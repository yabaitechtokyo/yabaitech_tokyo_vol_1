@require: itemize
@import: local
@import: bib

let lstar = '<+section{L\*アルゴリズム} <
+p {
  前節で定義した正規言語をDFAの形式で人間が書くことも当然できますが、これ以降この文書では未知の正規言語を学習するという問題を主に考えます。機械学習の教師付き二値分類問題では「正例と負例からなる訓練用データを与えて、訓練用以外のデータについても高い確率で正しく分類する」という問題設定が良く用いられますが、ここでは\emph{exact learning}と呼ばれる学習を考えます。Exact learningでは、未知の正規言語を近似する正規言語を学習するのではなく、未知の正規言語と完全に等しい正規言語を表現するDFAを学習します。ここで、任意の文字列の有限集合は正規言語であるので、有限個の訓練用データを与えても本当に学習したい正規言語に辿り着くのは難しそうです。本節では (というよりexact learningの文脈ではしばしば) 、訓練用データの代わりに次の二つの質問を神託に聞くことを通して学習を行なう、という設定を考えます。現実的にこんなことがわかる神託をどうやって作るのか、という問題はここでは考えません。
}
+p{
\listing{
* 所属性質問 (membership query): 文字列 ${w \in \alphabet^\ast} を神託に与えて、${w} が学習したい言語 ${L\subseteq \alphabet^\ast} に含まれているか (${w \in L})を問う質問。
* 等価性質問 (equivalence query): 正規言語 ${L' \subseteq \alphabet^\ast} を神託に与えて、${L'} が学習したい言語 ${L} と等しいかどうかを問う質問。${L'\neq L}である場合には反例 ${w\in \alphabet^\ast}、つまり ${w\in L \triangle L'} を充たす最短の文字列 ${w} が返る。ここで${\triangle}は集合の対称差の記号である。
}
}
+p {
  本節では例として ${L = \{ a \in \{\text!{a,b}\} \mid \text!{a, bの個数が共に偶数}\}} を用います。例えば図\ref(`fig:evenDFA`);のDFAがこの言語を認識します。

  \figure ?:(`fig:evenDFA`){a, bの個数が共に偶数の文字列の言語を認識するDFAの例。}<
     +image-frame{\insert-pdf-image(7cm)(`figs/evenDFA.pdf`)(1);}
  >
}
+subsection{観察表} <
+p {
  L\* アルゴリズムでは \emph{観察表} (observation table) と呼ばれる表${T}に、各質問の結果を随時記入していくことで学習を進めていきます。観察表は表にある様に行、列が共に${\alphabet}上の文字列で添字付けされている表です。観察表の各セルには所属性質問の結果が記入されます。例えばセル${T\[w,w'\]}には文字列${w\cdot w'}の所属性質問の結果が記入されます。また、観察表にはほげ線より上側と下側の区別があります。ほげ線より上側の行の添字集合を${P\subseteq \alphabet^\ast},下側の添字集合を${P'\subseteq\alphabet^\ast},また、列の添字集合を${S\subseteq\alphabet^\ast}と呼びます。ほげ線より下側の各行ベクトルがほげ線より上側に表われているとき、つまり各${w'\in P'}について${T\[w,\text!{-}\]=T\[w',\text!{-}\]}を充たす${w\in P}が存在するとき、その観察表を\emph{閉じている}と言います。
}
+frame<
+centering{
\tabular(fun cellf multif empty -> [
[
cellf {} ;
cellf {${\epsilon}} ;
cellf {a} ;
];
[
cellf {${\epsilon}};
cellf {T};
cellf {F};
];
[
cellf {a};
cellf {F};
cellf {T};
];
[
cellf {b};
cellf {F};
cellf {F};
];
[
cellf {—————};
cellf {—————};
cellf {—};
];
[
cellf {aa};
cellf {T};
cellf {F};
];
[
cellf {ab};
cellf {F};
cellf {F};
];
[
cellf {ba};
cellf {F};
cellf {F};
];
[
cellf {bb};
cellf {T};
cellf {F};
];
          ])(fun xs ys -> (
              match (ys, List.reverse ys) with
              | (y0 :: y1 :: _, ylast :: _) ->
                  ( match (xs, List.reverse xs) with
                    | (x0 :: x1 :: _, xlast :: _) ->
                        let grlstY =
                          [y0; ylast] |> List.map (fun y ->
                            stroke 1pt Color.black (Gr.line (x0, y) (xlast, y)))
                        in
                        (stroke 0.5pt Color.black (Gr.line (x1, y0) (x1, ylast)))
                          :: (stroke 0.5pt Color.black (Gr.line (x0, y1) (xlast, y1))) :: grlstY

                    | _ -> []
                  )
              | _ -> []
          ));
  
}
>
>
+subsection{L\* アルゴリズム} <
+frame<
+centering{
\tabular(fun cellf multif empty -> [
[
cellf {} ;
cellf {${\epsilon}} ;
];
[
cellf {${\epsilon}};
cellf {};
];
          ])(fun xs ys -> (
              match (ys, List.reverse ys) with
              | (y0 :: y1 :: _, ylast :: _) ->
                  ( match (xs, List.reverse xs) with
                    | (x0 :: x1 :: _, xlast :: _) ->
                        let grlstY =
                          [y0; ylast] |> List.map (fun y ->
                            stroke 1pt Color.black (Gr.line (x0, y) (xlast, y)))
                        in
                        (stroke 0.5pt Color.black (Gr.line (x1, y0) (x1, ylast)))
                          :: (stroke 0.5pt Color.black (Gr.line (x0, y1) (xlast, y1))) :: grlstY

                    | _ -> []
                  )
              | _ -> []
          ));
  
}
>
+p {
  L\*アルゴリズムではまず始めに表の観察表から始めます。最初に空欄になっているセル${T\[\epsilon, \epsilon\]}を所属性質問を用いて埋め、同時に${P'}にa,bを追加し、同様に埋めます (表) 。
}
+frame<
+centering{
\tabular(fun cellf multif empty -> [
[
cellf {} ;
cellf {${\epsilon}} ;
];
[
cellf {${\epsilon}};
cellf {T};
];
[
cellf {—————};
cellf {—————};
];
[
cellf {a};
cellf {F};
];
[
cellf {b};
cellf {F};
];
          ])(fun xs ys -> (
              match (ys, List.reverse ys) with
              | (y0 :: y1 :: _, ylast :: _) ->
                  ( match (xs, List.reverse xs) with
                    | (x0 :: x1 :: _, xlast :: _) ->
                        let grlstY =
                          [y0; ylast] |> List.map (fun y ->
                            stroke 1pt Color.black (Gr.line (x0, y) (xlast, y)))
                        in
                        (stroke 0.5pt Color.black (Gr.line (x1, y0) (x1, ylast)))
                          :: (stroke 0.5pt Color.black (Gr.line (x0, y1) (xlast, y1))) :: grlstY

                    | _ -> []
                  )
              | _ -> []
          ));
  
}
>
+p {
  ここで表の観察表が閉じているかを判定します。今回は行 aの行ベクトルがほげ線の上側の何れの行ベクトルとも一致しないので閉じていません。そこで閉じていない原因の行aをほげ線の上側に移動します。このとき各${\{a \cdot \sigma \mid \sigma \in \alphabet\}}を添字とする列が${P}と${P'}のどちらにもに存在しない場合、その存在しない添字を${P'}に追加します (表) 。
}
+frame<
+centering{
\tabular(fun cellf multif empty -> [
[
cellf {} ;
cellf {${\epsilon}} ;
];
[
cellf {${\epsilon}};
cellf {T};
];
[
cellf {a};
cellf {F};
];
[
cellf {—————};
cellf {—————};
];
[
cellf {b};
cellf {F};
];
[
cellf {aa};
cellf {T};
];
[
cellf {ab};
cellf {F};
];
          ])(fun xs ys -> (
              match (ys, List.reverse ys) with
              | (y0 :: y1 :: _, ylast :: _) ->
                  ( match (xs, List.reverse xs) with
                    | (x0 :: x1 :: _, xlast :: _) ->
                        let grlstY =
                          [y0; ylast] |> List.map (fun y ->
                            stroke 1pt Color.black (Gr.line (x0, y) (xlast, y)))
                        in
                        (stroke 0.5pt Color.black (Gr.line (x1, y0) (x1, ylast)))
                          :: (stroke 0.5pt Color.black (Gr.line (x0, y1) (xlast, y1))) :: grlstY

                    | _ -> []
                  )
              | _ -> []
          ));
  
}
>
+p {
  今回は観察表が閉じました。観察表が閉じている場合、次のルールに従って観察からDFAを生成することができます。
}
+p{
\listing{
* 各${w\in P}に対して、DFAの状態${q_w}を生成する
* DFAの初期状態は${q_{\epsilon}}とする
* DFAの受理状態は${T\[w,\epsilon\] = \top}となる状態${q_w}とする
* DFAの遷移関数${\mathrm{\Delta}\(q_w,a\)}は、${w\cdot a}がほげ線の上側に存在する場合${\mathrm{\Delta}\(q_w,a\)=q_{w\cdot a}}とし、そうでない場合${T\[w\cdot a,\text!{-}\] = T\[w',\text!{-}\]}を充たすほげ線の上側の列${T\[w',\text!{-}\]}について、${\mathrm{\Delta}\(q_w,a\)=q_{w'}}とする。
}
}
+p {
  例えば表の観察表からは図\ref(`fig:evenDFAStep1`);のDFA、${\mathcal{A}_1}が生成されます。

  \figure ?:(`fig:evenDFAStep1`){表の観察表に対応するDFA${\mathcal{A}_1}}<
     +image-frame{\insert-pdf-image(7cm)(`figs/evenDFAStep1.pdf`)(1);}
  >
}
+p {
  DFAを一つ生成することができたので等価性質問によってこのDFAが正解の正規言語を認識するかどうかを調べてみます。今回、DFA${\mathcal{A}_1}は言語${L}を認識しないので、最短の反例 ba が返ります。次に反例 baがどの位置から表のほげ線より上側と食い違ったかを見てみます。今回は${T\[\text!{b,-}\]= T\[\text!{a,-}\]}で、実際${b\nin L}と${a\nin L}が成り立ちますが、${ba\nin L}、${aa \in L}となるので末尾のaでと表食い違いました。これはつまり現在の状態の受理・非受理のみではなく、現在の状態からaを読んだときの受理・非受理も考慮する必要があるということになります。これを表わすために観察表の列にaを加え、先と同様に観察表が閉じるまで所属性質問を繰り返します (表) 。
}
+frame<
+centering{
\tabular(fun cellf multif empty -> [
[
cellf {} ;
cellf {${\epsilon}} ;
cellf {a} ;
];
[
cellf {${\epsilon}};
cellf {T};
cellf {F};
];
[
cellf {a};
cellf {F};
cellf {T};
];
[
cellf {b};
cellf {F};
cellf {F};
];
[
cellf {————};
cellf {————};
cellf {—};
];
[
cellf {aa};
cellf {T};
cellf {F};
];
[
cellf {ab};
cellf {F};
cellf {F};
];
[
cellf {ba};
cellf {F};
cellf {F};
];
[
cellf {bb};
cellf {T};
cellf {F};
];
          ])(fun xs ys -> (
              match (ys, List.reverse ys) with
              | (y0 :: y1 :: _, ylast :: _) ->
                  ( match (xs, List.reverse xs) with
                    | (x0 :: x1 :: _, xlast :: _) ->
                        let grlstY =
                          [y0; ylast] |> List.map (fun y ->
                            stroke 1pt Color.black (Gr.line (x0, y) (xlast, y)))
                        in
                        (stroke 0.5pt Color.black (Gr.line (x1, y0) (x1, ylast)))
                          :: (stroke 0.5pt Color.black (Gr.line (x0, y1) (xlast, y1))) :: grlstY

                    | _ -> []
                  )
              | _ -> []
          ));
  
}
>
+frame<
+centering{
\tabular(fun cellf multif empty -> [
[
cellf {} ;
cellf {${\epsilon}} ;
cellf {a} ;
cellf {b} ;
];
[
cellf {${\epsilon}};
cellf {T};
cellf {F};
cellf {F};
];
[
cellf {a};
cellf {F};
cellf {T};
cellf {F};
];
[
cellf {b};
cellf {F};
cellf {F};
cellf {T};
];
[
cellf {ab};
cellf {F};
cellf {F};
cellf {F};
];
[
cellf {————};
cellf {————};
cellf {—};
cellf {—};
];
[
cellf {aa};
cellf {T};
cellf {F};
cellf {F};
];
[
cellf {ba};
cellf {F};
cellf {F};
cellf {F};
];
[
cellf {bb};
cellf {T};
cellf {F};
cellf {F};
];
[
cellf {aba};
cellf {F};
cellf {F};
cellf {T};
];
[
cellf {abb};
cellf {F};
cellf {T};
cellf {F};
];
          ])(fun xs ys -> (
              match (ys, List.reverse ys) with
              | (y0 :: y1 :: _, ylast :: _) ->
                  ( match (xs, List.reverse xs) with
                    | (x0 :: x1 :: _, xlast :: _) ->
                        let grlstY =
                          [y0; ylast] |> List.map (fun y ->
                            stroke 1pt Color.black (Gr.line (x0, y) (xlast, y)))
                        in
                        (stroke 0.5pt Color.black (Gr.line (x1, y0) (x1, ylast)))
                          :: (stroke 0.5pt Color.black (Gr.line (x0, y1) (xlast, y1))) :: grlstY

                    | _ -> []
                  )
              | _ -> []
          ));
  
}
>
+p {
  \figure ?:(`fig:evenDFAStep2`){表の観察表に対応するDFA${\mathcal{A}_2}}<
     +image-frame{\insert-pdf-image(7cm)(`figs/evenDFAStep2.pdf`)(1);}
  >
  \figure ?:(`fig:evenDFAStep3`){表の観察表に対応するDFA${\mathcal{A}_3}}<
     +image-frame{\insert-pdf-image(7cm)(`figs/evenDFA.pdf`)(1);}
  >
  
  表から生成されるDFAについて等価性質問を問い合わせると学習したい言語と一致するので、今回の学習はここで終了となります。ここまでの流れだけを見ると今回たまたま上手く行っただけで、この学習が有限回で停止しない場合もあるのではないかと疑問に思うと思われますが、実は常に有限回 (より正確には多項式回)で停止しますし、更にはこの方法で生成されるDFAは与えられた言語を認識するDFAのなかで状態数が最小となることもわかります。これらの点について次に説明していきます。
}
>
+subsection{Myhill-Nerodeの定理とDFAの最小性} <
+p {
  さて、L\*アルゴリズムの停止性を見るために、まずは正規言語の"有限らしさ"の特徴付けであるMyhill-Nerodeの定理を見ていきます。
}
+definition ?:({Myhill-Nerode同値関係}) ?:(`myhill-nerode同値関係`)
{
  有限文字集合${\alphabet}上の言語${L}について、\emph{Myhill-Nerode同値関係}${R_L\subseteq\alphabet^\ast\times\alphabet^\ast}を、次のように定義する。文字列${w,w'\in\alphabet^\ast}について${w R_L w'}が成り立つのは以下のときである。
}
+math(${
\forall w'' \in \alphabet^\ast.\, w \cdot w'' \in L \Leftrightarrow w'\cdot w'' \in L 
});
+theorem ?:({Myhill-Nerodeの定理}) ?:(`myhill-nerodeの定理`)
{
  有限文字集合${\alphabet}上の言語${L}について、${L}が正規言語であることの必要十分条件は、商集合${L/R_L}が有限集合となることである。
}
+p {
  TODO: 木を使ってMNを説明する
}
+p {
  さて、Myhill-Nerodeの定理の立場からL\*アルゴリズムの観察表を見ていきます。まず、各${w\in P}について行ベクトル${T\[w,\text!{-}\]}は互いに異なる、つまり適宜末尾に文字列を加えたときの受理/非受理の関係が異なるので、${P}の要素数は${L/R_L}の要素数以下になり、${L}が正規言語であるとならば上限が存在します。各${P'}の要素は${P}の要素に一文字付け加えたものであるので、${\|P'\|\leq\|P\|\times\|\alphabet\|}となります。また、${S}に添字${w'}を追加する際は${w'}を追加することで新たに食い違うような${w'}のみを追加する、つまり各${w\in S}について${T\[u,w\]=T\[u',w\]}であるが${T\[u,w'\]\neq T\[u',w'\]}である様な${u,u' \in P}が存在するときのみ${w'}を${S}に追加します。従って、${\|S\|\leq \|L/R_L\|}も成立します。更に観察表を閉じる際及び等価性質問の結果反例が返って来た際には${P}と${S}の大きさが1以上増えます。以上よりL\*アルゴリズムは${L}が正規言語であれば常に停止し、${L\(\mathcal{A}\)=L}を充たすDFA${\mathcal{A}}を返することがわかります。また、L\*アルゴリズムが生成するDFAの状態数は${\|P\|}ですが、${L\(\mathcal{A}\)=L}を充たす任意のDFAの状態数は${L/R_L}以下であることから、${\mathcal{A}}は${L\(\mathcal{A}\)=L}を充たす状態数が最小のDFAであることもわかります。
}
>
>>
