@require: math
@require: proof

module ZptMath : sig
  direct \cdot : [] math-cmd
  direct \ldots : [] math-cmd
  direct \imp : [] math-cmd
  direct \imp2 : [] math-cmd
  direct \semicolon : [] math-cmd
  direct \ipc : [math; math] math-cmd
  direct \adj1 : [math; math; math] math-cmd
  direct \adj2 : [math; math] math-cmd
  direct \adj-up : [math] math-cmd
  direct \adj-down : [math] math-cmd
  direct \ipckm : [math list; math] math-cmd
  direct \modald : [math; math; math] math-cmd
  direct \repeat : [int; inline-text] inline-cmd
  direct \fmodal : [math] math-cmd
  direct \dmodal : [math] math-cmd
  direct \todo : [inline-text] inline-cmd
  direct \derive : [inline-text?; math list; math] math-cmd

end = struct
  let bin = math-char MathBin

  let-math \cdot = bin `⋅`
  let-math \ldots = bin `…`

  let-math \imp = ${\rightarrow}
  let-math \imp2 = ${\Rightarrow}
  let-math \semicolon = math-char MathBin `;`

  let-math \ipc ant succ = ${
    #ant \vdash #succ
  }

  let-math \adj1 ant1 ant2 succ = ${
    #ant1 \semicolon #ant2 \vdash_1 #succ
  }

  let-math \adj2 ant succ = ${
    #ant \vdash_2 #succ
  }

  let-rec make-modal-judgment
    | [] succ = ${\vdash #succ}
    | (x :: []) succ = ${#x \vdash #succ}
    | (x :: xs) succ = let rest = make-modal-judgment xs succ in
                           ${#x \semicolon #rest}

  let-math \ipckm andl succ = make-modal-judgment andl succ

  let-math \modald ant1 ant2 succ = ${
    #ant1 \semicolon #ant2 \vdash #succ
  }

  let-rec repeat-inline ibacc n ib =
    if n <= 0 then ibacc else
      repeat-inline (ibacc ++ ib) (n - 1) ib

  let-inline ctx \repeat n inner =
    let ib = read-inline ctx inner in
      repeat-inline inline-nil n ib

  let-math \adj-up p = ${\uparrow #p}

  let-math \adj-down p = ${\downarrow #p}

  let-math \fmodal p = let box = bin `□` in ${#box #p}
  let-math \dmodal p = let box = bin `■` in ${#box #p}

  let-inline ctx \todo text =
    let ctx-red = ctx |> set-text-color Color.red in
      read-inline ctx-red {TODO: #text;}

  let myderive nameopt mlst m=
    match nameopt with
    | None -> ${\derive !(mlst) !(m)}
    | Some(name) -> ${\derive ?:{\text!{\ (#name;)}} !(mlst) !(m)}

  let-math \derive ?:nameopt mlst m =
    myderive nameopt mlst m
  
end
