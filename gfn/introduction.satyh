@import: settings

let introduction = '<
  +section{\SATySFi;の開発動機}<
    +p{
      まずは「\SATySFi;がそもそもなぜマークアップ言語とその処理系という形態をとることを選んだのか」，そして
      「既存のマークアップ言語やその処理系では不満足だった，\SATySFi;で解決されるべき課題は何か」という点から書こう．
      そのためには，マークアップ言語＋処理系という形態が一般論として他の形態と比べ
      どんな利点をもち得てどんな弱点を本質的にもたざるを得ないか，
      そして既存のマークアップ言語はその利点を活かせていてその弱点を或る程度克服できているか，
      ということについて見ていく必要がある．
    }
    +subsection{マークアップ方式の利点と弱点}<
      +p{
        この本を手に取った方ならおそらくよくご存知のとおり，一口に組版処理システムといっても大きく分けて
        \listing{
          * GUIの画面上に版面がプレヴューされた状態で文書を記述していく\dfn{WYSIWYG}エディタ方式

          * マークアップ言語によってテキストファイルとして文書を記述し，
            言語処理系に入力として与えて最終的にPDFなどの形式で版面を出力する方式
        }%
        の2つがある．具体的には\TeX;/\LaTeX;, troff, Markdownなどが前者にあたり，
        Microsoft Office Word, Adobe InDesign, QuarkXpressなどが後者に該当する．
      }
      +p{
        “マークアップ言語方式とWYSIWYG方式とのいずれが優れているのか” に関する議論は
        （少なくとも一方には触れるユーザが多いためか）頻繁に目にし，もはや大喜利の様相を呈している場合もあるが，
        実際にはそれぞれの方式に利点と弱点のトレードオフがあるといってよいと考えられる．
        WYSIWYG方式に比べたマークアップ言語方式一般の利点としては，あくまでも傾向ではあるものの
        \listing{
         * 入力がテキストファイルなので差分管理が簡単
         * ユーザ定義コマンドにより：
           ** 複雑な自動処理が実現できる
           ** 文書の内容を変更せずに後から体裁を柔軟に変更しやすい
        }%
        といったことが挙げられる．したがって，これらの恩恵を活かして文書を作成したい場合が
        マークアップ言語の想定ユースケースということになる．
        特に，文書内容を文書の体裁からできるだけ独立したものとして記述したいという\dfn{意味マークアップ}の志向が強いユーザにとっては
        これらの性質は望ましいものである．
      }
      +p{
        一方で弱点としては
        \listing{
          * 直接版面を見ながら執筆できるわけではないため，執筆作業がしばしば直観的でない
          * ユーザが不適格なコードを入力として与えやすい
        }%
        といった点が挙げられるであろう．1点目については，組版処理システムを
        WYSIWYG方式，マークアップ言語方式と大別せず両者を融合したようなハイブリッド方式のソフトウェアを創るという方針によって
        緩和できるように考えられる．
        これは既存のソフトウェアでは\dfn{LyX} \cite[`LyX`];のような仕組みが該当し，
        今後組版処理システムを発達させていく上でも有望な方針といえそうである．
        ただし，LyXが\LaTeX;というマークアップ方式の組版処理システムの存在を前提としているように，
        順序としてはまず純粋なマークアップ言語とその処理系が発達してから
        このようなハイブリッド方式が発達していく余地ができるもの，という側面が強い
        （先走って述べると，\SATySFi;はこのハイブリッド方式の方針を採らずに純粋なマークアップ方式として組版処理システムを実現したが，
        それはこのような側面を念頭に置いたためである）．
      }
      +p{
        より注目すべきマークアップ方式の弱点は2点目である．
        WYSIWYG方式ではそもそも妥当な操作しかGUI上でユーザに提供しないことによって
        ユーザが不適格な入力をしえない仕組みを構築することができるのに対し，
        マークアップ方式ではその性質上任意のテキストが入力として渡せるので，
        ユーザが不適格なコードを与えてしまえるのである．
        さらに広く言えば不適格なコードだけでなく意図しないコード全般を与えてしまいうるのだが，
        ユーザが意図していない入力のうち処理系にとっては適格なコードは
        間違いを検出することが（少なくとも機械学習のような統計的な手法によらない限り原理的に）できないし，
        これはユーザ自身が出力された版面を見て確かめるしかない．
        これに対し，処理系にとっても不適格なコード，すなわちコマンドの引数の与え方がおかしいといったミスは，
        処理系が（非統計的な，“クリスプな” 手法により）見つけることができるから，これをユーザに報告して修正を仰ぐことができる．
        つまり，ユーザが意図しないコードを与えてしまいやすいという弱点が本質的にあるマークアップ言語という方式では，
        処理系にとって不適格なコードが入力として渡された場合にどのようなエラー報告を行ない修正方法を示唆するかが
        ユーザの執筆効率に多大な影響をもたらすと考えてよいであろう．
      }
      +p{
        ところが，このエラー報告に関して既存のマークアップ方式の組版処理システムには不十分な点が見受けられる．
        これを次節でより詳細に扱う．
      }
    >
    +subsection ?:(`problem1`) {既存システムの問題点1：エラー報告能力}<
      +p{
        前節で既に述べたように，マークアップ言語には

        \listing{
          * ユーザが不適格なコードを入力として与えやすい
        }%

        という本質的に避けにくい弱点があり，不適格な入力に対してどのようにエラー報告するかがユーザの執筆効率に大きく関わる．
        しかし，既存のマークアップ言語方式の組版処理システムでは，
        この不適格な入力に対するエラー報告がわかりにくいという傾向がある．
        特に\LaTeX;の場合を例に挙げると，以下のようなものはユーザにとって親の顔よりも見たエラーログだ：
      }
      +console(`! Undefined control sequence.`);%
      +console(`! Missing $ inserted.`);%
      +console(`! Missing number, treated as zero.`);%
      +p{
        場合によっては原因がすぐわかることもあるが，
        基本的には「組版処理中に初めて不整合が生じた」ときにエラーが報告される仕組みなので，
        ユーザの与り知らない，コマンドの実装内の記述と与えた引数との不整合によるエラーが直接報告されることも多い．
        「第${n}行目までで何かがおかしい」という程度の情報しか直ちには得られないことも多く，
        このような状況におかれてはもはやコードをコメントアウトしながら二分探索して原因の場所を特定するしかない．
      }
      +p{
        エラー報告は不親切なだけでなく提示されるまでに時間を要することも多い．
        やはり「組版処理中に初めて不整合が生じた」ときにエラーが報告されるのが要因で，
        例えば500ページの文書を\LaTeX;で組む際に490ページ目にあたる部分に不適格な記述を書いてしまった場合は
        490ページ分の組版処理の後にエラーが提示されるため，ユーザは入力ミスの存在を知らされるまで
        短めに見積もっても数十秒から数分程度は待つことになる．
      }
      +p{
        また，このエラーの原因が直ちに汲み取りにくいという傾向はエンドユーザだけでなくパッケージ開発者にとっても深刻な問題である．
        パッケージ開発者は多くの場合複雑な処理を簡潔なインターフェイスとして提供するためにパッケージを実装し，
        当然ながらその実装過程に於いて複雑な処理が意図どおり記述できているか具体的な文書例を作成してデバッグする．
        この際に，エラー報告が不親切であるがゆえに，どのように修正すればよいかがエラー報告からまるで見当がつかないことも極めて多く，
        パッケージ開発者は修正に四苦八苦することを強いられてしまう．
        このようにして不親切なエラー報告はパッケージ開発者の実装にも大きく支障をきたすのである．
      }
    >
    +subsection ?:(`problem2`) {既存システムの問題点2：コマンド定義の可読性}<
      +p{
        ここまで述べたエラー報告についての弱点とは別に，
        マークアップ方式をとっている既存の組版処理システムに対する別の不満点としてはコマンド定義等を記述したコードの可読性が挙げられる．
        マークアップ言語の利点の傾向のひとつとして

        \listing{
         * ユーザ定義コマンドにより：
           ** 複雑な自動処理が実現できる
           ** 文書の内容を変更せずに後から体裁を柔軟に変更しやすい
        }%

        という性質を挙げていたものの，
        注意すべきはこのコマンド定義は必ずしも簡単に書けたり読んで修正できたりするとは限らないということである．
        例えば\TeX;/\LaTeX;ではコマンド定義機能が提供されていて，多少の自動処理であれば簡単にコマンド定義として書くことができるが，
        少し凝った自動処理を書くにはかなりの工夫を要し，とても直観的に単純とはいえないコードを書く必要がある．
        複雑な自動処理を行なうコマンド定義は書く側にとっても負担であるが，
        他人の手によって書かれたコマンド定義を読んで修正したい人にとってはさらに大変な苦労を強いられることになる．
        \TeX;/\LaTeX;の場合，もはや書いた本人以外誰も読んで把握することができないのではなかろうかと思われるようなコードは
        ごく普通にパッケージ群の奥底にある．
      }
    >
    +subsection?:(`problem`){問題意識の総括}<
      +p{
        結局，ここまで追ってきた議論を簡潔にまとめると，以下のようになる：

        \listing{
          * マークアップ言語は（論文の執筆等の文書作成時に積極的に援用される志向である）意味マークアップの観点からは
            WYSIWYGエディタと比べて望ましい形態である
          * マークアップ言語とWYSIWYGエディタを融合した形態で両者の利点をいいとこ取りした組版処理システムが
            将来的には実現できるかもしれないが，
            LyXの例を見るに，そのようなソフトウェアは堅牢なマークアップ言語が土台にあってはじめて実現できるように思われるから，
            先に便利なマークアップ言語を確立しておく必要がある
          * しかし，既存のマークアップ言語は
            ** エラー報告機能が不親切で遅いため，ユーザの文書執筆やパッケージ開発の効率があまり良いとはいえない
            ** コマンド定義を記述したコードの可読性がしばしば著しく低く，変更や修正がしづらい
        }%

        そこでこれを解決した便利なマークアップ言語として\SATySFi;を実現しよう，というわけである．
      }
    >
    +subsection{\SATySFi;が選んだ解決策}<
      +p{
        \ref-subsection(`problem`);で述べた問題点を解消するため，

        \listing{
          * コマンド定義を記述したコードの可読性が高くカスタマイズしやすい
          * ユーザが不適格な入力を与えたときのエラー報告が素早く，わかりやすく提示される
        }%

        という性質を備えた新たなマークアップ言語方式の組版処理システムが\SATySFi;である．
        “主にコマンド定義用の言語” と “主に文書を書くための言語” の
        2層を切り分けて言語を設計し，
        この言語に対する処理系として\SATySFi;が実装されている．
        文書を書くための層は見た目上おおよそ\LaTeX;に近い設計にした一方で，
        コマンド定義用の層はいわゆる函数型プログラミングに便利な言語仕様，
        すなわち函数型言語らしい言語仕様をベースとして
        コア言語を設計・実装することでシステムの基礎づけを与え，
        これにより

        \listing{
          * グローバルな状態をあまり意識せず，
            局所的な処理にだけ気を遣ってコマンド定義が読み書きできる
          * 強力な型システムを搭載しやすい
        }%

        といった函数型言語であることによる恩恵を一気に享受することで上記の性質を達成した．
        この言語は，函数型言語の中でも特に\dfn{OCaml}や\dfn{F\#}に近い言語設計となっている．
        処理系は大きく分けて

        \listing{
          * ユーザやパッケージ開発者による不適格な入力を検出してエラーとして報告するフロントエンド
            （構文解析器や型検査器）
          * フロントエンドでの検査を通った入力を実際に組版処理を施してPDFを出力するバックエンド
        }%

        からなっている．
      }
      +p{
        また，このような構成の組版処理システムを実装するだけでなく，
        実装した成果をオープンソースなソフトウェアとして公開することも重要だ．
        主な理由は

        \listing{
          * ユーザが無償で組版処理システムを使えるようにすることに重大な意義があると考えられるため
          * 開発した組版処理システムの改善・拡張を活発化させるため
        }%

        なのだが，このうち特に2点目が重要である．
        多言語組版の実現などを念頭に置くと組版処理システムに必要な機能はきわめて多岐にわたり，
        あらゆる観点で万全なものとして完成させるには著者1人で創りきれる規模とはいえず，
        オープンソースにすることでシステム内部でどのような処理が行なわれているか
        誰でも実装を読んで理解でき，
        改善が必要であると感じた場合には
        積極的に開発に参加しうるような環境が必要なのである．
      }
      +p{
        最初からあらゆる観点で万全な組版処理システムにすることが現実的に困難なのは，
        これまで数十年規模で多くの開発者の手によって開発・保守されてきた\TeX;の派生システムでも
        未だにバグ修正や機能の拡張などに取り組まれていることからほぼ明らかであろう．
        \SATySFi;は
        多言語組版が可能な組版処理システムの基礎づけを与えることを主目的とし，
        まずは日本語を母語とする著者にとっても個人的に馴染みの深い
        和文・欧文の混植が実用に堪える程度満足にできることを目標として開発することとした．
      }
    >
  >
>
