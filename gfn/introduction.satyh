@import: settings

let introduction = '<
  +p{
    まずは
    「\SATySFi;がそもそもなぜマークアップ言語とその処理系という形態をとることを選んだのか」，
    そして
    「既存のマークアップ言語やその処理系では不満足だった，
    \SATySFi;で解決されるべき課題は何か」という点から書こう．
    そのためには，マークアップ言語＋処理系という形態が一般論として他の形態と比べ
    どんな利点をもち得てどんな弱点を本質的にもたざるを得ないか，
    そして既存のマークアップ言語はその利点を活かせていてその弱点を或る程度克服できているか，
    ということについて見ていく必要がある．
  }
  +section{マークアップ方式の利点と弱点}<
    +p{
      この本を手に取った方ならおそらくよくご存知のとおり，一口に組版処理システムといっても大きく分けて
      \listing{
        * GUIの画面上に版面がプレヴューされた状態で文書を記述していく\dfn{WYSIWYG}エディタ方式

        * マークアップ言語によってテキストファイルとして文書を記述し，
          言語処理系に入力として与えて最終的にPDFなどの形式で版面を出力する方式
      }%
      の2つがある．具体的には\TeX;/\LaTeX;, troff, Markdownなどが前者にあたり，
      Microsoft Office Word, Adobe InDesign, QuarkXpressなどが後者に該当する．
    }
    +p{
      “マークアップ言語方式とWYSIWYG方式とのいずれが優れているのか” に関する議論は
      （少なくとも一方には触れるユーザが多いためか）頻繁に目にし，
      もはや大喜利の様相を呈している場合もあるが，
      実際にはそれぞれの方式に利点と弱点のトレードオフがあるといってよいと考えられる．
      WYSIWYG方式に比べたマークアップ言語方式一般の利点としては，あくまでも傾向ではあるものの
      \listing{
       * 入力がテキストファイルなので差分管理が簡単
       * ユーザ定義コマンドにより：
         ** 複雑な自動処理が実現できる
         ** 文書の内容を変更せずに後から体裁を柔軟に変更しやすい
      }%
      といったことが挙げられる．したがって，これらの恩恵を活かして文書を作成したい場合が
      マークアップ言語の想定ユースケースということになる．
      特に，文書内容を文書の体裁からできるだけ独立したものとして記述したいという
      \dfn{意味マークアップ}の志向が強いユーザにとっては
      これらの性質は望ましいものである．
    }
    +p{
      一方で弱点としては
      \listing{
        * 直接版面を見ながら執筆できるわけではないため，執筆作業がしばしば直観的でない
        * ユーザが不適格なコードを入力として与えやすい
      }%
      といった点が挙げられるであろう．1点目については，組版処理システムを
      WYSIWYG方式，マークアップ言語方式と大別せず
      両者を融合したようなハイブリッド方式のソフトウェアを創るという方針によって
      緩和できるように考えられる．
      これは既存のソフトウェアでは\dfn{LyX} \cite[`LyX`];のような仕組みが該当し，
      今後組版処理システムを発達させていく上でも有望な方針といえそうである．
      ただし，LyXが\LaTeX;というマークアップ方式の組版処理システムの存在を前提としているように，
      順序としてはまず純粋なマークアップ言語とその処理系が発達してから
      このようなハイブリッド方式が発達していく余地ができるもの，という側面が強い
      （先走って述べると，\SATySFi;はこのハイブリッド方式の方針を採らずに
      純粋なマークアップ方式として組版処理システムを実現したが，
      それはこのような側面を念頭に置いたためである）．
    }
    +p{
      より注目すべきマークアップ方式の弱点は2点目である．
      WYSIWYG方式ではそもそも妥当な操作しかGUI上でユーザに提供しないことによって
      ユーザが不適格な入力をしえない仕組みを構築することができるのに対し，
      マークアップ方式ではその性質上任意のテキストが入力として渡せるので，
      ユーザが不適格なコードを与えてしまえるのである．
      さらに広く言えば不適格なコードだけでなく意図しないコード全般を与えてしまいうるのだが，
      ユーザが意図していない入力のうち処理系にとっては適格なコードは
      間違いを検出することが
      （少なくとも機械学習のような統計的な手法によらない限り原理的に）できないし，
      これはユーザ自身が出力された版面を見て確かめるしかない．
      これに対し，処理系にとっても不適格なコード，
      すなわちコマンドの引数の与え方がおかしいといったミスは，
      処理系が（非統計的な，“クリスプな” 手法により）見つけることができるから，
      これをユーザに報告して修正を仰ぐことができる．
      つまり，ユーザが意図しないコードを与えてしまいやすいという
      弱点が本質的にあるマークアップ言語という方式では，
      処理系にとって不適格なコードが入力として渡された場合に
      どのようなエラー報告を行ない修正方法を示唆するかが
      ユーザの執筆効率に多大な影響をもたらすと考えてよいであろう．
    }
    +p{
      ところが，このエラー報告に関して既存のマークアップ方式の組版処理システムには
      不十分な点が見受けられる．
      これを次節でより詳細に扱う．
    }
  >
  +section ?:(`problem1`) {既存システムの問題点1：エラー報告能力}<
    +p{
      前節で既に述べたように，マークアップ言語には

      \listing{
        * ユーザが不適格なコードを入力として与えやすい
      }%

      という本質的に避けにくい弱点があり，不適格な入力に対してどのようにエラー報告するかがユーザの執筆効率に大きく関わる．
      しかし，既存のマークアップ言語方式の組版処理システムでは，
      この不適格な入力に対するエラー報告がわかりにくいという傾向がある．
      特に\LaTeX;の場合を例に挙げると，以下のようなものはユーザにとって親の顔よりも見たエラーログだ：
    }
    +console(`! Undefined control sequence.`);%
    +console(`! Missing $ inserted.`);%
    +console(`! Missing number, treated as zero.`);%
    +p{
      場合によっては原因がすぐわかることもあるが，
      基本的には「組版処理中に初めて不整合が生じた」ときにエラーが報告される仕組みなので，
      ユーザの与り知らない，
      コマンドの実装内の記述と与えた引数との不整合によるエラーが直接報告されることも多い．
      「第${n}行目までで何かがおかしい」という程度の情報しか直ちには得られないことも多く，
      このような状況におかれては
      もはやコードをコメントアウトしながら二分探索して原因の場所を特定するしかない．
    }
    +p{
      エラー報告は不親切なだけでなく提示されるまでに時間を要することも多い．
      やはり「組版処理中に初めて不整合が生じた」ときにエラーが報告されるのが要因で，
      例えば500ページの文書を\LaTeX;で組む際に490ページ目にあたる部分に
      不適格な記述を書いてしまった場合は
      490ページ分の組版処理の後にエラーが提示されるため，ユーザは入力ミスの存在を知らされるまで
      短めに見積もっても数十秒から数分程度は待つことになる．
    }
    +p{
      また，このエラーの原因が直ちに汲み取りにくいという傾向は
      エンドユーザだけでなくパッケージ開発者にとっても深刻な問題である．
      パッケージ開発者は多くの場合複雑な処理を
      簡潔なインターフェイスとして提供するためにパッケージを実装し，
      当然ながらその実装過程に於いて複雑な処理が意図どおり記述できているか
      具体的な文書例を作成してデバッグする．
      この際に，エラー報告が不親切であるがゆえに，
      どのように修正すればよいかがエラー報告からまるで見当がつかないことも極めて多く，
      パッケージ開発者は修正に四苦八苦することを強いられてしまう．
      このようにして不親切なエラー報告はパッケージ開発者の実装にも大きく支障をきたすのである．
    }
  >
  +section ?:(`problem2`) {既存システムの問題点2：コマンド定義の可読性}<
    +p{
      ここまで述べたエラー報告についての弱点とは別に，
      マークアップ方式をとっている既存の組版処理システムに対する別の不満点としてはコマンド定義等を記述したコードの可読性が挙げられる．
      マークアップ言語の利点の傾向のひとつとして

      \listing{
       * ユーザ定義コマンドにより：
         ** 複雑な自動処理が実現できる
         ** 文書の内容を変更せずに後から体裁を柔軟に変更しやすい
      }%

      という性質を挙げていたものの，
      注意すべきはこのコマンド定義は
      必ずしも簡単に書けたり読んで修正できたりするとは限らないということである．
      例えば\TeX;/\LaTeX;ではコマンド定義機能が提供されていて，
      多少の自動処理であれば簡単にコマンド定義として書くことができるが，
      少し凝った自動処理を書くにはかなりの工夫を要し，
      とても直観的に単純とはいえないコードを書く必要がある．
      複雑な自動処理を行なうコマンド定義は書く側にとっても負担であるが，
      他人の手によって書かれたコマンド定義を読んで修正したい人にとっては
      さらに大変な苦労を強いられることになる．
      \TeX;/\LaTeX;の場合，
      もはや書いた本人以外誰も読んで把握することができないのではなかろうかと
      思われるようなコードは
      ごく普通にパッケージ群の奥底にある．
    }
  >
  +section?:(`problem`){問題意識の総括}<
    +p{
      結局，ここまで追ってきた議論を簡潔にまとめると，以下のようになる：

      \listing{
        * マークアップ言語は
          （論文の執筆等の文書作成時に積極的に援用される志向である）意味マークアップの観点からは
          WYSIWYGエディタと比べて望ましい形態である

        * マークアップ言語とWYSIWYGエディタを融合した形態で
          両者の利点をいいとこ取りした組版処理システムが
          将来的には実現できるかもしれないが，
          LyXの例を見るに，そのようなソフトウェアは
          堅牢なマークアップ言語が土台にあってはじめて実現できるように思われるから，
          先に便利なマークアップ言語を確立しておく必要がある

        * しかし，既存のマークアップ言語は

          ** エラー報告機能が不親切で遅いため，
             ユーザの文書執筆やパッケージ開発の効率があまり良いとはいえない

          ** コマンド定義を記述したコードの可読性がしばしば著しく低く，変更や修正がしづらい
      }%

      そこでこれを解決した便利なマークアップ言語として\SATySFi;を実現しよう，というわけである．
    }
  >
  +section{\SATySFi;が選んだ解決策}<
    +p{
      \ref-subsection(`problem`);で述べた問題点を解消するため，

      \listing{
        * コマンド定義を記述したコードの可読性が高くカスタマイズしやすい
        * ユーザが不適格な入力を与えたときのエラー報告が素早く，わかりやすく提示される
      }%

      という性質を備えた新たなマークアップ言語方式の組版処理システムが\SATySFi;である．
      “主にコマンド定義用の言語” と “主に文書を書くための言語” の
      2層を切り分けて言語を設計し，
      この言語に対する処理系として\SATySFi;が実装されている．
      文書を書くための層は見た目上おおよそ\LaTeX;に近い設計にした一方で，
      コマンド定義用の層はいわゆる函数型プログラミングに便利な言語仕様，
      すなわち函数型言語らしい言語仕様をベースとして
      コア言語を設計・実装することでシステムの基礎づけを与え，
      これにより

      \listing{
        * グローバルな状態をあまり意識せず，
          局所的な処理にだけ気を遣ってコマンド定義が読み書きできる
        * 強力な型システムを搭載しやすい
      }%

      といった函数型言語であることによる恩恵を一気に享受することで上記の性質を達成した．
      この言語は，函数型言語の中でも特に\dfn{OCaml}や\dfn{F\#}に近い言語設計となっている．
      処理系は大きく分けて

      \listing{
        * ユーザやパッケージ開発者による不適格な入力を検出してエラーとして報告するフロントエンド
          （構文解析器や型検査器）
        * フロントエンドでの検査を通った入力を実際に組版処理を施してPDFを出力するバックエンド
      }%

      からなっている．
    }
    +p{
      また，このような構成の組版処理システムを実装するだけでなく，
      実装した成果をオープンソースなソフトウェアとして公開することも重要だ．
      主な理由は

      \listing{
        * ユーザが無償で組版処理システムを使えるようにすることに重大な意義があると考えられるため
        * 開発した組版処理システムの改善・拡張を活発化させるため
      }%

      なのだが，このうち特に2点目が重要である．
      多言語組版の実現などを念頭に置くと組版処理システムに必要な機能はきわめて多岐にわたり，
      あらゆる観点で万全なものとして完成させるには著者1人で創りきれる規模とはいえず，
      オープンソースにすることでシステム内部でどのような処理が行なわれているか
      誰でも実装を読んで理解でき，
      改善が必要であると感じた場合には
      積極的に開発に参加しうるような環境が必要なのである．
    }
    +p{
      最初からあらゆる観点で万全な組版処理システムにすることが現実的に困難なのは，
      これまで数十年規模で多くの開発者の手によって開発・保守されてきた\TeX;の派生システムでも
      未だにバグ修正や機能の拡張などに取り組まれていることからほぼ明らかであろう．
      \SATySFi;は
      多言語組版が可能な組版処理システムの基礎づけを与えることを主目的とし，
      まずは日本語を母語とする著者にとっても個人的に馴染みの深い
      和文・欧文の混植が実用に堪える程度満足にできることを目標として開発することとした．
    }
  >
  +section{エラー報告機能}<
    +p{
      以上のような動機のもとに開発した\SATySFi;によって実現された，
      ユーザの高い執筆効率を支える縁の下の力持ちとなるところの
      エラー報告機能についての特徴を具体例とともに紹介する．
      ユーザが以下のような出力をしようとしてわずかに間違った記述を入力に含めてしまった場合を考え，
      \LaTeX;と\SATySFi;でどのようにエラー報告が異なるかを見てみる．
    }
    +d-block<
      +p {
        いろは歌：
        \fbox{\parbox ?:(Top) (5cm) <
          +p { 色は匂へど散りぬるを，吾が世誰ぞ恒ならむ．
               有為の奥山今日越えて，浅き夢見じ，酔ひもせず． }
        >}
      }
    >
    +p{
      まず，\LaTeX;の場合（特にp\LaTeX;を用いることにする）の
      正しい出力を得られるコードは以下のとおりである：

      \d-code(```
        % -*- coding: utf-8 -*-
        \documentclass{jsarticle}
        \usepackage[T1]{fontenc}
        \usepackage{lmodern}
        \begin{document}
          \indent
            いろは歌：
            \fbox{\parbox[t]{5cm}{%
              色は匂へど散りぬるを，吾が世誰ぞ恒ならむ．
              有為の奥山今日越えて，浅き夢見じ，酔ひもせず．
            }}
          \par
        \end{document}
      ```);%

      ここでユーザが\codem{\\parbox}コマンドの幅指定を忘れ，
      8行目を以下のように間違ってしまったとする：

      \d-code(```
        \fbox{\parbox[t]{%
      ```);%

      このときp\LaTeX;は不適格な入力であるとして何らかのタイミングでエラーを報告するのだが，
      そのエラーとして標準出力/標準エラー出力に提示されるのが次のようなメッセージである：

      \console(```
        ! Argument of \@iiiparbox has an extra }.
        <inserted text>
                        \par
        l.11     }}

        ?
      ```);%

      おそらくほとんどのユーザはこのエラーログから
      「11行目までで何かおかしい」ということ以上に詳しい情報を引き出せないだろう．
%        これは\LaTeX;が覆い隠せなかった，“生の\TeX;のエラー” が直接ユーザに見えている状態である．
%        実は\TeX;/\LaTeX;について十分素養のある人間にとってもすぐには理解できない．
      これは\codem{\\parbox}コマンドの実装内部でエラーが生じており，
      そこで初めてユーザの与えた不適格な引数が害を及ぼして
      このようなエラーログを引き起こしているのであり，
      ユーザにとってはほとんど与り知らないようなところのエラーが報告されていて
      わかりづらいと言わざるを得ない．
    }
    +p{
      同様に，高さ指定のオプション引数を
      ユーザが間違えて必須の引数だと思い込んで記述してしまった時のエラーも見てみる．
      これは8行目を以下のように間違えてしまった場合である．

      \d-code(```
        \fbox{\parbox{t}{5cm}{%
      ```);%

      そのエラーが次のようなメッセージである：

      \console(```
        ! Missing number, treated as zero.
        <to be read again>
                           t
        l.11     }}

        ?
      ```);%

      やはりコマンドの実装内で初めて破綻した箇所でのエラーが出ており，
      ユーザにとってはまるで直接の原因がわからないといってよいようなエラーログである．
      小さい文書であればすぐ気づくかもしれないが，
      大きな文書を組んでいる場合は原因を探すのにもひと苦労である．
      場合によっては，
      “書いたコードの一部をコメントアウトしながら地道に二分探索して原因箇所をつきとめる”
      ことになってしまう．
    }
    +p{
      では\SATySFi;で等価な実験をするとどうだろうか．ここからが要点である．
      まず，正しい出力を得る\SATySFi;のコードは以下のとおり：

      \d-code(```
        % -*- coding: utf-8 -*-
        @require: stdja
        @import: local

        document (|
          title = {Test Document};
          author = {Takashi SUWA};
          show-title = false;
          show-toc = false;
        |) '<
          +p {
            いろは歌：
            \fbox{\parbox?:(Top)(5cm)<
              +p { 色は匂へど散りぬるを，吾が世誰ぞ恒ならむ．
                   有為の奥山今日越えて，浅き夢見じ，酔ひもせず． }
            >}
          }
        >
      ```);%

      念のために述べると，\codem{\\fbox}や\codem{\\parbox}といったコマンドは
      わかりやすさのために\LaTeX;と名称を揃えてあるだけで，
      \SATySFi;のプリミティヴのみを用いて実装されている．
      内容は今は逐一解説しないが，以下のようにしてコマンドとして定義できる：

      \d-code(```
        let-inline ctx \fbox it =
          let pads = (2pt, 2pt, 2pt, 2pt) in
          let t = 0.5pt in
          let deco (x, y) w h d =
            [ stroke t Color.black
                (Gr.rectangle (x, y -' d) (x +' w, y +' h)) ]
          in
            inline-frame-inner pads deco (read-inline ctx it)

        type position-spec = Top | Bottom

        let-inline ctx \parbox ?:specopt wid ib =
          let blockf =
            match specopt with
            | None         -> embed-block-top ctx wid
            | Some(Top)    -> embed-block-top ctx wid
            | Some(Bottom) -> embed-block-bottom ctx wid
          in
            blockf (fun ctx -> read-block ctx ib)
      ```);%

      では，もとの\codem{\\parbox}の幅指定を
      やはりユーザが誤って記述しなかったときはどうなるであろうか．
      13行目を以下のように変えてみる：

      \d-code(```
        \fbox{\parbox?:(Top)<
      ```);%

      これを処理すると入力として不適格ゆえにエラーが報告されるのであるが，
      そのエラー報告が以下のようなものとなる：

      \console(```
        ! [Type Error] at line 13, character 26 to line 16, character 1:
            this expression has type
              block-text,
            but is expected of type
              length.
      ```);%

      13行目の26文字目から\type(Type.block-text);型の引数が与えられているが，
      ここには\type(Type.length);型の引数，
      つまり長さを表す指定がくるべきだ，というエラーが出ているのである．
      直接的な原因がわかりやすいため，ユーザはこのエラーにしたがってすぐに修正することができる．
    }
    +p{
      同様に，オプション引数を必須の引数だと間違えてユーザが入力を与えてしまった場合の
      エラーも見てみる．
      やはり13行目を以下のように変えて処理してみることにする：

      \d-code(```
        \fbox{\parbox(Top)(5cm)<
      ```);%

      以下のようなエラー報告が返ってくる：

      \console(```
        ! [Type Error] at line 13, characters 18-23:
            this expression has type
              position-spec,
            but is expected of type
              length.
      ```);%

      \type(Type.base-type {position-spec});型の引数が与えられているが，
      必須の引数なら\type(Type.length);型の引数が与えられるべき箇所である，
      というエラーが出ている．
      やはり直接的な原因がわかりやすく，ユーザはすぐに修正に向かうことができる．
      このようなエラー報告は型検査器に於いて
      コマンド\codem{\\parbox}に型推論の結果つけられた型から判定することによって為されており，
      静的に型をつける恩恵はまさにここにあるといってよいだろう．
      以上のような型を用いた修正に便利な仕組みが，
      既存のマークアップ言語方式の組版処理システムでは実現されていない，
      \SATySFi;の大きな強みである．
    }
  >
>
