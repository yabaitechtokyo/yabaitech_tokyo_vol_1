% -*- coding: utf-8 -*-
@import: settings
@import: preface
@import: introduction
@import: overall
@import: bib

document (|
  title = {The \SATySFi;book};
  author = {T. Suwa};
  preface = preface;
  bibliography = bibliography;
|) '<
  +chapter?:(`introduction`){ゲームを始める前に}< #introduction; >
  +chapter?:(`getting-started`){\SATySFi;簡易入門}<
    +p{
      ひとまず読者がすぐにさわれるものとして\pkg{stdjareport}クラス\REMAINS{}があるので，
      これを土台に説明することとしよう．
      おそらく\LaTeX;の使用経験がある読者なら
      コード例を見ただけでおおよそ何を記述しているかは察しがつくであろうが，
      \LaTeX;（の一般的なクラスファイルが提供するマークアップ）と
      顕著に違いのある箇所についてはその都度述べておくことにした．
    }
    +p{
      なお，\LaTeX;の使用経験がない読者，
      そのうち特にMarkdownやreStructuredTextといった
      いわゆる軽量マークアップ言語に慣れ親しんだ読者からすれば
      「こんな冗長な記述をしなければならないのか」と感じられる点も見受けられるかもしれないが，
      組版処理中にエラーを生じないことを組版処理よりも前にできるだけ検出すること，
      ユーザにもコマンドが柔軟に定義できるようにすることを志向している都合上
      冗長にならざるを得ない部分も多いのだろうとひとまずは理解されたい．
    }
    +section{ファイルの種別と拡張子}<
      +p{
        \SATySFi;がユーザからの入力として直接的に扱うファイルには

        \listing{
          * \dfn{文書ファイル}： 文書の内容を記述するファイル
          * \dfn{パッケージファイル}： コマンド定義などを記述するファイル
        }%

        の2種類がある．
        パッケージファイルのうちの一部には
        文書のマークアップ方法や体裁等を規定しているものがあり，
        これは\dfn{クラスファイル}と呼ぶ．
        パッケージファイルは拡張子を\path{.satyh}にしておく必要がある\footnote{
          実際には\path{.satyh}のほかに\path{.satyg}などの拡張子が扱われるが，
          今のところはひとまず\path{.satyh}だけと認識してもらって差し支えない．
          詳しくはテキストモードで扱う．
        }．
        文書ファイルの拡張子は現在のところ特に決まりはないが，
        慣習的には\path{.saty}を使用している．
        特別な理由がない限り，拡張子はこの\path{.saty}にすることを強く推奨する．
      }
    >
    +section{文書構造}<
      +p{
        全体構造として文書ファイルは以下のように記述する：
        \d-code(```
          @require: stdjareport

          document (|
            title = {サンプル文書};
            author = {組 版太郎};
          |) '<
            +chapter{はじめての章}<
              +p{
                \SATySFi;でのはじめての段落の記述です．
                段落は\dfn{ブロックコマンド}で実現されています．
              }
            >
          >
        ```);%
        インデントは構文解析上特に意味を持たず単に無視されるので，
        どのようにつけても構わない\footnote{
          勿論，習慣としては可読性のために括弧の入れ子構造に応じてインデントをつけておくことを薦める．
        }．
        文書ファイルの\code(`document`);よりも手前の部分は
        \LaTeX;に準じて\dfn{プリアンブル}と呼ぶことにしよう．
        ここに

        \d-code(```
          @require: （パッケージ名）
        ```);%

        と書くことでシステムにインストールされたパッケージを読み込むことができる．
        パッケージの実体はソースコードが記述された単一のパッケージファイルであり，
        例えば\pkg{stdjareport}の本体は\path{stdjareport.satyh}というファイルなのだが，
        読み込みの指定は拡張子なしで書く（\path{.satyh}が自動で補われる）．
        文書ファイルと同じディレクトリに置いているような
        “ローカルな” パッケージファイルや分割ファイルは

        \d-code(```
          @import: （ファイルへの相対パス）
        ```);%

        で読み込む．やはり拡張子は自動で補われるので書かない\footnote{
          \code(`@require`);と\code(`@import`);で拡張子を省略する仕組みは
          単に手間を省くためにあるわけではない．
          補われる拡張子は\path{.satyh}とは限らないのである．
          これについては\ref-chapter(`text-mode`);でのテキストモードについての説明で後述する．
        }．
%        より精確には，\code(`<path/to>`);として（UNIX系OSでは）
%        \code(`~/.satysfi`);，\code(`/usr/local/share/satysfi`);，\code(`/usr/share/satysfi`);
%        をこの優先度で見に行き，最初に存在したファイルを読み込む．
      }
      +p{
        \codem{(\| ${\cdots} \|)}にタイトルや著者名など文書に必要な情報を与え，本文は\codem{'\< ${\cdots} \>}に記述する．
        この形式は\SATySFi;のGitHubリポジトリの
        \path{lib-satysfi/dist/packages/}に置いている他のクラスファイル，
        例えば\pkg{stdjabook}クラスなどでもおおよそ同様である．
        \SATySFi;での文書の記述は主に

        \listing{
          * \dfn{ブロックテキスト}： ページ方向に積み重なるもの
          * \dfn{インラインテキスト}： 文字の進行方向へ連なるもの
        }%

        に分かれており，
        このうちインラインテキストが
        基本的に通常の文字列としてのテキストを書くことが想定されている箇所である．
        ブロックテキストは\codem{\< ${\cdots} \>}，
        インラインテキストは\codem{\{ ${\cdots} \}}で囲って記述する．
        ただし，上に掲げたコードで文書全体の内容にあたるブロックテキストを囲う開始側の括弧が
        \code(`<`);ではなく例外的に\code(`'<`);であることには注意されたい\footnote{
          詳細は後述するが，この括弧の前後で字句解析規則が変わりうる都合上，
          “コマンドの引数ではない部分” でブロックテキストを書くときは\code(`<`);ではなく\code(`'<`);にする必要がある．
          単に\code(`<`);と書くと不等号の2項演算子だと認識されてしまう．
        }．
        \TeX;の用語でいえば，ブロックテキストは垂直モードにおける記述，
        インラインテキストは水平モードにおける記述におおよそ対応する．
      }
      +p{
        ひとまず，上に掲げた例からPDFを生成してみよう．
        まずは適当なディレクトリに例示した文書ファイルを保存する．
        ファイル名は\path{hello.saty}とする．
        ターミナルを開き，\path{hello.saty}が置いてあるディレクトリに移動して

        \console(`$ satysfi hello.saty`);%

        を実行する．文書ファイルの記述に誤りがなければ，同じディレクトリに
        \path{hello.satysfi-aux}と\path{hello.pdf}が生成されるはずである．
        このうち\path{hello.satysfi-aux}は
        \dfn{補助ファイル}あるいは\dfn{ダンプファイル}と呼ばれる副産物で，
        今は無視して構わない．\path{hello.pdf}が肝腎の生成物であり，
        これを開くとたしかにそれらしい小さな文書ができていることが確認できるだろう．
      }
      +p{
        さて，上に掲げた例の文書内容には，
        \codem{+chapter\{ ${\cdots} \}\< ${\cdots} \>}やら\codem{+p\{ ${\cdots} \}}やら
        \codem{\\dfn\{ ${\cdots} \}}やら，
        なんとなくわかりそうだが妙に多くの記号が駆使された怪しげな記述がある\footnote{
          念のため書いておくと，\codem{+chapter}や\codem{+p}といったコマンドは
          \pkg{stdjareport}が規定しているもので，
          “\SATySFi;の言語機能に本質的に備わっているもの” ではない．
          その気になればクラスファイル\path{stdjareport.satyh}の中を覗いて
          実装を見ることができる．
        }．
        これらについて以下の節で見ていくこととしよう．
      }
    >
    +section{段落}<
      +p{
        段落は “文字の連なりを受け取ってページ方向に連なる行のリストにするもの” と捉え，
        インラインテキストを引数にとってブロックを返すコマンドで定式化されている．
        以下のように\code(`+p`);コマンドでブロックテキスト内に記述する：

        \d-code(```
          +p{
            明日は明日の風が吹く
          }
        ```);%

        上で「ブロック」と書いたものは正確には「ブロックテキスト」ではないが，
        ひとまずはブロックテキストとおおよそ同じものだと考えて差し支えない．
        ブロックテキスト内で使うコマンド，つまり “ブロックを返す” コマンドは
        名前が\code(`+`);で始まり， \dfn{ブロックコマンド}と呼ぶ．
        一方インラインテキスト内で使うコマンドは名前が（\LaTeX;のコマンドと同様に）\code(`\`);で始まり，
        これを\dfn{インラインコマンド}と呼ぶ（後述）．
      }
      +p{
        \codem{\{ ${\cdots} \}}の中にはインラインテキストとして通常のテキストと
        インラインコマンドが書けるが，
        いくつかの特殊な機能をもつ文字は通常のテキストとして扱うには
        \code(`\`);によるエスケープを要する．
        エスケープする必要のある文字は
        \code(`{`);，\code(`}`);，\code(`<`);，\code(`>`);，\code(`|`);，\code(`%`);，
        \code(`*`);，\code(`;`);，\code(`#`);，\code(`$`);，\code(`\`);
        である．
      }
    >
    +section{章節}<
      +p{
        \code(`+chapter`);，\code(`+section`);，\code(`+subsection`);を使う．
        名称は\LaTeX;に準じているが用法は少し異なり，ブロックテキスト内に以下のように記述する：

        \d-code(```
          +chapter{（章題）}<
            （内容）
          >
        ```);%

        章題だけではなく，その章の内容をブロックテキストとして第2引数に与えるという形で定式化されている．
        章題は文字の連なりなのでインラインテキスト，内容は段落のページ方向への積み重なりなのでブロックテキストである．
        \code(`+section`);，\code(`+subsection`);の用法も全く同様．
      }
    >
    +section{新出単語}<
      +p{
        新たに定義される名称や言い回しは，インラインコマンド\code(`\dfn`);で囲む．
        インラインテキスト中で以下のように使う：

        \d-code(```
          \dfn{Typesetting} is the composition of text
          by means of arranging types.
        ```);%

        引数として囲まれた部分のラテン文字がイタリック体になる．
        このように，インラインコマンドとは “（何らかの加工が施された）文字の連なり” を返すコマンドなのである．
        なお，引数のないインラインコマンドはセミコロンをつける：

        \d-code(```
          \SATySFi; is a new typesetting system.
        ```);%
      }
    >
    +section{文中数式}<
      +p{
        文中数式は，インラインテキスト中に\codem{\$\{ ${\cdots} \}}で囲って書く．
        記法はかなり\LaTeX;に近く，以下のような例だと
        \codem{\$\{ ${\cdots} \}}の中身は見かけ上\LaTeX;コードと完全に一致する：

        \d-code(```
          We can write formulae like
          ${E = m c^2}, ${F = G \frac{m_1 m_2}{r^2}},
          ${x^x = e^{x \log x}}, and so on.
        ```);%

        数式中のコマンド（\dfn{数式コマンド}）はインラインコマンドと同様に\code(`\`);から名前が始まる．
        同一の名前をインラインコマンドと数式コマンドの両方で使うことはできない（つまり，名前空間は分かれていない）．
        インラインコマンドの場合とは違い，引数のない数式コマンドの使用に\code(`;`);はつけない．
      }
      +p{
        \LaTeX;の数式の記法とよく似ているものの，主に以下の節に挙げるような違いがある．
      }
      +subsection{括弧}<
        +p{
          \LaTeX;の\code(`\left`);・\code(`\right`);・\code(`\middle`);に相当するものはなく，
          代わりに括弧が左右合わせてひとつのコマンドとして定義されている．
          丸括弧で囲いたい場合は\codem{\\paren\{（囲う式）\}}と記述する．
          丸括弧のほか，集合の外延記法は\codem{\\set\{ ${\cdots} \}}，
          内包記法は\codem{\\setsep\{ ${\cdots} \}\{ ${\cdots} \}}，
          絶対値は\codem{\\abs\{ ${\cdots} \}}，
          距離やノルムに使う2本線の括弧は\codem{\\dist\{ ${\cdots} \}}という数式コマンドにより提供されている．
          また，函数の適用は\code(`\app{f}{x}`);という具合に書けるようになっている．
        }
        +p{
          なお，四角括弧，（集合に限らない一般の）波括弧，三角括弧もそれぞれ
          \codem{\\sqbracket\{ ${\cdots} \}}，\codem{\\brace\{ ${\cdots} \}}，
          \codem{\\angle-bracket\{ ${\cdots} \}}
          で書けるようになっているが，これらのコマンドは数式の “意味” を指しているわけではないので，
          直接数式に書くことよりもユーザ定義コマンド（後述）の定義中で使うことを想定している．
        }
      >
      +p{ \REMAINS{\LaTeX;と\SATySFi;の数式記法の違い} }
    >
    +section{コメントアウト}<
      +p{
        単行コメントアウトは\LaTeX;と全く同様に
        \code(`%`);
        によって行なう．
        単純にコメントアウトとして使うだけでなく，
        インラインテキスト中で改行文字を入力として与えずにソース上で改行するのに使うことができる．
        複数行のコメントアウトは現在は備わっていないが，明らかにあると便利なので近い将来追加するつもりでいる．
      }
    >
    +section{箇条書き}<
      +p{
        箇条書きは\pkg{itemize}パッケージを読み込むと使える．
        ブロックテキスト中で

        \d-code(```
          +listing{
            * 東京
              ** 本郷
              ** 弥生
              ** 浅野
              ** 駒場
            * 千葉
              ** 柏
          }
        ```);%

        と書くほか，インラインテキスト中でも

        \d-code(```
          \listing{
            * 東京
              （中略）
              ** 柏
          }%
        ```);%

        という具合に書ける．箇条書きは “ページ方向に積み重なるもの” なので基本的には “ブロック” なのだが，
        マークアップの都合上段落中などでも使えるようにインラインコマンド版も提供されている．
        ただし，インラインコマンド版は末尾にコメントアウトの文字
        \code(`%`);
        をつける必要がある\footnote{
          これがないと，\code(`}`);直後の改行文字に由来して
          次の文字の前に余分なスペースが挿入されてしまう．
          やや微妙な性質なので今後
          \code(`%`);
          を書かなくてよいように改善したいと検討している．
        }．
        見てのとおり多重構造も扱え，階層は\code(`*`);の連続する個数によって判定される
        （インデントは単に見やすさのためにつけてあるだけである）．
        既に述べたように，\code(`*`);はこの機能のために特殊な文字として扱われている都合上
        通常のテキストとして書くには\code(`\*`);とエスケープする必要がある．
      }
      +p{
        ちなみに，上に掲げた例の箇条書きの部分\codem{\{ ${\cdots} \}}はインラインテキストではなく，
        itemize 型という箇条書き専用の型がつくテキストになっており，
        通常のインラインテキストを与えると型エラーとなる．
        これについては\ref-chapter(`type-system`);で後述する．
      }
    >
    +section{定理環境}<
      +p{
        \code(`cs-thesis`);には定義・補題・定理・系・例のための環境一式が備わっており，
        コマンドはそれぞれ
        \code(`+definition`);，\code(`+lemma`);，\code(`+theorem`);，\code(`+corollary`);，\code(`+example`);
        である．いずれも用法は同様で，最も簡素な使い方としてはブロックテキスト中で
        \d-code(```
          +theorem{
            （内容）
          }
        ```);
        などと書く．環境中で改段落することは想定されていないので，内容はインラインテキストで与える．
        オプション引数としてタイトルを与えることができる：
        \d-code(```
          +theorem ?:({Progress}){
            If ${t} is well-typed, then one of the following holds:
            \listing{
              * ${t} is a value.
              * ${t \to t'} for some ${t'}.
            }%
          }
        ```);
        \codem{?:( ${\cdots} )}がオプション引数を与える構文である．
      }
    >
    +section{脚註}<
      +p{
        脚註の用法はほぼ\LaTeX;と同様で，インラインテキスト中に
        \codem{\\footnote\{ ${\cdots} \}}
        と記述することで挿入できる．
      }
    >
    +section{相互参照}<
      +p{
        相互参照は\ref-chapter(`introduction`);でも述べたとおり
        マークアップ方式の組版処理システムが簡潔に実現することを得意としやすい機能だ．
        \SATySFi;にも相互参照機能が備わっており，
        \pkg{stdjareport}はそれを利用して相互参照のインターフェイスを実現している．
        実は，既に紹介した章節や定理環境のコマンドたちは，オプション引数として相互参照のラベルを受け取ることができる：

        \d-code(```
          \chapter?:(`introduction`){はじめに}<
            （中略）
          >
        ```);%

        そして，章番号を使いたい箇所で\codem{\\ref-chapter}を用いて挿入する：

        \d-code(```
          既に\ref-chapter(`introduction`);で述べたように，
        ```);
      }
    >
    +p{ \REMAINS{wikiをたたき台にして書く} }
  >
  +chapter?:(`basic-command-definition`){コマンド定義：基礎編}<
    +p{
      \ref-chapter(`getting-started`);で\pkg{stdjareport}を用いて
      \SATySFi;の基礎的なコマンドの用法を知った．
      ところで，マークアップ言語の大きな強みのひとつは
      自前でコマンドを定義することによって
      種々の自動処理を実現したり独自の意味マークアップを規定したりできる点にあったはずである．
      実際，\codem{+chapter}とか\codem{+p}とか\codem{\\dfn}とかいった
      コマンドたちは単に\pkg{stdjareport}クラスによって定義が提供されているだけであり，
      その気になればユーザでも同様の定義を書いたりできるはずだ．
      そろそろ自前でコマンドを定義したくてうずうずしている読者も多いかと思う．
      この章では，コマンド定義のごく基礎的な方法を紹介する．
      あらかじめ言ってしまうとここでの説明はとてもアドホックなものになっており，
      \SATySFi;をよく理解されたのちにこの章を読めば
      「こんな子供騙しな説明をしていたのか」と驚かれるかもしれないが，
      読者の様々なバックグラウンドを鑑み，
      まず最初の一歩としておおまかに把握してもらうには良い説明だろうと
      判断してのことなのでご容赦願いたいと思う．
      より深い理解を獲得し，より柔軟で幅広い種類の処理をコマンドとして定義するには，
      \ref-chapter(`overall-structure`);で
      \SATySFi;が行なっている組版処理の全体像を把握した上で
      \ref-chapter(`advanced-command-definition`);に臨んでいただきたい．
    }
    +section{簡単なエイリアス}<
      +p{
        まずは非常に簡素な例から考える．
        例えば\pkg{stdjareport}の提供する\codem{\\dfn}というコマンド名が気に入らず，
        \codem{\\new-word}という名前で書きたいとしよう．
        要するに，\codem{\\new-word\{（新出単語）\}}と書いたら\codem{\\dfn\{（新出単語）\}}
        に “勝手に変わってくれる” ようなコマンド\codem{\\new-word}を定義したいとする．
      }
      +p{
        これを実現するために，プリアンブルに手を加えよう．文書ファイルの
        \code(`@require`);や\code(`@import`);が並ぶ箇所と\codem{document}との間には，
        コマンド定義を書くことができる．
        \ref-chapter(`getting-started`);で扱った例の
        本文中の\codem{\\dfn}を\codem{\\new-word}に書き換え，
        \codem{\\new-word}の定義をプリアンブルに追加してみよう：

        \d-code(```
          @require: stdjareport

          let-inline \new-word it =
            {\dfn{#it;}}

          in
          document (|
            title = {サンプル文書};
            author = {組 版太郎};
          |) '<
            +chapter{はじめての章}<
              +p{
                \SATySFi;でのはじめての段落の記述です．
                段落は\new-word{ブロックコマンド}で実現されています．
              }
            >
          >
        ```);

        \codem{let-inline}云々とあるのが\codem{\\new-word}の定義である．
        コマンドの定義はプログラミング言語で言うところの函数の定義によく似ており，
        \codem{it}がインラインテキストが格納される引数にあたる．
        そして受け取った引数をインラインテキスト中で使っているのが\codem{\#it\;}である．
        コマンド定義は

        \d-code(```
          let-inline （定義したいインラインコマンド名） （0個以上の引数） =
            {（置き換え後の記述）}
        ```);%

        という形で書くことになる．
        おそらく中級以上の\LaTeX;ユーザなら\code(`\newcommand`);を想起するだろう．
        実際，\SATySFi;での上記のような\codem{\\new-word}の定義は，
        \code(`\dfn`);が定義されている下で\code(`\newWord`);を定義する
        以下の\LaTeX;コードとほぼ等価なものと考えてよい．

        \d-code(```
          \newcommand{\newWord}[1]{\dfn{#1}}
        ```);

        この定義中の\code(`#1`);が\SATySFi;での\codem{\#t\;}に相当するのである．
        引数を要しないコマンドも同様に定義できる．例えば

        \d-code(```
          let-inline \Cde =
            {ともあれ，カルタゴは滅ぶべきであると考える次第である．}
        ```);

        と定義すれば，インラインテキスト中で \codem{\\Cde\;}と打つだけで
        「ともあれ，カルタゴは滅ぶべきであると考える次第である．」と書いているのと等価になってくれる．
        日本語を読み書きできる古代ローマ人にとっては重宝するだろう．
      }
      +p{
        ブロックコマンドの自前定義についても，以下のような構文によってインラインコマンドと同様に行なえる：

        \d-code(```
          let-block （定義したいブロックコマンド名） （0個以上の引数） =
            '<（置き換え後の記述）>
        ```);%

        ただし，またも\codem{\<}ではなく\codem{'\<}であることに注意されたい．
        不恰好だが残念ながらこればかりは気をつけてもらうしかない．
        この機構を用いると，例えば
        段落末に必ず「ともあれ，カルタゴは滅ぶべきであると考える次第である．」という1文をつけ加えて
        段落をつくるコマンド\codem{+pCde}は

        \d-code(```
          let-block +pCde t = '<
            +p{
              #t;
              ともあれ，カルタゴは滅ぶべきであると考える次第である．
            }
          >
        ```);%

        という具合に定義できる．以降\codem{+p}の代わりにこの\codem{+pCde}を使えば
        自動で末尾に文が挿入されるからやはり便利である．
        このほか，古代ローマ人以外にも便利な例としてはつぎのようなブロックコマンドが定義できる：

        \d-code(```
          let-block +no-proof bt = '<
            #bt;
            +p{証明は読者への演習課題とする．}
          >
        ```);

        今度は引数がブロックテキストであることに注意されたい．ブロックテキストが格納された変数\codem{bt}も，
        ブロックテキスト中に\codem{\#bt\;}と書くことでそこに内容を埋め込むことができる．
        この定義は要するに，与えられたブロックテキストの後ろに
        「証明は読者への演習課題とする．」と書かれた段落をくっつけるコマンドの定義になっている．
        以下のようにして理工書の執筆に使えば大変便利である．

        \d-code(```
          +no-proof<
            +lemma{
              （証明がめんどくさい補題の内容）
            }
          >
        ```);
      }

    >
    +section{プログラミング言語としての\SATySFi;}<
      +p{
        \REMAINS{}
      }
    >
  >
  +chapter?:(`overall-structure`){文書が処理される仕組み}< #overall; >
  +chapter?:(`advanced-command-definition`){コマンド定義：発展編}<
    +p{ \REMAINS{} }
  >
  +chapter?:(`type-system`){型システム}<
    +p{
      既に\ref-chapter(`introduction`);で述べたとおり，
      \SATySFi;の最大の特徴は型システムを備えているおかげで
      或る種の入力の誤りを実際に組版処理を始めるよりも前に検出してすばやく報告できることにある．
      本章では，この型システムについて詳細を追って見ていくことにしよう．
    }
    +p{ \REMAINS{} }
  >
  +chapter?:(`typography`){文字組版}<
    +p{
      文字は組版処理の主役であり，そして最も人間くささゆえの複雑性を備えた組版処理対象だ．
    }
    +p{ \REMAINS{} }
  >
  +chapter?:(`graphics`){グラフィックス}<
    +p{ \REMAINS{} }
  >
  +chapter?:(`math`){数式組版}<
    +p{
      主に理工系の文書をしたためる者にとって，
      数式組版機能は水や空気のように当然のものとして組版処理システムに備わっていてほしいものだ．
      \TeX;/\LaTeX;が30年の長きに亘って使われ続けてきた大きな要因のひとつが，
      誰もが納得するような品質の数式組版機能を古くから提供している
      数少ない組版処理システムだったからであることにおそらく異論はないだろう．
    }
    +p{
      \SATySFi;も，\TeX;/\LaTeX;に肩を並べられるくらいの品質の数式組版機能を提供している．
      しかも，既に\ref-chapter(`getting-started`);で見たように，
      \LaTeX;そっくりの構文で書くことができる．
      数式を多大に含む文書を執筆したいという動機で既に盛んに\LaTeX;に触れていた人にとって，
      少なくとも数式の記法が\SATySFi;への移行に関する心理的障壁となることはまずないだろう．
      本章では，\SATySFi;に備わっている数式組版機能について，詳細を追って見ていくことにしよう．
    }
    +p{
      なお，繰り返しになるが，\SATySFi;での数式の記述はコードの見た目上\LaTeX;にそっくりなものの，
      裏でやっていることは両者で全然違う．
      \LaTeX;は字句解析（トークン化）に相当する処理を組版処理と同時進行で行ない，
      かつ構文木も一切構築せずパターンマッチでトークン列を書き換えていくのに対し，
      \SATySFi;は静的に構文解析して数式を構文木の形で保持している．
    }
  >
  +chapter?:(`cross-reference`){相互参照}<
    +p{ \REMAINS{} }
  >
  +chapter?:(`page-breaking`){ページ分割}<
    +p{ \REMAINS{} }
  >
  +chapter?:(`text-mode`){テキストモード}<
    +p{ \REMAINS{} }
  >
  +chapter?:(`primitives`){プリミティヴ一覧}<
    +p{ \REMAINS{} }
  >
  +chapter?:(`future-work`){Future Work}<
    +p{
      \SATySFi;は現時点でも充分実用に耐える程度に機能を備えているが，
      今後さらに拡張していきたいと考えている点がいくつもある．
      本章ではこれについて簡潔に述べることとしよう．
      端的に言ってしまえば開発に協力してくださるかもしれない方への喧伝である．
    }
    +p{ \REMAINS{} }
  >
  +chapter?:(`specification`){言語仕様}<
    +p{
      この章は，対象をより細かい粒度で理解しようとせずにはいられない，物好きな読者向けに用意した．
      全貌を形式的に記述するには\SATySFi;は大きすぎるので，
      根幹となる部分だけを抜き出したサブセットをいくつか定義し，
      それについて操作的意味論や型システムをフォーマルに記述することを試みた．
    }
    +p{ \REMAINS{} }
  >
>
