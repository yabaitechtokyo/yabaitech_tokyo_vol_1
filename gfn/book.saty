% -*- coding: utf-8 -*-
@import: settings
@import: preface
@import: introduction
@import: getting-started
@import: alias-command-definition
@import: programming
@import: overall
@import: advanced-command-definition
@import: line-breaking
@import: system-and-config
@import: typography
@import: graphics
@import: cross-reference
@import: page-breaking
@import: future-work
@import: specification
@import: bib

document (|
  title = {The \SATySFi;book};
  author = {Takashi SUWA};
  preface = preface;
  bibliography = bibliography;
|) '<
  +chapter?:(`introduction`){\SATySFi;の開発動機}< #introduction; >
  +chapter?:(`getting-started`){\SATySFi;簡易入門}< #getting-started; >
  +chapter?:(`basic-command-definition`){コマンド定義：基礎編}<
    +p{
      \ref-chapter(`getting-started`);で\pkg{stdjareport}を用いて
      \SATySFi;の基礎的なコマンドの用法を知った．
      ところで，マークアップ言語の大きな強みのひとつは
      自前でコマンドを定義することによって
      種々の自動処理を実現したり独自の意味マークアップを規定したりできる点にあったはずである．
      実際，\codem{+chapter}とか\codem{+p}とか\codem{\\dfn}とかいった
      コマンドたちは単に\pkg{stdjareport}クラスによって定義が提供されているだけであり，
      その気になればユーザでも同様の定義を書いたりできるはずだ．
      そろそろ自前でコマンドを定義したくてうずうずしている読者も多いかと思う．
      この章では，コマンド定義のごく基礎的な方法を紹介する．
      あらかじめ言ってしまうとここでの説明はとてもアドホックなものになっており，
      \SATySFi;をよく理解されたのちにこの章を読めば
      「こんな子供騙しな説明をしていたのか」と驚かれるかもしれないが，
      読者の様々なバックグラウンドを鑑み，
      まず最初の一歩としておおまかに把握してもらうには良い説明だろうと
      判断してのことなのでご容赦願いたいと思う．
      より深い理解を獲得し，より柔軟で幅広い種類の処理をコマンドとして定義するには，
      \ref-chapter(`overall-structure`);で
      \SATySFi;が行なっている組版処理の全体像を把握した上で
      \ref-chapter(`advanced-command-definition`);に臨んでいただきたい．
    }
    +section{簡単なエイリアス}< #alias-command-definition; >
    +section{プログラミング言語としての\SATySFi;}< #programming; >
  >
  +chapter?:(`overall-structure`){文書が処理される仕組み}< #overall; >
  +chapter?:(`advanced-command-definition`){コマンド定義：発展編}< #advanced-command-definition; >
  +chapter?:(`line-breaking`){行分割処理}< #line-breaking; >
  +chapter?:(`system-and-config`){システムと設定ファイル}< #system-and-config; >
  +chapter?:(`typography`){文字組版}< #typography; >
  +chapter?:(`graphics`){グラフィックス}< #graphics; >
  +chapter?:(`math`){数式組版}<
    +p{
      主に理工系の文書をしたためる者にとって，
      数式組版機能は水や空気のように当然のものとして組版処理システムに備わっていてほしいものだ．
      \TeX;/\LaTeX;が30年の長きに亘って使われ続けてきた大きな要因のひとつが，
      誰もが納得するような品質の数式組版機能を古くから提供している
      数少ない組版処理システムだったからであることにおそらく異論はないだろう．
    }
    +p{
      \SATySFi;も，\TeX;/\LaTeX;に肩を並べられるくらいの品質の数式組版機能を提供している．
      しかも，既に\ref-chapter(`getting-started`);で見たように，
      \LaTeX;そっくりの構文で書くことができる．
      数式を多大に含む文書を執筆したいという動機で既に盛んに\LaTeX;に触れていた人にとって，
      少なくとも数式の記法が\SATySFi;への移行に関する心理的障壁となることはまずないだろう．
      本章では，\SATySFi;に備わっている数式組版機能について，詳細を追って見ていくことにしよう．
    }
    +p{
      なお，繰り返しになるが，\SATySFi;での数式の記述はコードの見た目上\LaTeX;にそっくりなものの，
      裏でやっていることは両者で全然違う．
      \LaTeX;は字句解析（トークン化）に相当する処理を組版処理と同時進行で行ない，
      かつ構文木も一切構築せずパターンマッチでトークン列を書き換えていくのに対し，
      \SATySFi;は静的に構文解析して数式を構文木の形で保持している．
    }
    +p{ \REMAINS{} }
  >
  +chapter?:(`cross-reference`){相互参照}< #cross-reference; >
  +chapter?:(`page-breaking`){ページ分割処理}< #page-breaking; >
  +chapter?:(`future-work`){Future Work}< #future-work; >
  +chapter?:(`specification`){言語仕様}< #specification; >
>
