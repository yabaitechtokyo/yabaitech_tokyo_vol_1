% -*- coding: utf-8 -*-
@import: settings
@import: preface
@import: introduction
@import: getting-started
@import: alias-command-definition
@import: overall
@import: line-breaking
@import: system-and-config
@import: typography
@import: graphics
@import: cross-reference
@import: page-breaking
@import: future-work
@import: specification
@import: bib

document (|
  title = {The \SATySFi;book};
  author = {T. Suwa};
  preface = preface;
  bibliography = bibliography;
|) '<
  +chapter?:(`introduction`){\SATySFi;の開発動機}< #introduction; >
  +chapter?:(`getting-started`){\SATySFi;簡易入門}< #getting-started; >
  +chapter?:(`basic-command-definition`){コマンド定義：基礎編}<
    +p{
      \ref-chapter(`getting-started`);で\pkg{stdjareport}を用いて
      \SATySFi;の基礎的なコマンドの用法を知った．
      ところで，マークアップ言語の大きな強みのひとつは
      自前でコマンドを定義することによって
      種々の自動処理を実現したり独自の意味マークアップを規定したりできる点にあったはずである．
      実際，\codem{+chapter}とか\codem{+p}とか\codem{\\dfn}とかいった
      コマンドたちは単に\pkg{stdjareport}クラスによって定義が提供されているだけであり，
      その気になればユーザでも同様の定義を書いたりできるはずだ．
      そろそろ自前でコマンドを定義したくてうずうずしている読者も多いかと思う．
      この章では，コマンド定義のごく基礎的な方法を紹介する．
      あらかじめ言ってしまうとここでの説明はとてもアドホックなものになっており，
      \SATySFi;をよく理解されたのちにこの章を読めば
      「こんな子供騙しな説明をしていたのか」と驚かれるかもしれないが，
      読者の様々なバックグラウンドを鑑み，
      まず最初の一歩としておおまかに把握してもらうには良い説明だろうと
      判断してのことなのでご容赦願いたいと思う．
      より深い理解を獲得し，より柔軟で幅広い種類の処理をコマンドとして定義するには，
      \ref-chapter(`overall-structure`);で
      \SATySFi;が行なっている組版処理の全体像を把握した上で
      \ref-chapter(`advanced-command-definition`);に臨んでいただきたい．
    }
    +section{簡単なエイリアス}< #alias-command-definition; >
    +section{プログラミング言語としての\SATySFi;}<
      +p{
        既に述べたように，\SATySFi;はいわゆる函数型らしい特徴を兼ね備えた
        組版処理向けのマークアップ言語である．
        むしろ，より正確を期して言い表すならば
        値呼びの函数型言語の上に組版処理用の種々の言語機能が分厚く搭載された
        DSL（domain-specific language, 領域特化言語）だ．
        プログラミング言語としての\SATySFi;の基礎的部分には
        OCamlに大変よく似た体系が採用されており，
        基礎的部分の理解を得るのにOCamlに関する参考書で代用することも十分可能なほどである．
        とはいえ，OCamlなどの他言語から回り道せずとも\SATySFi;での最低限の直観を身につければ
        十分\SATySFi;でのプログラミングが可能であり，
        熱心に函数型プログラミングの基礎を習得したい読者ばかりではないであろうから，
        ここでも簡単にプログラミング言語としての\SATySFi;について解説する．
        また，OCamlと\SATySFi;との間には目的意識や美意識の違いに起因した多少の差異があるので，
        これについて（既にOCamlで流暢にプログラミングできる読者に対しても）
        \ref-subsection(`diff-from-ocaml`);で簡単に補足する．
      }
      +subsection{式と値}<
        +p{
          \SATySFi;には対話環境が特に整備されていないので，
          プログラムの計算結果をPDFに出力して確かめることにしよう．
          ひとまず以下のようなコードを見てほしい：

          \d-code(```
            @require: stdjareport

            let-inline \show-int n =
              embed-string (arabic n)
            in

            document (|
              title = {Programming in \SATySFi;};
              author = {計 算太郎};
            |) '<
              +p{ Answer: \show-int(40 + 2); }
            >
          ```);%

          \codem{let-inline}から始まる，
          未知でありながら前節で見たインラインコマンドを定義する方法によく似た構文があるが，
          実際これは\codem{\\show-int}というインラインコマンドの定義である．
          この定義をどう読むのかは後々わかることになるので，
          今の段階では
          「与えられた整数を版面に文字として10進法で出力するコマンド\codem{\\show-int}」
          を定義するオマジナイだと思っていただきたい．
          注目されたいのは\codem{\\show-int}を使う部分，すなわち

          \d-code(```
            ​  +p{ Answer: \show-int(40 + 2); }
          ```);%

          である．丸括弧に囲まれた\codem{40 + 2}という怪しげな記述がある．
          とりあえず，この文書を\SATySFi;処理系にかけてみると，
          この段落に相当する部分は

          \d-block(open Sample in '<
            +p{ Answer: \show-int(40 + 2); }
          >);%

          と出力される．そう，${40} と ${2} の和が計算されているのである．
          平たく言えば，こういった “計算をする処理” がプログラムの仕事の根幹であり，
          “計算をする処理” をプログラムとして記述することをプログラミングと呼ぶ．
          \codem{40 + 2}のような記述は
          \dfnje{\index(`シキ`){式}}{expression}
          またはしばしば
          \dfnje{\index(`コウ`){項}}{term}と呼ばれ，
          式を適切な構文にしたがって組み立てることでプログラムが構築される\footnote{
            C言語やPythonなどの
            “手続き的な” 観点に強く基づいている計算機言語に馴染みのある読者は
            「式から文をつくり，文からプログラムを構築するのではないか？」
            と思われるかもしれないが，
            \SATySFi;に文の概念はない．
            というか，式の特殊な場合が “手続き的な” 言語に備わっている文に相当するのである．
            これはOCamlをはじめとする多くのいわゆる函数型言語に共通する性質である．
          }．
        }
        +p{
          \codem{40 + 2}の “計算が進んで” \codem{42}になったように，
          式は一般に “それ以上計算しない式” へと “うつりかわっていく”．
          この “うつりかわり” の過程を
          \dfnje{\index(`ヒョウカ`){評価}}{evaluation}
          またはしばしば
          \dfnje{\index(`カンヤク`){簡約}}{reduction}
          と呼び， “それ以上計算しない式” を
          \dfnje{\index(`コウブンテキアタイ`){構文的値}}{syntactic value}
          或いは単に
          \dfnje{\index(`アタイ`){値}}{value}
          と呼ぶ．
          プログラムの動作とは，式を評価して値を求めることなのである．
        }
        +p{
          もう少し複雑な計算をしてみよう．

          \d-code-and-block(```
            +p{ Answer: \show-int(1 + 2 * 3 - 4); }
          ```)(open Sample in '<
            +p{ Answer: \show-int(1 + 2 * 3 - 4); }
          >);%

          \codem{\*}は乗算のための2項演算子である．
          通常我々が「${1 + 2 \times 3 - 4}」と書いた時には
          ${\paren{1 + \paren{2 \times 3}} - 4} と扱われるのと同様に，
          \SATySFi;言語でも2項演算子の結合には優先順位がある．
          やはり日常的な数式と同様に，括弧で囲うと優先順位を指示できる：

          \d-code-and-block(```
            +p{ Answer: \show-int((1 + 2) * 3 - 4); }
          ```)(open Sample in '<
            +p{ Answer: \show-int((1 + 2) * 3 - 4); }
          >);%
        }
      >
      +subsection{変数とその束縛}<
        +p{
          ただ単に整数の計算をするだけでは電卓を叩いているのと大して違いはないから，
          もう少し “プログラミングらしいこと” に踏み込もう．
          すなわち，\dfnje{変数}{variable}の使用である．
          変数は，\dfnje{変数名}{variable name}によって識別され，
          何らかの値を\dfnje{束縛する}{bind}ことのできる機構だ．
          変数名として使えるのは，

          \listing{
            * 1文字目はラテン小文字（\codem{a}–\codem{z}）

            * 2文字目以降は大小ラテン文字（\codem{a}–\codem{z}，\codem{A}–\codem{Z}），
              数字（\codem{0}–\codem{9}），
              またはハイフン（\codem{-}）
          }%

          を満たす，長さが1文字以上のコード中の文字列である．
          ただし，これに該当する文字列のうち
          以下に列挙した39種類は\dfnje{予約語}{reserved word}と呼ばれ，
          構文を示すなどの特別な用途で用いられることが定められたトークンなので，
          変数名には使えない\footnote{
            \codem{controls}と\codem{cycle}は今では特に使われないのだが，
            かつてグラフィックスに用いられていたTikZ風の構文の名残として予約語のままになっている．
          }：

          \tokens{
            |and|as
            |before|block-cmd
            |command|constraint|controls|cycle
            |do|direct
            |else|end
            |false|fun
            |if|in|inline-cmd
            |let|let-block|let-inline|let-math|let-mutable|let-rec
            |match|math-cmd|mod|module
            |not
            |of|open
            |sig|struct
            |then|true|type
            |val
            |when|while|with
            |}

          さて，肝腎の変数への値の束縛は

          \d-codem{
            let \meta{x} = \metasub(${1}){expr} in \metasub(${2}){expr}
          }%

          という形をもつ\dfnje{let式}{let-expression}で行なう\footnote{
            ここにイタリック体で
            \codem{\meta{x}}とか\codem{\metasub(${1}){expr}}などと書いたのは
            “メタ文字” であり，
            実際にコード中に\codem{x}とか\codem{expr1}といった文字列を書いているわけではなく，
            適宜あてはめるべきものに読み替えよ，ということを指す記述である．
            以降もこの “メタ文字” は頻繁に登場するので是非慣れて頂きたい．
          }．
          \codem{\meta{x}}が束縛される変数名であり，
          \codem{\metasub(${1}){expr}}および
          \codem{\metasub(${2}){expr}}は式である．
          このlet式は，\codem{\metasub(${1}){expr}}を評価した結果の値を
          変数\codem{\meta{x}}に束縛し，
          そして\codem{\metasub(${2}){expr}}を評価するのに使う．
          要するに，\codem{\metasub(${2}){expr}}中では
          変数\codem{\meta{x}}が
          \codem{\metasub(${1}){expr}}を評価した結果の値として使えるのである．
          実際に使ってみよう：

          \d-code-and-block(```
            +p{ Answer:
              \show-int(
                let n = (1 + 2) * 3 - 4 in
                  n * n * n
              );
            }
          ```)(open Sample in '<
            +p{
              Answer:
              \show-int(
                let n = (1 + 2) * 3 - 4 in
                  n * n * n
              );
            }
          >);%

          あまりにも大したことのない例だが，期待どおり計算できていることがわかる．
        }
        +p{
          ここですでにC言語やPythonなどの “手続き的な” 言語に慣れ親しんでいる人は
          特によく注意されたいのだが，束縛は「代入」とは似て非なる概念である．
          \SATySFi;に於ける変数は
          （OCamlなどその他のいわゆる函数型言語の変数にも共通するのだが）
          “値を入れておき，適宜変更できる箱” ではない．
          むしろ，“値に別名をつけたもの” という直観の方が正確である．
        }
      >
      +subsection{基本的なデータと型}<
        +p{
          \SATySFi;で扱えるデータは勿論整数だけではない．
          文字列，浮動小数点数，真偽値，さらには組版指定のための長さの値などが扱える．
        }
        +p{
          まずは文字列である．文字列の “計算結果” を実際にPDFに出力するため，
          やはり以下のようなオマジナイのテンプレートを用意しよう：

          \d-code(```
            @require: stdjareport

            let-inline \show-string s =
              embed-string s
            in

            document (|
              title = {Programming in \SATySFi;};
              author = {計 算太郎};
            |) '<
              +p{ Answer: [\show-string(`this is a string`);] }
            >
          ```);%

          この\codem{\`this is a string\`}の部分を色々変えて遊ぶのである．
          先走って登場してしまったが，\SATySFi;での文字列リテラルは
          両端をバッククォート（\codem{\`}）で囲って記述する．
          多くのプログラミング言語では文字列内容を二重引用符で囲い，
          キャリッジリターンや二重引用符などいくつかの特殊文字は
          バックスラッシュでエスケープして書くような方式が採られるが，
          \SATySFi;にはそのような文字列リテラルの記法はなく，
          代わりに一切エスケープの要らない
          バッククォートによるリテラルだけが備わっている．
          一切エスケープが要らないといっても，
          「\code(``foo`bar``);」のように
          バッククォートを文字列内容に含めたい場合はどうすればよいのだろう？\quad;
          これはMarkdownを書いた経験があれば想像しやすいが，
          バッククォートが内容に現れる場合は
          両端のバッククォートを2個ずつにするのである．
          これにより文字列内容の終端がどこであるかがわかる．
          試しに上のコードの\codem{\\show-string}の適用の部分を

          \d-code(```
            +p{ Answer: [\show-string(``foo`bar``);] }
          ```);%

          にしてみると，結果は以下のようになる：

          \d-block(open Sample in '<
            +p{ Answer: [\show-string(``foo`bar``);] }
          >);%

          一般化して言うと，
          文字列内容として ${n} 個隣接したバッククォートを含めたいとき，
          左右で同数の ${\paren{n + 1}} 個以上の
          連続したバッククォートで両端を囲めばよい．
        }
        +p{
          ここで，良い意味で性格の悪い読者は
          コーナーケースに気づいたかもしれない：\quad;
          文字列内容の（少なくとも一方の）
          端にバッククォートがくる場合はどうすればよいのだろう？\quad;
          これは簡単で，文字列内容の端がバッククォートの場合は，
          文字列を括るためのバッククォートの連続と文字列内容の端のバッククォートとの間に
          空白文字を挿入するとよい．
          バッククォートで括られた内容は，
          両末端の空白文字の ${0} 個以上を除去して文字列内容にするのである：

          \d-code-and-block(```
            +p{ Answer: [\show-string(`` `bar``);] }
          ```)(open Sample in '<
            +p{ Answer: [\show-string(`` `bar``);] }
          >);%

          たしかに空白文字が除去され，左端がバッククォートになっていることがわかる．
          さて，読者が次に思うことはもう私にはよくわかっている：\quad;
          文字列内容の（いずれかの）末端を本当に空白文字にしたい場合はどうすればいいのだろう？\quad;
          この疑問にもしっかり答えられるので安心してほしい．
          もし左端の空白文字の ${0} 個以上の連続を無視させたくないのであれば，
          文字列の括る左側のバッククォートを\codem{\`}ではなく\codem{\#\`}にするのである．
          バッククォートが2個以上の場合も同様に\codem{\#\`\`}の要領で\codem{\#}を左につける．
          右端の空白文字の ${0} 個以上の連続を無視させたくない場合も同様に
          文字列を括る右側を\codem{\`}ではなく\codem{\`\#}とする．
          バッククォートが2個以上の場合も同様である：

          \d-code-and-block(```
            +p{ Answer: [\show-string(#`` `bar``);] }
          ```)(open Sample in '<
            +p{ Answer: [\show-string(#`` `bar``);] }
          >);%

          たしかに空白文字が残っている．これでようやく安心して文字列リテラルが使える．
        }
        +p{
          文字列リテラルが書けるようになったところで，文字列を操作する方法を伝授しよう．
          文字列の結合は2項演算子\codem{^}でできるほか，
          整数値に評価される式\codem{\meta{expr}}に対し，
          \codem{(arabic (\meta{expr}))}で整数値を十進法文字列にすることができる：

          \d-code-and-block(```
            +p{ Answer: [\show-string(
              `The result is `# ^ (arabic ((1 + 2) * 3 - 4)) ^ `.`
            );] }
          ```)(open Sample in '<
            +p{ Answer: [\show-string(
              `The result is `# ^ (arabic ((1 + 2) * 3 - 4)) ^ `.`
            );] }
          >);%

          ここで使った\codem{(arabic (\meta{expr}))}という式は
          函数\codem{arabic}の\dfnje{適用}{application}であり，
          次節でしっかりと扱う．
        }
        +p{
          ところで，“文字列を整数値に足そうとする” とどうなるだろうか？\quad;
          整数の計算に使った\codem{\\show-int}を含む最初のテンプレートで，
          試しに以下のように記述して処理してみよう：

          \d-code(```
            +p{ Answer: [\show-int(
              42 + `added string`
            );] }
          ```);%

          次のようなエラーが出るはずである：

          \console(```
            ! [Type Error] at "test.saty", line 12, characters 9-23:
                this expression has type
                  string,
                but is expected of type
                  int.
          ```);%

          ファイル名\code(`test.saty`);や行数などは実際にどう記述したかで変わるが，
          どうであれ実際に\codem{\`added string\`}が書かれている位置を指しているはずだ．
          上記のエラーは\SATySFi;の型検査器が出した\dfnje{型エラー}{type error}であり，
          その意味するところは
          「\codem{\`added string\`}という式は\type(Type.string);型の式だが，
          ここには\type(Type.int);型の式が書かれることが期待されている」だ．
          ここでようやく\SATySFi;の特徴たる\dfnje{型}{type}の登場となる．
          といっても，プログラミング言語のもつ特徴としては型は非常に一般的な概念だ\footnote{
            型システムを有していることではなく，
            型システムを組版処理を行なう処理系に持ち込んだことが
            \SATySFi;の顕著な特徴なのである．
          }．
          一旦上のような具体的な型エラーを離れ，型についての一般論の時間にしよう．
          型とは，非常に大雑把に言えば “値の種類による分類”，さらには
          “評価した結果どんな種類の値になることが事前にわかっているかに基づく式の分類”
          である．ここで “事前に” と言っているところが非常に重要だ．
          要するに，“計算を実際に行なわなくともどんな種類の値が結果として出てくるのかが
          式の字面\footnote{より正確には抽象構文木である．}だけからわかる”
          ような仕組みが型によって確立されているということであり，
          この仕組みが\dfnje{型システム}{type system}と呼ばれるものだ．
          型システムを反映して与えられたプログラムが整合しているかどうかを判定する機構が
          型検査器であり，この “整合しているかの検査” は
          プログラムをなす各部分の式に型がつくかどうかを判定することで行なわれる．
        }
        +p{
          式に型をつけることの直観は単純である．
          まず，整数値の型として（上の型エラーにも出てきたように）
          \type(Type.int);型が用意されている．
          最初から値であるような\codem{1}とか\codem{2}とか\codem{500000000}といった
          整数リテラルの式は単純にそのまま\type(Type.int);型がつけられる．
          重要なのは，まだ値でない，評価すると “何かしら計算が進む” 式の型つけだ．
          例えば，加算の式\codem{\metasub(${1}){expr} + \metasub(${2}){expr}}は
          どのように型で扱うかというと，
          「\codem{\metasub(${1}){expr} + \metasub(${2}){expr}}に何らかの型がつくなら
          それは\type(Type.int);型であり，そのためには
          \codem{\metasub(${1}){expr}}と
          \codem{\metasub(${2}){expr}}にそれぞれ\type(Type.int);型がつかねばならない」
          という規則が設けられているのである．
          これが型システムという仕組みの大枠だ．
          本当はもう少し一般性の高い仕組みなのだが，それは次節での函数の型つけの説明に譲る．
        }
        +p{
          さて，上で出た型エラーの話に戻る．
          このエラーの要因は，要するに
          \codem{\metasub(${1}){expr} + \metasub(${2}){expr}}という形の式に型をつけるには
          上記の説明どおり\codem{\metasub(${1}){expr}}と
          \codem{\metasub(${2}){expr}}のそれぞれに
          \type(Type.int);型がつくことが要請されるのだが，
          ここでは\codem{\metasub(${2}){expr}}が\codem{\`added string\`}という
          文字列リテラルであり，これは\type(Type.int);型がつかないと定められている．
          したがって加算の式全体には型がつかないことになり，型検査で弾かれるのである．
        }
      >
      +subsection{函数と条件分岐}<
        +p{
          \REMAINS{函数定義と条件分岐}
        }
      >
      +subsection{代数的データ型}<
        +p{
          \REMAINS{代数的データ型}
        }
        +p{
          \REMAINS{itemize}
        }
      >
      +subsection{再帰函数}<
        +p{
          \REMAINS{再帰函数}
        }
      >
      +subsection{レコード}<
        +p{
          \REMAINS{レコード}
        }
      >
      +subsection{算術に関するプリミティヴ}<
        +p{
          \REMAINS{プリミティヴ}
        }
      >
      +subsection?:(`diff-from-ocaml`){OCamlとの顕著な差異}<
        +p{
          すでに述べたように
          プログラミング言語としての\SATySFi;は
          OCamlにかなり近いものとなっているが，
          非互換な違いがいくつか顕著にある．
        }
        +desc{変数名}{
          おそらくコードの見た目上これが最も目につく違いである．
          変数名はラテン小文字から始まり，
          2文字目以降は大小ラテン文字，数字，ハイフンのいずれかでなければならない．
          アンダースコア（\codem{_}）や
          引用符（\codem{'}）は使えないことに注意．
        }
        +desc{再帰函数の定義}{
          再帰函数の定義には，OCamlの\code(`let rec`);の代わりに
          \codem{let-rec}を用いる．これで1トークンである．
        }
        +desc{型コンストラクタの構文}{
          \SATySFi;では，型コンストラクタ\codem{\meta{tyconstr}}の “適用” は
          \codem{\metasub(${1}){ty} ${\cdots} \metasub(${n}){ty} \meta{tyconstr}}
          という形で書く．これはOCamlの
          \codem{(\metasub(${1}){ty}, ${\ldots}, \metasub(${n}){ty}) \meta{tyconstr}}
          および ${n = 1}の場合の
          \codem{\metasub(${1}){ty} \meta{tyconstr}}
          という形の構文とは明確に異なる．そのかわり，
          OCamlでの\code(`int list list`);のような括弧を省いた “適用” を書くことはできず，
          必ず\codem{(int list) list}と括弧をつけることになる．
        }
        +desc{コンストラクタ}{
          \SATySFi;では，ヴァリアント型のコンストラクタはすべて1引数である．
          \codem{None}のように引数のないコンストラクタの使用は
          \codem{None()}のようにユニット値が省略されているものとして扱われているほか，
          OCamlでは

          \d-code(```
            type foo = Foo of int * int
          ```);%

          と

          \d-code(```
            type foo = Foo of (int * int)
          ```);%

          とで定義される型が異なるが，\SATySFi;では完全に一致する．
        }
        +desc{レコード}{
          まずレコード式を囲む括弧が
          \code(`{`); ${\cdots} \code(`}`);
          の代わりに
          \codem{(\| ${\cdots} \|)}である\footnote{
            これは\codem{\{ ${\cdots} \}}の記法を
            インラインテキストのために明け渡したからである．
          }．
          また，レコード型はnominalではなくstructuralであり，
          したがってレコード式\codem{(\| ${\cdots} \|)}は
          それにつく型を\codem{type ${\cdots}}で宣言せずとも
          書くことができる．
          これは\SATySFi;の型システムがレコードに関して
          \dfn{SML\#}と同様のもの \cite[`Ohori1995`];
          を採用しているからである（詳細は元論文を参照せよ）．
          これに加え，
          OCamlに備わっているような，
          特定のフィールドをmutableにするような機能はなく，
          必ず全てのフィールドがimmutableである．
        }
        +desc{可変参照}{
          可変参照はOCamlのように多相函数\code(`ref`);で作るのではなく，

          \d-codem{
            let-mutable \meta{x} \<- \metasub(${1}){expr} in \metasub(${2}){expr}
          }%

          という構文で作るように限定されている．これはOCamlの

          \d-codem{
            let \meta{x} = ref \metasub(${1}){expr} in \metasub(${2}){expr}
          }%

          と同等である．破壊的代入も，OCamlのように\code(`:=`);ではなく，
          \codem{\meta{x} \<- \meta{expr}}と書く．
          \codem{\<-}が多相な2項演算子なのではなく，
          \codem{\meta{x} \<- \meta{expr}}全体が式をなすひとつの構文である．
        }
      >
    >
  >
  +chapter?:(`overall-structure`){文書が処理される仕組み}< #overall; >
%  +chapter?:(`type-system`){型システム}<
%    +p{
%      既に\ref-chapter(`introduction`);で述べたとおり，
%      \SATySFi;の最大の特徴は型検査器を備えているおかげで
%      或る種の入力の誤りを実際に組版処理を始めるよりも前に検出してすばやく報告できることにある．
%      本章では，この型検査器を実現している型システムについて見ていくことにしよう．
%    }
%    +p{ \REMAINS{} }
%  >
  +chapter?:(`advanced-command-definition`){コマンド定義：発展編}<
    +p{
      \ref-chapter(`basic-command-definition`);
      で基礎的なコマンド定義の方法およびプログラミング言語としての\SATySFi;について習得し，
      \ref-chapter(`overall-structure`);で\SATySFi;の処理系の全体像，
      および各工程がどのように定式化されているかについて概観した．
      これらの前提知識を把握した下で，この章ではようやくフォントや文字色，行送りといった，
      “組版上の装飾的な視覚情報” にも関わる処理を行なうコマンドの実装方法を習得する．
    }
    +section?:(`text-processing-context`){テキスト処理文脈}<
      +p{
        \ref-chapter(`overall-structure`);でも既に述べたが，
        組版処理はインラインテキスト・ブロックテキストといった
        “テキストの情報” だけが与えられてもできない．
        すなわち，どのフォントのどんなサイズで組むか\footnote{
          活版印刷の慣習としては，“font” という語は
          各字形が同一のデザインに則っているだけでなく
          サイズも相等しいひと揃いの活字のセットを指したようだが，
          \SATySFi;でフォントと言う場合は
          （字形やそれに関するメトリックのひとかたまりに紐づけられた）フォント名，
          拡大縮小比率，ベースライン調整率
          の3つ組を指す．詳しくは\ref-chapter(`typography`);で述べる．
        }，段落の幅や行送りはどの程度の長さにするか，
        といった情報が “テキストの情報” に加えて必要である．
        これらの
        “テキストには表れていないが組版処理上必要な情報”
        を，\SATySFi;は
        \dfnje{\index(`テキスト処理文脈`){テキスト処理文脈}}{text-processing context}
        という機構に保持させて扱う．
        抽象的な説明を続けてもおそらく要領を得ないであろうから，
        具体例を用いて説明しよう．
        例えば，文字サイズを1.5倍に変更するコマンド\codem{\\enlarge}を考える：

        \d-code-and-block(```
          +p{ 内側の\enlarge{文字が\enlarge{1.5倍}の大きさに}なります． }
        ```)(open Sample in '<
          +p{ 内側の\enlarge{文字が\enlarge{1.5倍}の大きさに}なります． }
        >);%

        このような\codem{\\enlarge}は次のように定義できる：

        \d-code(```
          let-inline ctx \enlarge it =
            let size = get-font-size ctx in
            let ctx-enlarge = set-font-size (size *' 1.5) ctx in
              read-inline ctx-enlarge it
        ```);%

        唐突に全部見せられてもあまり実感が湧かないであろうから少しずつ説明するが，
        まず1行目から見慣れない文法である．
        \codem{let-inline}を用いてインラインコマンドを定義する構文は
        \ref-chapter(`basic-command-definition`);で既に紹介したが，
        ここでは\codem{let-inline}と定義されるコマンド名\codem{\\enlarge}との間に
        \codem{ctx}なる何かがある．
        実はこれこそがテキスト処理文脈を受け取る “第0引数” の変数だ．
        コマンドの適用が評価されるとき，
        ユーザが与えた通常の引数に加えて，コマンドが使われている箇所のすぐ外側の
        テキスト処理文脈がこの変数\codem{ctx}に渡され，
        コマンドの実装中で使える，というわけである．
        ここまで\pkg{stdjareport}など
        何らかのクラスファイルが提供するマークアップ等の方式に従って
        \SATySFi;を使うにあたってはテキスト処理文脈を全く意識する必要がなかったであろうけれども，
        実のところユーザからは見えない裏側で
        密かに各コマンドがテキスト処理文脈を受け渡ししていたのである．
        なお，\codem{ctx}は単に変数名なので，第0引数に\codem{x}とか\codem{y}とか
        \codem{i-love-satysfi}といった違う名前を使っても構わない\footnote{
          ただし，既存のパッケージでは慣習的に第0引数を必ず\codem{ctx}という変数名にしているので，
          複数人で開発したり，既存パッケージを改造したりする場合は
          \codem{ctx}という変数名で統一した方が理解に齟齬を生じにくいかもしれない．
        }．
      }
      +p{
        さて，続いてコマンド定義の “中身” を見てみる．
        第0引数の\codem{ctx}と（各適用でユーザが与える）第1引数\codem{it}を使うのだが，
        まず\codem{size}に
        外から渡されてきたテキスト処理文脈\codem{ctx}が保持している
        フォントサイズを取り出して束縛する．これはプリミティヴ：

        \val?:(`get-font-size`)({get-font-size})%
          (Type.(context --> length));%

        を用いて行なう．取得したフォントサイズ\codem{size}は\type(Type.(length));型であり，

        \val?:(`*'`)({(\*')})(Type.(length --> (float --> length)));%

        を用いて\codem{size \*' 1.5}で${1.5}倍の長さを得る．
        フォントサイズの設定は

        \val?:(`set-font-size`)({set-font-size})%
          (Type.(length --> (context --> context)));%

        を用いて行なう．
        すなわち，古いテキスト処理文脈\codem{ctx}と設定するフォントサイズ\codem{size}に対して
        \codem{set-font-size size ctx}で
        フォントサイズの更新された新しいテキスト処理文脈が返ってくる．
        \codem{\\enlarge}の実装では，この新しいテキスト処理文脈を
        変数\codem{ctx-enlarge}に束縛している．
        なお，ここの一連の処理で
        \codem{ctx}の内容が “書き換えられる” わけではないことに注意されたい．
        単に\codem{ctx}の内容のうちフォントサイズに関するデータだけが
        \codem{size}に変更された新しいテキスト処理文脈がつくられて
        \codem{ctx-enlarge}という変数に束縛されているだけである．
        実際，\codem{ctx-enlarge}が束縛されたスコープでも
        依然として\codem{ctx}を使うことができ，
        かつそのテキスト処理文脈には元々のフォントサイズが保持されている．
      }
      +p{
        最も重要なのは最終行だ．ここで使われているプリミティヴ

        \val?:(`read-inline`)({read-inline})%
          (Type.(context --> (inline-text --> inline-boxes)));%

        は\ref-chapter(`overall-structure`);で説明した
        インライン変換器に相当し，\ref-figure(`conversion-to-inline-boxes`);
        に示されたような処理をしている．すなわち，
        \codem{read-inline \meta{ctx} \meta{it}}で
        テキスト処理文脈\codem{\meta{ctx}}の保持するフォントや
        文字サイズなどの情報をもとにインラインテキスト\codem{\meta{it}}を
        インラインボックス列へと変換する．
        そしてこれがきわめて重要な事項なのだが，
        インラインテキスト\codem{\meta{it}}に含まれている
        インラインコマンドの適用が評価されるのも，
        この\codem{read-inline}によるインラインボックス列への変換の最中である．
        このとき，\codem{read-inline}に第1引数として渡したテキスト処理文脈が，
        第2引数の\codem{\meta{it}}中の各コマンド適用を評価するときに
        第0引数として渡されるのである．
      }
    >
    +p{
      \REMAINS{コマンドが処理されるアニメーション}
    }
    +p{
      \REMAINS{let-inlineによるエイリアス定義は糖衣構文}
    }
    +p{
      \REMAINS{発展的なコマンド定義：line-break}
    }
  >
  +chapter?:(`line-breaking`){行分割処理}< #line-breaking; >
  +chapter?:(`system-and-config`){システムと設定ファイル}< #system-and-config; >
  +chapter?:(`typography`){文字組版}< #typography; >
  +chapter?:(`graphics`){グラフィックス}< #graphics; >
  +chapter?:(`math`){数式組版}<
    +p{
      主に理工系の文書をしたためる者にとって，
      数式組版機能は水や空気のように当然のものとして組版処理システムに備わっていてほしいものだ．
      \TeX;/\LaTeX;が30年の長きに亘って使われ続けてきた大きな要因のひとつが，
      誰もが納得するような品質の数式組版機能を古くから提供している
      数少ない組版処理システムだったからであることにおそらく異論はないだろう．
    }
    +p{
      \SATySFi;も，\TeX;/\LaTeX;に肩を並べられるくらいの品質の数式組版機能を提供している．
      しかも，既に\ref-chapter(`getting-started`);で見たように，
      \LaTeX;そっくりの構文で書くことができる．
      数式を多大に含む文書を執筆したいという動機で既に盛んに\LaTeX;に触れていた人にとって，
      少なくとも数式の記法が\SATySFi;への移行に関する心理的障壁となることはまずないだろう．
      本章では，\SATySFi;に備わっている数式組版機能について，詳細を追って見ていくことにしよう．
    }
    +p{
      なお，繰り返しになるが，\SATySFi;での数式の記述はコードの見た目上\LaTeX;にそっくりなものの，
      裏でやっていることは両者で全然違う．
      \LaTeX;は字句解析（トークン化）に相当する処理を組版処理と同時進行で行ない，
      かつ構文木も一切構築せずパターンマッチでトークン列を書き換えていくのに対し，
      \SATySFi;は静的に構文解析して数式を構文木の形で保持している．
    }
    +p{ \REMAINS{} }
  >
  +chapter?:(`cross-reference`){相互参照}< #cross-reference; >
  +chapter?:(`page-breaking`){ページ分割処理}< #page-breaking; >
  +chapter?:(`future-work`){Future Work}< #future-work; >
  +chapter?:(`specification`){言語仕様}< #specification; >
>
