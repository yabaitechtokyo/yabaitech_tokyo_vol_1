% -*- coding: utf-8 -*-
@import: settings
@import: preface
@import: introduction
@import: getting-started
@import: alias-command-definition
@import: overall
@import: line-breaking
@import: system-and-config
@import: graphics
@import: cross-reference
@import: future-work
@import: specification
@import: bib

document (|
  title = {The \SATySFi;book};
  author = {T. Suwa};
  preface = preface;
  bibliography = bibliography;
|) '<
  +chapter?:(`introduction`){\SATySFi;の開発動機}< #introduction; >
  +chapter?:(`getting-started`){\SATySFi;簡易入門}< #getting-started; >
  +chapter?:(`basic-command-definition`){コマンド定義：基礎編}<
    +p{
      \ref-chapter(`getting-started`);で\pkg{stdjareport}を用いて
      \SATySFi;の基礎的なコマンドの用法を知った．
      ところで，マークアップ言語の大きな強みのひとつは
      自前でコマンドを定義することによって
      種々の自動処理を実現したり独自の意味マークアップを規定したりできる点にあったはずである．
      実際，\codem{+chapter}とか\codem{+p}とか\codem{\\dfn}とかいった
      コマンドたちは単に\pkg{stdjareport}クラスによって定義が提供されているだけであり，
      その気になればユーザでも同様の定義を書いたりできるはずだ．
      そろそろ自前でコマンドを定義したくてうずうずしている読者も多いかと思う．
      この章では，コマンド定義のごく基礎的な方法を紹介する．
      あらかじめ言ってしまうとここでの説明はとてもアドホックなものになっており，
      \SATySFi;をよく理解されたのちにこの章を読めば
      「こんな子供騙しな説明をしていたのか」と驚かれるかもしれないが，
      読者の様々なバックグラウンドを鑑み，
      まず最初の一歩としておおまかに把握してもらうには良い説明だろうと
      判断してのことなのでご容赦願いたいと思う．
      より深い理解を獲得し，より柔軟で幅広い種類の処理をコマンドとして定義するには，
      \ref-chapter(`overall-structure`);で
      \SATySFi;が行なっている組版処理の全体像を把握した上で
      \ref-chapter(`advanced-command-definition`);に臨んでいただきたい．
    }
    +section{簡単なエイリアス}< #alias-command-definition; >
    +section{プログラミング言語としての\SATySFi;}<
      +p{
        既に述べたように，\SATySFi;はいわゆる函数型らしい特徴を兼ね備えた
        組版処理向けのマークアップ言語である．
        むしろ，より正確を期して言い表すならば
        値呼びの函数型言語の上に組版処理用の種々の言語機能が分厚く搭載された
        DSL（domain-specific language, 領域特化言語）だ．
        プログラミング言語としての\SATySFi;の基礎的部分には
        OCamlに大変よく似た体系が採用されており，
        基礎的部分の理解を得るのにOCamlに関する参考書で代用することも十分可能なほどである．
        とはいえ，OCamlなどの他言語から回り道せずとも\SATySFi;での最低限の直観を身につければ
        十分\SATySFi;でのプログラミングが可能であり，
        熱心に函数型プログラミングの基礎を習得したい読者ばかりではないであろうから，
        ここでも簡単にプログラミング言語としての\SATySFi;について解説する．
        また，OCamlと\SATySFi;との間には目的意識や美意識の違いに起因した多少の差異があるので，
        これについて（既にOCamlで流暢にプログラミングできる読者に対しても）簡単に補足する．
      }
      +subsection{式と値}<
        +p{
          \SATySFi;には対話環境が特に整備されていないので，
          プログラムの計算結果をPDFに出力して確かめることにしよう．
          ひとまず以下のようなコードを見てほしい：

          \d-code(```
            @require: stdjareport

            let-inline \show-int n =
              embed-string (arabic n)
            in

            document (|
              title = {Programming in \SATySFi;};
              author = {計 算太郎};
            |) '<
              +p{ Answer: \show-int(40 + 2); }
            >
          ```);%

          \codem{let-inline}から始まる，
          未知でありながら前節で見たインラインコマンドを定義する方法によく似た構文があるが，
          実際これは\codem{\\show-int}というインラインコマンドの定義である．
          この定義をどう読むのかは後々わかることになるので，
          今の段階では
          「与えられた整数を版面に文字として10進法で出力するコマンド\codem{\\show-int}」
          を定義するオマジナイだと思っていただきたい．
          注目されたいのは\codem{\\show-int}を使う部分，すなわち

          \d-code(```
            ​  +p{ Answer: \show-int(40 + 2); }
          ```);%

          である．丸括弧に囲まれた\codem{40 + 2}という怪しげな記述がある．
          とりあえず，この文書を\SATySFi;処理系にかけてみると，
          この段落に相当する部分は

          \d-block(open Sample in '<
            +p{ Answer: \show-int(40 + 2); }
          >);%

          と出力される．そう，${40} と ${2} の和が計算されているのである．
          平たく言えば，こういった “計算をする処理” がプログラムの仕事の根幹であり，
          “計算をする処理” をプログラムとして記述することをプログラミングと呼ぶ．
          \codem{40 + 2}のような記述は
          \dfnje{\index(`シキ`){式}}{expression}
          またはしばしば
          \dfnje{\index(`コウ`){項}}{term}と呼ばれ，
          式を適切な構文にしたがって組み立てることでプログラムが構築される\footnote{
            C言語やPythonなどの
            “手続き的な” 観点に強く基づいている計算機言語に馴染みのある読者は
            「式から文をつくり，文からプログラムを構築するのではないか？」
            と思われるかもしれないが，
            \SATySFi;に文の概念はない．
            というか，式の特殊な場合が “手続き的な” 言語に備わっている文に相当するのである．
            これはOCamlをはじめとする多くのいわゆる函数型言語に共通する性質である．
          }．
        }
        +p{
          \codem{40 + 2}の “計算が進んで” \codem{42}になったように，
          式は一般に “それ以上計算しない式” へと “うつりかわっていく”．
          この “うつりかわり” の過程を
          \dfnje{\index(`ヒョウカ`){評価}}{evaluation}
          またはしばしば
          \dfnje{\index(`カンヤク`){簡約}}{reduction}
          と呼び， “それ以上計算しない式” を
          \dfnje{\index(`コウブンテキアタイ`){構文的値}}{syntactic value}
          或いは単に
          \dfnje{\index(`アタイ`){値}}{value}
          と呼ぶ．
          プログラムの動作とは，式を評価して値を求めることなのである．
        }
        +p{
          \REMAINS{2項演算子の結合優先度}
        }
      >
      +subsection{変数とその束縛}<
        +p{
          \REMAINS{変数の概念とlet式}
        }
        +p{
          \REMAINS{変数名}
        }
      >
      +subsection{基本的なデータと型}<
        +p{
          \REMAINS{整数，文字列，浮動小数点数，長さ，真偽値}
        }
      >
      +subsection{函数と条件分岐}<
        +p{
          \REMAINS{函数定義と条件分岐}
        }
      >
      +subsection{代数的データ型}<
        +p{
          \REMAINS{代数的データ型}
        }
      >
      +subsection{再帰函数}<
        +p{
          \REMAINS{再帰函数}
        }
      >
    >
  >
  +chapter?:(`overall-structure`){文書が処理される仕組み}< #overall; >
%  +chapter?:(`type-system`){型システム}<
%    +p{
%      既に\ref-chapter(`introduction`);で述べたとおり，
%      \SATySFi;の最大の特徴は型検査器を備えているおかげで
%      或る種の入力の誤りを実際に組版処理を始めるよりも前に検出してすばやく報告できることにある．
%      本章では，この型検査器を実現している型システムについて見ていくことにしよう．
%    }
%    +p{ \REMAINS{} }
%  >
  +chapter?:(`advanced-command-definition`){コマンド定義：発展編}<
    +p{
      \ref-chapter(`basic-command-definition`);
      で基礎的なコマンド定義の方法およびプログラミング言語としての\SATySFi;について習得し，
      \ref-chapter(`overall-structure`);で\SATySFi;の処理系の全体像，
      および各工程がどのように定式化されているかについて概観した．
      これらの前提知識を把握した下で，この章ではようやくフォントや文字色，行送りといった，
      “組版上の装飾的な視覚情報” にも関わる処理を行なうコマンドの実装方法を習得する．
    }
    +section?:(`text-processing-context`){テキスト処理文脈}<
      +p{
        \ref-chapter(`overall-structure`);でも既に述べたが，
        組版処理はインラインテキスト・ブロックテキストといった
        “テキストの情報” だけが与えられてもできない．
        すなわち，どのフォントのどんなサイズで組むか\footnote{
          活版印刷の慣習としては，“font” という語は
          各字形が同一のデザインに則っているだけでなく
          サイズも相等しいひと揃いの活字のセットを指したようだが，
          \SATySFi;でフォントと言う場合は
          （字形やそれに関するメトリックのひとかたまりに紐づけられた）フォント名，
          拡大縮小比率，ベースライン調整率
          の3つ組を指す．詳しくは\ref-chapter(`typography`);で述べる．
        }，段落の幅や行送りはどの程度の長さにするか，
        といった情報が “テキストの情報” に加えて必要である．
        これらの
        “テキストには表れていないが組版処理上必要な情報”
        を，\SATySFi;は
        \dfnje{\index(`テキスト処理文脈`){テキスト処理文脈}}{text-processing context}
        という機構に保持させて扱う．
        抽象的な説明を続けてもおそらく要領を得ないであろうから，
        具体例を用いて説明しよう．
        例えば，文字サイズを1.5倍に変更するコマンド\codem{\\enlarge}を考える：

        \d-code-and-block(```
          +p{ 内側の\enlarge{文字が\enlarge{1.5倍}の大きさに}なります． }
        ```)(open Sample in '<
          +p{ 内側の\enlarge{文字が\enlarge{1.5倍}の大きさに}なります． }
        >);%

        このような\codem{\\enlarge}は次のように定義できる：

        \d-code(```
          let-inline ctx \enlarge it =
            let size = get-font-size ctx in
            let ctx-enlarge = set-font-size (size *' 1.5) ctx in
              read-inline ctx-enlarge it
        ```);%

        唐突に全部見せられてもあまり実感が湧かないであろうから少しずつ説明するが，
        まず1行目から見慣れない文法である．
        \codem{let-inline}を用いてインラインコマンドを定義する構文は
        \ref-chapter(`basic-command-definition`);で既に紹介したが，
        ここでは\codem{let-inline}と定義されるコマンド名\codem{\\enlarge}との間に
        \codem{ctx}なる何かがある．
        実はこれこそがテキスト処理文脈を受け取る “第0引数” の変数だ．
        コマンドの適用が評価されるとき，
        ユーザが与えた通常の引数に加えて，コマンドが使われている箇所のすぐ外側の
        テキスト処理文脈がこの変数\codem{ctx}に渡され，
        コマンドの実装中で使える，というわけである．
        ここまで\pkg{stdjareport}など
        何らかのクラスファイルが提供するマークアップ等の方式に従って
        \SATySFi;を使うにあたってはテキスト処理文脈を全く意識する必要がなかったであろうけれども，
        実のところユーザからは見えない裏側で
        密かに各コマンドがテキスト処理文脈を受け渡ししていたのである．
        なお，\codem{ctx}は単に変数名なので，第0引数に\codem{x}とか\codem{y}とか
        \codem{i-love-satysfi}といった違う名前を使っても構わない\footnote{
          ただし，既存のパッケージでは慣習的に第0引数を必ず\codem{ctx}という変数名にしているので，
          複数人で開発したり，既存パッケージを改造したりする場合は
          \codem{ctx}という変数名で統一した方が理解に齟齬を生じにくいかもしれない．
        }．
      }
      +p{
        さて，続いてコマンド定義の “中身” を見てみる．
        第0引数の\codem{ctx}と（各適用でユーザが与える）第1引数\codem{it}を使うのだが，
        まず\codem{size}に
        外から渡されてきたテキスト処理文脈\codem{ctx}が保持している
        フォントサイズを取り出して束縛する．これはプリミティヴ：

        \val?:(`get-font-size`)({get-font-size})%
          (Type.(context --> length));%

        を用いて行なう．取得したフォントサイズ\codem{size}は\type(Type.(length));型であり，

        \val?:(`*'`)({(\*')})(Type.(length --> (float --> length)));%

        を用いて\codem{size \*' 1.5}で${1.5}倍の長さを得る．
        フォントサイズの設定は

        \val?:(`set-font-size`)({set-font-size})%
          (Type.(length --> (context --> context)));%

        を用いて行なう．
        すなわち，古いテキスト処理文脈\codem{ctx}と設定するフォントサイズ\codem{size}に対して
        \codem{set-font-size size ctx}で
        フォントサイズの更新された新しいテキスト処理文脈が返ってくる．
        \codem{\\enlarge}の実装では，この新しいテキスト処理文脈を
        変数\codem{ctx-enlarge}に束縛している．
        なお，ここの一連の処理で
        \codem{ctx}の内容が “書き換えられる” わけではないことに注意されたい．
        単に\codem{ctx}の内容のうちフォントサイズに関するデータだけが
        \codem{size}に変更された新しいテキスト処理文脈がつくられて
        \codem{ctx-enlarge}という変数に束縛されているだけである．
        実際，\codem{ctx-enlarge}が束縛されたスコープでも
        依然として\codem{ctx}を使うことができ，
        かつそのテキスト処理文脈には元々のフォントサイズが保持されている．
      }
      +p{
        最も重要なのは最終行だ．ここで使われているプリミティヴ

        \val?:(`read-inline`)({read-inline})%
          (Type.(context --> (inline-text --> inline-boxes)));%

        は\ref-chapter(`overall-structure`);で説明した
        インライン変換器に相当し，\ref-figure(`conversion-to-inline-boxes`);
        に示されたような処理をしている．すなわち，
        \codem{read-inline \meta{ctx} \meta{it}}で
        テキスト処理文脈\codem{\meta{ctx}}の保持するフォントや
        文字サイズなどの情報をもとにインラインテキスト\codem{\meta{it}}を
        インラインボックス列へと変換する．
        そしてこれがきわめて重要な事項なのだが，
        インラインテキスト\codem{\meta{it}}に含まれている
        インラインコマンドの適用が評価されるのも，
        この\codem{read-inline}によるインラインボックス列への変換の最中である．
        このとき，\codem{read-inline}に第1引数として渡したテキスト処理文脈が，
        第2引数の\codem{\meta{it}}中の各コマンド適用を評価するときに
        第0引数として渡されるのである．
      }
    >
    +p{
      \REMAINS{コマンドが処理されるアニメーション}
    }
    +p{
      \REMAINS{let-inlineによるエイリアス定義は糖衣構文}
    }
    +p{
      \REMAINS{発展的なコマンド定義：line-break}
    }
  >
  +chapter?:(`line-breaking`){行分割処理}< #line-breaking; >
  +chapter?:(`system-and-config`){システムと設定ファイル}< #system-and-config; >
  +chapter?:(`typography`){文字組版}<
    +p{
      文字は組版処理の主役であり，そして最も人間くささゆえの複雑性を備えた組版処理対象だ．
      現在の\SATySFi;はひとまず和欧混植がそれらしくできることを志向して開発したため
      かなりアドホックな面も目立つのだが，
      ひとまず文字をどのように分類して扱っているかについてここで説明する．
    }
    +section{文字の分類}<
      +p{
        \SATySFi;はUnicodeコードポイントに対して以下の方法でそれぞれ分類する：

        \listing{
          * どの\dfnje{文字体系}{script}に属するか
          * “東アジア的観点から” \dfnje{広い}{wide}文字か\dfnje{狭い}{narrow}文字か
          * どの\dfnje{行分割クラス}{line breaking class}に属するか
        }%

        文字体系は\dfn{Unicode Script Property} \cite[`unicode-script`];により規定されているが，
        現在の\SATySFi;は\code(`Hani`);，\code(`Kana`);，\code(`Latn`);と「それ以外」の4種類を

        \d-code(```
          type script =
            | HanIdeographic
            | Kana
            | Latin
            | OtherScript
        ```);%

        で定義されるような\type(Type.script);型で扱う．
        勿論扱える文字体系は今後増やしていく想定であり，
        或いは\type(Type.script);型のように文字体系があらかじめ言語にハードコードされた方法ではない，
        より一般的な方法で文字体系を区別する方法に変更するかもしれない．
      }
      +p{
        文字が “東アジア的観点から” 広いか狭いかは
        \dfn{East Asian Width} \cite[`unicode-eaw`];に基づいて判断される．
        East Asian Widthは東アジアのレガシーな文字表示に於いて
        各文字が “いわゆる「全角」で表示されるものであるか，
        いわゆる「半角」で表示されるものであるか” といったことを
        規定しているプロパティなのだが，
        \SATySFi;ではこのプロパティを
        主に属する文字体系のないUnicodeコードポイントを扱うのに
        有用な情報として転用している．
        East Asian Widthは各Unicodeコードポイントを
        Fullwidth (F)，Wide (W)，Ambiguous (A)，
        Halfwidth (H)，Narrow (Na)，Neutral (N)
        の6種類のいずれかに分類しており，\SATySFi;は
        このうちの前2分類に該当するUnicodeコードポイントを\dfnje{広い}{wide}文字，
        後ろ4分類に該当するものを\dfnje{狭い}{narrow}文字として扱う．
      }
      +p{
        残る分類方法は行分割クラスである．これは
        \dfn{Unicode Line Breaking Algorithm} \cite[`unicode-lb`];
        で定義されたline breaking classとおおよそ一致する分類方法だが，
        『日本語組版の要件』\cite[`jlreq`];，通称JLreqで定義されている
        \dfn{文字クラス}の要素を取り込んで独自に少し上書きしたものだ．
        すべて掲載すると長いので，
        Unicode Line Breaking Algorithmが定義する
        line breaking classとの差分を以下に述べる：
      }
      +listing{
        * BK (Mandatory Break)，CR (Carriage Return)，LF (Line Feed)，NL (Next Line)を廃止し，
          代わりにいずれもINBR (Input Break)という新しい分類に統一する．

%        * \ucp(`2018`)(`LEFT SINGLE QUOTATION MARK`);

        * JLreqが定義する文字クラス
          cl-01（始め括弧類），
          cl-02（終わり括弧類），
%          cl-03（ハイフン類），
%          cl-04（区切り約物），
%          cl-05（中点類），
          cl-06（句点類），
          cl-07（読点類），
          cl-10（長音記号）
%          cl-11（小書きの仮名）
          に相当する
          JLOP (JL Open Punctuation)，
          JLCP (JL Close Punctuation)，
%          JLHY (JL Hyphens)，
%          JLNS (JL Nonstarter)，
%          JLMD (JL Middle Dot)，
          JLFS (JL Full Stops)，
          JLCM (JL Commas)，
          JLPL (JL Prolonged Sound Mark)
%          JLSM (JL Small Kanas)
          という分類をそれぞれ新たに用意する．

        * \ref-table(`lb`);のとおりに上書きする．
          \table?:(`lb`){行分割クラスの上書き定義}<
            +centering{\size(8.5pt){
              \tabular(fun t -> (
                let l = t#l in
                let ucp snum sname itch itlbc =
                  [ l {\code(`U+` ^ snum);}; l (embed-string sname);
                      l {\fbox{#itch;}}; l itlbc ]
                in
                [
                  ucp `2018` `LEFT SINGLE QUOTATION MARK             ` {‘} {OP};
                  ucp `2019` `RIGHT SINGLE QUOTATION MARK            ` {’} {CP};
                  ucp `201B` `SINGLE HIGH-REVERSED-9 QUOTATION MARK  ` {‛} {OP  };
                  ucp `201C` `LEFT DOUBLE QUOTATION MARK             ` {“} {OP  };
                  ucp `201D` `RIGHT DOUBLE QUOTATION MARK            ` {”} {CP  };
                  ucp `201F` `DOUBLE HIGH-REVERSED-9 QUOTATION MARK  ` {‟} {OP  };
                  ucp `3001` `IDEOGRAPHIC COMMA                      ` {、} {JLCM};
                  ucp `3002` `IDEOGRAPHIC FULL STOP                  ` {。} {JLFS};
                  ucp `3008` `LEFT ANGLE BRACKET                     ` {〈} {JLOP};
                  ucp `3009` `RIGHT ANGLE BRACKET                    ` {〉} {JLCP};
                  ucp `300A` `LEFT DOUBLE ANGLE BRACKET              ` {《} {JLOP};
                  ucp `300B` `RIGHT DOUBLE ANGLE BRACKET             ` {》} {JLCP};
                  ucp `300C` `LEFT CORNER BRACKET                    ` {「} {JLOP};
                  ucp `300D` `RIGHT CORNER BRACKET                   ` {」} {JLCP};
                  ucp `300E` `LEFT WHITE CORNER BRACKET              ` {『} {JLOP};
                  ucp `300F` `RIGHT WHITE CORNER BRACKET             ` {』} {JLCP};
                  ucp `3010` `LEFT BLACK LENTICULAR BRACKET          ` {【} {JLOP};
                  ucp `3011` `RIGHT BLACK LENTICULAR BRACKET         ` {】} {JLCP};
                  ucp `3014` `LEFT TORTOISE SHELL BRACKET            ` {〔} {JLOP};
                  ucp `3015` `RIGHT TORTOISE SHELL BRACKET           ` {〕} {JLCP};
                  ucp `3016` `LEFT WHITE LENTICULAR BRACKET          ` {〖} {JLOP};
                  ucp `3017` `RIGHT WHITE LENTICULAR BRACKET         ` {〗} {JLCP};
                  ucp `3018` `LEFT WHITE TORTOISE SHELL BRACKET      ` {〘} {JLOP};
                  ucp `3019` `RIGHT WHITE TORTOISE SHELL BRACKET     ` {〙} {JLCP};
                  ucp `301A` `LEFT WHITE SQUARE BRACKET              ` {〚} {JLOP};
                  ucp `301B` `RIGHT WHITE SQUARE BRACKET             ` {〛} {JLCP};
                  ucp `30FC` `KATAKANA-HIRAGARA PROLONGED SOUND MARK ` {ー} {JLPL};
                  ucp `FF08` `FULLWIDTH LEFT PARENTHESIS             ` {（} {JLOP};
                  ucp `FF09` `FULLWIDTH RIGHT PARENTHESIS            ` {）} {JLCP};
                  ucp `FF0C` `FULLWIDTH COMMA                        ` {，} {JLCM};
                  ucp `FF0E` `FULLWIDTH FULL STOP                    ` {．} {JLFS};
                  ucp `FF3B` `FULLWIDTH LEFT SQUARE BRACKET          ` {［} {JLOP};
                  ucp `FF3D` `FULLWIDTH RIGHT SQUARE BRACKET         ` {］} {JLCP};
                  ucp `FF5B` `FULLWIDTH LEFT CURLY BRACKET           ` {｛} {JLOP};
                  ucp `FF5D` `FULLWIDTH RIGHT CURLY BRACKET          ` {｝} {JLCP};
                  ucp `FF5F` `FULLWIDTH LEFT WHITE PARENTHESIS       ` {｟} {JLOP};
                  ucp `FF60` `FULLWIDTH RIGHT WHITE PARENTHESIS      ` {｠} {JLCP};
                ]
              ))(fun xs ys ->
                []
              );
            }}
          >
      }
      +p{
        また，これに伴ってUnicode Line Breaking Algorithmも一部拡張する．
        具体的には

        \listing{
          * LB13: ${\times} \meta-or{|CL|CP|EX|IS|SY|JLCP|JLCM|JLFS|}
          * LB14: \meta-or{|OP|JLOP|} ${\text!{SP}^{\ast}} ${\times}
          * LB16: \meta-or{|CL|CP|} ${\text!{SP}^{\ast}} ${\times} \meta-or{|NS|CJ|JLPL|}
          * LB21: ${\times} \meta-or{|BA|HY|NS|CJ|JLPL|}，\quad;BB ${\times}
        }%

        と変更する．規則の読み方は\cite[`unicode-lb`];を参照されたい．
        なお，INBRクラスとSPクラスに該当する文字，つまり “改行文字” や “空白文字” は，
        行分割候補箇所を決定する前に以下に挙げるような規則に基づく正規化処理により除去される場合がある．
        すなわち，\meta-or{|ID|CJ|IN|SA|JLOP|JLCP|JLFS|JLCM|JLPL|} を IDs と略記するとして，
        各 SP または INBR の文字は前後が
        以下のどのパターンに（先に挙げたものほど高い優先度で）マッチするかによって，
        除去するか，残すか，置換するか等の処理を決定する．

        \listing{
          * 前方が IDs，後方が AL にそれぞれマッチする SP または INBR は除去する．
          * 前方が AL，後方が IDs にそれぞれマッチする SP または INBR は除去する．
          * 前方が IDs，後方が IDs にそれぞれマッチする INBR は除去する．
          * 前方が IDs，後方が IDs にそれぞれマッチする SP は残す．
          * 前方が IDs に合致する SP または INBR は除去する．
          * 後方が IDs に合致する SP または INBR は除去する．
          * INBR は SP に置換する．
        }%

        この正規化の処理は，和文の途中にある改行文字は特に何も書いていないのと同じだが，
        欧文の途中にある改行文字は単語間空白と扱われることが期待されている，
        という区別が必要であることを反映したものになっている．
      }
    >
    +section{フォントの扱い}<
      +p{
        \SATySFi;に於ける「フォント」を規定するのは，
        単にOpenTypeフォントファイル\footnote{
          TrueType Collectionの場合も加味すると，
          正確には「フォントファイル内の要素のひとつ」．
        }に関連づけられたフォント名 ${F} ではなく，
        これに\dfn{拡大率} ${r} と\dfn{ベースライン調整率} ${r'} という2つの数値が備えつけられた3つ組
        ${\tuple{|F|r|r'|}} である．
        フォントは文字体系ごとに別個に設定され，
        次のようなプリミティヴを用いる：

        \val-explain?:(`set-font`)({set-font})%
          (Type.(script --> (product [string; float; float] --> (context --> context)))) {
            \codem{\meta{ctx} \|\> set-font \meta{script} (\meta{fontname}, \meta{r}, \meta{rb})}
            で文字体系\codem{\meta{script}}のフォント設定を\codem{(\meta{fontname}, \meta{r}, \meta{rb})}
            に更新したテキスト処理文脈\codem{\meta{ctx}}を返す．
          }%

        \val-explain?:(`get-font`)({get-font})%
          (Type.(context --> (script --> product [string; float; float]))) {
            \codem{get-font \meta{script} \meta{ctx}}で
            \codem{\meta{ctx}}に格納されている\codem{\meta{script}}のフォント設定を取り出す．
          }%

        拡大率が ${r} に設定されている場合，テキスト処理文脈設定されている文字サイズを ${s} としたとき，
        ${F} のもつグリフやメトリックの情報は ${r s} を1emとするようなサイズで使われる．
        すなわち，${r < 1} なら “標準的な大きさ” から縮小補正がかかり，
        ${r > 1} なら拡大補正，${r = 1} ならばそのまま，ということである．
        さらに，ベースライン調整率が ${r'} に設定されている場合，
        ${F} のグリフは通常よりも ${r' s} だけベースラインを持ち上げた位置に描かれる．
        すなわち，${r' = 0} なら補正せず，${r' < 0} ならば基準よりも下に，
        ${r' > 0} ならば上に補正される．
        これら拡大率とベースライン調整率は，
        ラテン文字と漢字などベースラインに対する捉え方の異なる文字体系をスムーズに共存させるための補正である．
        実際，ラテン文字と漢字で異なるフォントデータ ${F_1}，${F_2} を用いて組み，
        フォントサイズ ${s} をそのまま ${F_1} と ${F_2} の両方で素直に1emにすると，
        大抵の場合はラテン文字の方が小さく見えてしまう．
        そこで，通常は和文の方を小さくするように補正する．
        本書では${r_1 = 1}，${r_2 = 0.88} という拡大率を
        ラテン文字に使うフォントと漢字や仮名に使うフォントにそれぞれ設定している．
        なお，ベースライン調整率は両者ともに ${0} にしている．
        和文フォントは和欧混植を見越してか
        もともとベースラインを仮想ボディの下端よりも上に設定しているものが多く，
        改めて補正する必要がなかったためである．
      }
    >
    +section{異なる文字体系間の空白}<
      +p{
        一般に，ラテン文字と漢字など，異なる文字体系の文字が隣接する際には
        字間を空けないと詰まりすぎて見える．
        \SATySFi;は，互いに異なる文字体系に属する文字が隣接している箇所に自動でグルーを挿入する．
        このグルーの各長さに関する情報は単語間空白と同様にフォントサイズに対する比率で
        テキスト処理文脈が保持している．
        デフォルトでは
        \codem{Latin}と\codem{HanIdeographic}の間，\codem{Latin}と\codem{Kana}の間，
        およびそれらの前後逆の4種類の組み合わせに対して\codem{(0.24, 0.08, 0.16)}が設定されているが，
        以下のプリミティヴによって変更できる：

        \val-explain?:(`set-space-ratio-between-scripts`)({set-space-ratio-between-scripts})%
          (Type.(script --> (script --> (float --> (float --> (float --> (context --> context))))))) {
            \codem{\meta{ctx} \|\> set-space-ratio-between-scripts
              \metasub(${1}){script} \metasub(${2}){script}
                \metasub(${0}){r} \metasub(${1}){r} \metasub(${2}){r}}
            で前方が文字体系\codem{\metasub(${1}){script}}の文字，
            後方が文字体系\codem{\metasub(${2}){script}}の文字の隣接箇所で
            自然長，収縮基準長，伸長基準長の文字サイズに対する比率が
            それぞれ
            \codem{\metasub(${0}){r}}，
            \codem{\metasub(${1}){r}}，
            \codem{\metasub(${2}){r}}であるようなグルーを挿入するように
            \codem{\meta{ctx}}を更新したテキスト処理文脈を返す．
          }%

        スペーシングに関してインラインボックス列を
        特定の文字体系のテキストに “擬態させる” 方法として，
        次のプリミティヴが使える：

        \val-explain?:(`script-guard`)({script-guard})%
          (Type.(script --> (inline-boxes --> inline-boxes))) {
            \codem{script-guard \meta{script} \meta{ib}}で
            インラインボックス列\codem{\meta{ib}}を前後のスペーシングに関して
            文字体系\codem{\meta{script}}のテキストとして扱う．
          }%
      }
    >
    +section{寡占的文字体系}<
      +p{
        文字の広い/狭いの区別は，文字体系が特に定まっていない約物などのUnicodeコードポイントを
        特定の文字体系へと “吸収” するのに用いる．
        \SATySFi;では，テキストは基本的に “代表となる文字体系” が意識されて書かれているという仮定のもと，
        テキスト処理文脈に “現在の寡占的な文字体系” の情報を保持させるようになっている．
        “寡占的な文字体系” は2つ設定することができ，
        ひとつは特定の文字体系に属さない広い文字をどの文字体系に “吸収” して扱うかで，
        もうひとつは特定の文字体系に属さない狭い文字をどの文字体系へと “吸収” して扱うかである．
        前者に設定された文字体系を\dfnje{広い寡占的文字体系}{dominant wide script}，
        後者を\dfnje{狭い寡占的文字体系}{dominant narrow script}と呼ぶ．
        例えば和欧混植の場合，前者は\codem{Kana}，後者は\codem{Latin}に設定するとよい．
        こうすることで，いわゆる “全角用の” 約物は仮名の仲間として扱われることになってフォントも仮名と揃えられ，
        一方で “アルファベット用の” 約物はラテン文字の仲間として扱われ，
        フォントがラテン文字のものと揃えられることになる．
        このような設定に関与するのが以下のプリミティヴたちである：

        \val-explain?:(`set-dominant-wide-script`)({set-dominant-wide-script})%
          (Type.(script --> (context --> context))) {
            第1引数に与えられた文字体系を広い寡占的文字体系に設定する．
          }%

        \val-explain?:(`get-dominant-wide-script`)({get-dominant-wide-script})%
          (Type.(context --> script)) {
            広い寡占的文字体系に設定されている文字体系を取得する．
          }%

        \val-explain?:(`set-dominant-narrow-script`)({set-dominant-narrow-script})%
          (Type.(script --> (context --> context))) {
            第1引数に与えられた文字体系を狭い寡占的文字体系に設定する．
          }%

        \val-explain?:(`get-dominant-narrow-script`)({get-dominant-narrow-script})%
          (Type.(context --> script)) {
            狭い寡占的文字体系に設定されている文字体系を取得する．
          }%

        以上の仕組みを知って「なんとアドホックな仕組みであることか」と驚かれる読者も多いかもしれない．
        正直なところ著者もそう思うが，一応現状では和欧混植に関してよく効力を発揮している．
        おそらく “より多言語な組版” を扱うには耐えない仕組みであろうから，
        この仕組みが将来の非互換な変更で大きく形を変える可能性は高い．
      }
    >
  >
  +chapter?:(`graphics`){グラフィックス}< #graphics; >
  +chapter?:(`math`){数式組版}<
    +p{
      主に理工系の文書をしたためる者にとって，
      数式組版機能は水や空気のように当然のものとして組版処理システムに備わっていてほしいものだ．
      \TeX;/\LaTeX;が30年の長きに亘って使われ続けてきた大きな要因のひとつが，
      誰もが納得するような品質の数式組版機能を古くから提供している
      数少ない組版処理システムだったからであることにおそらく異論はないだろう．
    }
    +p{
      \SATySFi;も，\TeX;/\LaTeX;に肩を並べられるくらいの品質の数式組版機能を提供している．
      しかも，既に\ref-chapter(`getting-started`);で見たように，
      \LaTeX;そっくりの構文で書くことができる．
      数式を多大に含む文書を執筆したいという動機で既に盛んに\LaTeX;に触れていた人にとって，
      少なくとも数式の記法が\SATySFi;への移行に関する心理的障壁となることはまずないだろう．
      本章では，\SATySFi;に備わっている数式組版機能について，詳細を追って見ていくことにしよう．
    }
    +p{
      なお，繰り返しになるが，\SATySFi;での数式の記述はコードの見た目上\LaTeX;にそっくりなものの，
      裏でやっていることは両者で全然違う．
      \LaTeX;は字句解析（トークン化）に相当する処理を組版処理と同時進行で行ない，
      かつ構文木も一切構築せずパターンマッチでトークン列を書き換えていくのに対し，
      \SATySFi;は静的に構文解析して数式を構文木の形で保持している．
    }
    +p{ \REMAINS{} }
  >
  +chapter?:(`cross-reference`){相互参照}< #cross-reference; >
  +chapter?:(`page-breaking`){ページ分割処理}<
    +p{
      ページ分割は，
      おそらく\SATySFi;の機構の中でも最も理解が難しい部分だろう．
      処理の概要自体はブロックボックス列になった文書の全内容を適切な長さで切り分けて
      各ページの内容にするというだけなのだが，
      まともな文書をつくるにはページ分割に伴って種々の手続き的処理を行なう必要があり，
      したがってクラスファイルを開発するには避けて通れない道である．
      まず，ページ分割処理に相当するプリミティヴは

      \val({page-break})(Type.(page --> (tymtausub ${2} --> (tymtausub ${3} --> (block-boxes --> document)))));%

      である．\type(Type.(tymtausub ${2}));と\type(Type.(tymtausub ${3}));は
      やや複雑なため後述するが，
      これらの型がつく第2・第3引数を置いておけば
      \codem{page-break}のインターフェイスは単純極まりないもので，
      第1引数は紙面のサイズ，第4引数はページ分割対象となるブロックボックス列である．
      \type(Type.page);型は

      \d-code(```
        type page =
          | A0Paper | A1Paper | A2Paper | A3Paper | A4Paper | A5Paper
          | USLetter | USLegal
          | UserDefinedPaper of length * length
      ```);%

      で定義されるようなデータ型で，
      \codem{A4Paper}などのコンストラクタが
      それぞれ何を表すのかは想像のとおりである\footnote{
        正直なところ紙面のサイズ指定は
        \type(Type.(product [length; length]));型で十分で，
        \codem{A4Paper}などに相当する値は

        \val({Paper.a4})(Type.(product [length; length]));%

        のようにパッケージレヴェルで与えればよかったのだが，
        過去の阿呆な著者はこんな形式化をしてしまった．
        おそらく最も近い将来の非互換な変更でこの\type(Type.page);型は姿を消すだろう．
      }．
      要するに，ひとまず最も大雑把に言えば，
      \codem{page-break}とは第4引数に与えられたブロックボックス列を
      第1引数に与えられた紙面の大きさに基づいてページ分割を行なうプリミティヴ，
      ということになる．
      ただし，これだけでは説明としてあまりにも語弊が大きいので，
      以降順次詳細に説明する．
    }
    +p{
      まず注目すべきは\codem{page-break}の返り値の型\type(Type.document);だ．
      この型は\codem{page-break}以外のプリミティヴには返り値の型として一切現れず，
      したがって\type(Type.document);型の値を構築することは
      本質的に\codem{page-break}によってしかできないようになっている．
      \SATySFi;は文書ファイルにつく型が\type(Type.document);型であることを型検査時に要請するので，
      クラスファイルの奥底には必ず\codem{page-break}があって\footnote{
        ユーザに直接\codem{page-break}を書かせるような病的なクラスファイルなら
        \codem{page-break}を含まないかもしれないが，
        そんなクラスファイルをつくるような必要はほぼない．
      }，
      そこでユーザが与えた種々の情報をもとに組み上げられたブロックボックス列に
      ページ分割処理を施すための記述が為されている．
      \pkg{stdjareport}クラスに基づいて文書を作成するときに書いていた

      \d-code(```
        @require: stdjareport

        document (|
          （文書情報）
        |) '<
          （内容）
        >
      ```);%

      の\codem{document}は実は単なる函数であり，上の記述は
      \codem{document}という函数の適用である．\codem{document}函数は

      \quote{
        \type(Type.(forall-kinded ${\alpha}
          [
            (`title`, inline-text);
            (`author`, inline-text);
          ]
          (tymalpha --> (block-text --> document))));
      }%

      という型をもつので，タイトルおよび著者を記述したレコードを第1引数に，
      文書内容のブロックテキストを第2引数に受け取り，
      最終的に\type(Type.document);型の値を返すということになっているのである．
    }
    +p{
      さて，後回しにしていた\type(Type.(tymtausub ${2}));の話である．
      これは以下のような型だ：

      \quote{
        \type(Type.(
          record [(`page-number`, int)] -->
            record [(`text-height`, length); (`text-origin`, point)]
        ));
      }%

      ここから，ひとまず\codem{page-break}に与える第2引数は
      レコードを受け取ってレコードを返す函数であることがわかる．
      この函数は，ページ分割処理の最中に ${\paren{n - 1}} ページまでの内容が確定し，
      今まさに残りのブロックボックス列から ${n} ページ目の内容を切り分ける箇所を
      探し始めるというときに
      \codem{(\| page-number = \meta{n}\; \|)}
      というレコードが渡されることで呼び出され，
      \codem{(\| text-height = \meta{h}\; text-origin = (\meta{x}, \meta{y})\; \|)}
      という形の値を返すことで

      \listing{
        * ${h}：\quad;
            ${n} ページ目の内容のテキストの領域の段落方向の長さ
        * ${\tuple{|x|y|}}：\quad;
            実際に切り分けられた内容を配置するときの左上の座標
      }%

      という情報をページ分割処理を担う機構に教える．
      ただし，グラフィックスの座標系とは異なり，
      ここでの ${\tuple{|x|y|}} の ${y} は
      紙面の左上を原点とし下向きを ${+y} 方向とする座標系に基づく値なので
      注意されたい．
      どのページも同じ地点から同じ長さだけ本文が記述されているような文書を出力したいなら
      ${n} によらず同一の ${h} と ${\tuple{|x|y|}} を返すような函数にすればよいし，
      ページの左右で（綴じしろなどの都合で）余白を変えたい場合は
      ${n} の偶奇で異なる値を返すような函数にすればよいだろう．
    }
    +p{
      同様に，\codem{page-break}の第3引数につく型である
      \type(Type.(tymtausub ${3}));についても述べると，
      以下のようなものである：

      \quote{
        \type(Type.(
          record [(`page-number`, int)] -->
            record [
              (`header-content`, block-boxes);
              (`header-origin`, point);
              (`footer-content`, block-boxes);
              (`footer-origin`, point);
            ]
        ));
      }%

      やはりレコードを受け取ってレコードを返す函数の型である．
      \codem{page-break}の第3引数に指定された函数は，
      第 ${n} ページの内容が確定し，
      後述するようなページ内の “フック処理” がすべて終了したときに
      \codem{(\| page-number = \meta{n}\; \|)}
      というレコードが渡されることで呼び出され，

      \d-codem{
        (\|
        \new-line;\quad;
        header-content = \metasub(${1}){bb}\;
        header-origin = (\metasub(${1}){x}, \metasub(${1}){y})\;
        \new-line;\quad;
        footer-content = \metasub(${2}){bb}\;
        footer-origin = (\metasub(${2}){x}, \metasub(${2}){y})\;
        \new-line;
        \|)
      }%

      という形のレコードを返すことで

      \listing{
        * ${\tuple{|x_1|y_1|}} を左上としてブロックボックス列 ${bb_1} をヘッダとして描く
        * ${\tuple{|x_2|y_2|}} を左上としてブロックボックス列 ${bb_2} をフッタとして描く
      }%

      という情報を与える．
      上で説明した第2引数と同じく，
      ここで返す座標も左上を原点とし下向きを ${+y} 方向とする座標系であるので注意されたい．
      この座標系を用いるのは\codem{page-break}の第2・第3引数のみである．
    }
    +p{
      以上がプリミティヴ\codem{page-break}の仕様なのだが，
      ほんの少しつけ加えるとすれば，それは “実際に行分割が行なわれるタイミング” についてである．
      実は “\codem{page-break}自体がページ分割処理をしている” わけではなく，
      文書全体が\type(Type.document);型の値として返された時，
      初めてページ分割処理が起動する．
      言うなれば，\type(Type.document);型の値とは
      最終的なページ分割に関わる情報を実際にページ分割を行なわずに “凍結” したものである．
      したがって，最終的に返される\type(Type.document);型の値以外に
      \type(Type.document);型の値をつくるような処理を書いたとしても，
      それが実際にページ分割されることはない．
      そもそも\type(Type.document);型の値を加工するようなプリミティヴは一切ないので，
      PDFに出力する内容を返す以外で
      \codem{page-break}によって\type(Type.document);型の値をつくる意味はなく，
      意味があるとすればそれは返り値を使わずに
      ページ分割時の “副作用” だけ起こすことを意図したものであろうが，
      それもできないようになっているのである\footnote{
        できないようになっている理由は特にないので，
        必要があれば将来の非互換な変更で仕様を変え，
        “\codem{page-break}自体がページ分割処理をする”
        ようにしてもよいかもしれない．
      }．
    }
    +section{ページ分割に関連するプリミティヴ}<
      +p{
        ページ分割に関する処理を行なうためのプリミティヴがいくつかあるので，
        ここで紹介する．

        \val-explain?:(`clear-page`)({clear-page})%
          (Type.(block-boxes)) {
            強制的に改ページする．
            ページ分割される対象ではない箇所に挿入されている場合は
            \codem{block-nil}と等価である．
          }%

        \val-explain?:(`add-footnote`)({add-footnote})%
          (Type.(block-boxes --> inline-boxes)) {
            \codem{add-footnote \meta{bb}}で
            ブロックボックス列\codem{\meta{bb}}を脚註として挿入する．
            返り値は\type(Type.inline-boxes);型で，
            この返り値のインラインボックス列を挿入した場所に関連づけられて
            ページ分割処理時に脚註の挿入されるページが決まる．
            インラインボックス列としての効能自体は
            \codem{inline-nil}と同等である．
          }%

        \val-explain?:(`hook-page-break`)({hook-page-break})%
          (Type.(((record [(`page-number`, int)] --> (point --> unit))) --> inline-boxes)) {
            \codem{hook-page-break \meta{f}}の形で使う．
            返り値はインラインボックス列であり，組版上の効能は\codem{inline-nil}と同等なのだが，
            ページ分割処理の最中にこれが挿入されている箇所がどのページに含まれるか確定したときに
            “フック函数” である\codem{\meta{f}}が起動される．
            同一ページ内に複数の “フック函数” が仕込まれている場合，
            ページ内容上で手前にあるものから順に起動される．
            この “フック” 函数の潜んだインラインボックス列が
            ページ分割の結果 ${n} ページ目に含まれることになり，
            その参照点が ${\tuple{|x|y|}} であったとき，
            \codem{\meta{f}}には第1引数として
            \codem{(\| page-number = \meta{n}\; \|)}
            が，第2引数として
            \codem{(\meta{x}, \meta{y})}
            が渡されることで起動される．
            そしてそれらの引数の値を用いてこの\codem{\meta{f}}の “函数の中身” で
            ページ番号に基づく相互参照の紐づけを新たに登録したりといった
            様々な “副作用” が起こせる，というわけである．
          }%

        \ref-chapter(`graphics`);で説明した
        「グラフィックスの評価はページ分割時に行なわれる」という話は，
        実はこの\codem{hook-page-break}と同様である．
        \codem{inline-graphics}の第4引数など，
        参照点を受け取ってグラフィックスを返す類いの函数は，
        \codem{hook-page-break}による “フック函数” と同じタイミングで評価が起動するのである．
      }
    >
    +section{クラスファイルの基礎}<
      +p{
        さて，ページ分割処理について把握したところで
        クラスファイルを創ろうと軽く思い立ったとき，
        ふと今まで特に意識していなかったことに気づくかもしれない：\quad;
        “最も外側の” テキスト処理文脈はどこから来るのだろう？\quad;
        これはごく単純で，次のようなプリミティヴによって受け取れる：

        \val-explain?:(`get-initial-context`)({get-initial-context})%
          (Type.(length --> (cmdI [math] --> context))) {
            デフォルトのテキスト処理文脈を返す．
            第1引数は段落幅を，
            第2引数はインラインテキスト中に現れた数式に適用するコマンドを
            \codem{set-math-command}と同じ要領で与える．
          }%

        段落幅を指定できるのはこの\codem{get-initial-context}のみである．
        “まともな” クラスファイルの中にはこの\codem{get-initial-context}が必ずどこかにあり，
        これが返したテキスト処理文脈を適宜加工して “最も外側の” テキスト処理文脈としているのである．
      }
      +example{
        “多少なりともまともに使える，実質的に最小のクラスファイル” は以下のように定義できる：

        \d-code(```
          let-inline ctx \math m =
            script-guard Latin (embed-math ctx m)

          let-block ctx +p it =
            line-break true true ctx
              (read-inline ctx it ++ inline-fil)

          let document bt =
            let ctx =
              get-initial-context 440pt (command \math)
                |> set-dominant-narrow-script Latin
            in
            let bb = read-block ctx bt in
            page-break A4Paper
              (fun _ -> (|
                text-origin = (80pt, 100pt);
                text-height = 630pt;
              |))
              (fun _ -> (|
                header-origin  = (0pt, 0pt);
                header-content = block-nil;
                footer-origin  = (0pt, 0pt);
                footer-content = block-nil;
              |))
              bb
        ```);%

        このクラスファイルの下では，
        ユーザが新たにコマンドを定義しない限り，
        \codem{+p}を用いてひたすら段落が並べられたブロックテキストを
        \codem{document}の引数に渡した文書しか記述することができない．
      }
    >
  >
  +chapter?:(`future-work`){Future Work}< #future-work; >
  +chapter?:(`specification`){言語仕様}< #specification; >
>
