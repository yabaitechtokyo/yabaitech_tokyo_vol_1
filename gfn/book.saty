% -*- coding: utf-8 -*-
@import: settings
@import: preface
@import: introduction
@import: getting-started
@import: alias-command-definition
@import: overall
@import: line-breaking
@import: graphics
@import: cross-reference
@import: bib

document (|
  title = {The \SATySFi;book};
  author = {T. Suwa};
  preface = preface;
  bibliography = bibliography;
|) '<
  +chapter?:(`introduction`){\SATySFi;の開発動機}< #introduction; >
  +chapter?:(`getting-started`){\SATySFi;簡易入門}< #getting-started; >
  +chapter?:(`basic-command-definition`){コマンド定義：基礎編}<
    +p{
      \ref-chapter(`getting-started`);で\pkg{stdjareport}を用いて
      \SATySFi;の基礎的なコマンドの用法を知った．
      ところで，マークアップ言語の大きな強みのひとつは
      自前でコマンドを定義することによって
      種々の自動処理を実現したり独自の意味マークアップを規定したりできる点にあったはずである．
      実際，\codem{+chapter}とか\codem{+p}とか\codem{\\dfn}とかいった
      コマンドたちは単に\pkg{stdjareport}クラスによって定義が提供されているだけであり，
      その気になればユーザでも同様の定義を書いたりできるはずだ．
      そろそろ自前でコマンドを定義したくてうずうずしている読者も多いかと思う．
      この章では，コマンド定義のごく基礎的な方法を紹介する．
      あらかじめ言ってしまうとここでの説明はとてもアドホックなものになっており，
      \SATySFi;をよく理解されたのちにこの章を読めば
      「こんな子供騙しな説明をしていたのか」と驚かれるかもしれないが，
      読者の様々なバックグラウンドを鑑み，
      まず最初の一歩としておおまかに把握してもらうには良い説明だろうと
      判断してのことなのでご容赦願いたいと思う．
      より深い理解を獲得し，より柔軟で幅広い種類の処理をコマンドとして定義するには，
      \ref-chapter(`overall-structure`);で
      \SATySFi;が行なっている組版処理の全体像を把握した上で
      \ref-chapter(`advanced-command-definition`);に臨んでいただきたい．
    }
    +section{簡単なエイリアス}< #alias-command-definition; >
    +section{プログラミング言語としての\SATySFi;}<
      +p{
        既に述べたように，\SATySFi;はいわゆる函数型らしい特徴を兼ね備えた
        組版処理向けのマークアップ言語である．
        むしろ，より正確を期して言い表すならば
        値呼びの函数型言語の上に組版処理用の種々の言語機能が分厚く搭載された
        DSL（domain-specific language, 領域特化言語）だ．
        プログラミング言語としての\SATySFi;の基礎的部分には
        OCamlに大変よく似た体系が採用されており，
        基礎的部分の理解を得るのにOCamlに関する参考書で代用することも十分可能なほどである．
        とはいえ，OCamlなどの他言語から回り道せずとも\SATySFi;での最低限の直観を身につければ
        十分\SATySFi;でのプログラミングが可能であり，
        熱心に函数型プログラミングの基礎を習得したい読者ばかりではないであろうから，
        ここでも簡単にプログラミング言語としての\SATySFi;について解説する．
        また，OCamlと\SATySFi;との間には目的意識や美意識の違いに起因した多少の差異があるので，
        これについて（既にOCamlで流暢にプログラミングできる読者に対しても）簡単に補足する．
      }
      +subsection{式と値}<
        +p{
          \SATySFi;には対話環境が特に整備されていないので，
          プログラムの計算結果をPDFに出力して確かめることにしよう．
          ひとまず以下のようなコードを見てほしい：

          \d-code(```
            @require: stdjareport

            let-inline \show-int n =
              embed-string (arabic n)
            in

            document (|
              title = {Programming in \SATySFi;};
              author = {計 算太郎};
            |) '<
              +p{ Answer: \show-int(40 + 2); }
            >
          ```);%

          \codem{let-inline}から始まる，
          未知でありながら前節で見たインラインコマンドを定義する方法によく似た構文があるが，
          実際これは\codem{\\show-int}というインラインコマンドの定義である．
          この定義をどう読むのかは後々わかることになるので，
          今の段階では
          「与えられた整数を版面に文字として10進法で出力するコマンド\codem{\\show-int}」
          を定義するオマジナイだと思っていただきたい．
          注目されたいのは\codem{\\show-int}を使う部分，すなわち

          \d-code(```
            ​  +p{ Answer: \show-int(40 + 2); }
          ```);%

          である．丸括弧に囲まれた\codem{40 + 2}という怪しげな記述がある．
          とりあえず，この文書を\SATySFi;処理系にかけてみると，
          この段落に相当する部分は

          \d-block(open Sample in '<
            +p{ Answer: \show-int(40 + 2); }
          >);%

          と出力される．そう，${40} と ${2} の和が計算されているのである．
          平たく言えば，こういった “計算をする処理” がプログラムの仕事の根幹であり，
          “計算をする処理” をプログラムとして記述することをプログラミングと呼ぶ．
          \codem{40 + 2}のような記述は
          \dfnje{\index(`シキ`){式}}{expression}
          またはしばしば
          \dfnje{\index(`コウ`){項}}{term}と呼ばれ，
          式を適切な構文にしたがって組み立てることでプログラムが構築される\footnote{
            C言語やPythonなどの
            “手続き的な” 観点に強く基づいている計算機言語に馴染みのある読者は
            「式から文をつくり，文からプログラムを構築するのではないか？」
            と思われるかもしれないが，
            \SATySFi;に文の概念はない．
            というか，式の特殊な場合が “手続き的な” 言語に備わっている文に相当するのである．
            これはOCamlをはじめとする多くのいわゆる函数型言語に共通する性質である．
          }．
        }
        +p{
          \codem{40 + 2}の “計算が進んで” \codem{42}になったように，
          式は一般に “それ以上計算しない式” へと “うつりかわっていく”．
          この “うつりかわり” の過程を
          \dfnje{\index(`ヒョウカ`){評価}}{evaluation}
          またはしばしば
          \dfnje{\index(`カンヤク`){簡約}}{reduction}
          と呼び， “それ以上計算しない式” を
          \dfnje{\index(`コウブンテキアタイ`){構文的値}}{syntactic value}
          或いは単に
          \dfnje{\index(`アタイ`){値}}{value}
          と呼ぶ．
          プログラムの動作とは，式を評価して値を求めることなのである．
        }
        +p{
          \REMAINS{2項演算子の結合優先度}
        }
      >
      +section{変数とその束縛}<
        +p{
          \REMAINS{変数の概念とlet式}
        }
        +p{
          \REMAINS{変数名}
        }
      >
      +section{基本的なデータと型}<
        +p{
          \REMAINS{整数，文字列，浮動小数点数，長さ，真偽値}
        }
      >
      +section{函数と条件分岐}<
        +p{
          \REMAINS{函数定義と条件分岐}
        }
      >
      +section{代数的データ型}<
        +p{
          \REMAINS{代数的データ型}
        }
      >
      +section{再帰函数}<
        +p{
          \REMAINS{再帰函数}
        }
      >
    >
  >
  +chapter?:(`overall-structure`){文書が処理される仕組み}< #overall; >
%  +chapter?:(`type-system`){型システム}<
%    +p{
%      既に\ref-chapter(`introduction`);で述べたとおり，
%      \SATySFi;の最大の特徴は型検査器を備えているおかげで
%      或る種の入力の誤りを実際に組版処理を始めるよりも前に検出してすばやく報告できることにある．
%      本章では，この型検査器を実現している型システムについて見ていくことにしよう．
%    }
%    +p{ \REMAINS{} }
%  >
  +chapter?:(`advanced-command-definition`){コマンド定義：発展編}<
    +p{
      \ref-chapter(`basic-command-definition`);
      で基礎的なコマンド定義の方法およびプログラミング言語としての\SATySFi;について習得し，
      \ref-chapter(`overall-structure`);で\SATySFi;の処理系の全体像，
      および各工程がどのように定式化されているかについて概観した．
      これらの前提知識を把握した下で，この章ではようやくフォントや文字色，行送りといった，
      “組版上の装飾的な視覚情報” にも関わる処理を行なうコマンドの実装方法を習得する．
    }
    +section?:(`text-processing-context`){テキスト処理文脈}<
      +p{
        \ref-chapter(`overall-structure`);でも既に述べたが，
        組版処理はインラインテキスト・ブロックテキストといった
        “テキストの情報” だけが与えられてもできない．
        すなわち，どのフォントのどんなサイズで組むか\footnote{
          活版印刷の慣習としては，“font” という語は
          各字形が同一のデザインに則っているだけでなく
          サイズも相等しいひと揃いの活字のセットを指したようだが，
          \SATySFi;でフォントと言う場合は
          （字形やそれに関するメトリックのひとかたまりに紐づけられた）フォント名，
          拡大縮小比率，ベースライン調整率
          の3つ組を指す．詳しくは\ref-chapter(`typography`);で述べる．
        }，段落の幅や行送りはどの程度の長さにするか，
        といった情報が “テキストの情報” に加えて必要である．
        これらの
        “テキストには表れていないが組版処理上必要な情報”
        を，\SATySFi;は
        \dfnje{\index(`テキスト処理文脈`){テキスト処理文脈}}{text-processing context}
        という機構に保持させて扱う．
        抽象的な説明を続けてもおそらく要領を得ないであろうから，
        具体例を用いて説明しよう．
        例えば，文字サイズを1.5倍に変更するコマンド\codem{\\enlarge}を考える：

        \d-code-and-block(```
          +p{ 内側の\enlarge{文字が\enlarge{1.5倍}の大きさに}なります． }
        ```)(open Sample in '<
          +p{ 内側の\enlarge{文字が\enlarge{1.5倍}の大きさに}なります． }
        >);%

        このような\codem{\\enlarge}は次のように定義できる：

        \d-code(```
          let-inline ctx \enlarge it =
            let size = get-font-size ctx in
            let ctx-enlarge = set-font-size (size *' 1.5) ctx in
              read-inline ctx-enlarge it
        ```);%

        唐突に全部見せられてもあまり実感が湧かないであろうから少しずつ説明するが，
        まず1行目から見慣れない文法である．
        \codem{let-inline}を用いてインラインコマンドを定義する構文は
        \ref-chapter(`basic-command-definition`);で既に紹介したが，
        ここでは\codem{let-inline}と定義されるコマンド名\codem{\\enlarge}との間に
        \codem{ctx}なる何かがある．
        実はこれこそがテキスト処理文脈を受け取る “第0引数” の変数だ．
        コマンドの適用が評価されるとき，
        ユーザが与えた通常の引数に加えて，コマンドが使われている箇所のすぐ外側の
        テキスト処理文脈がこの変数\codem{ctx}に渡され，
        コマンドの実装中で使える，というわけである．
        ここまで\pkg{stdjareport}など
        何らかのクラスファイルが提供するマークアップ等の方式に従って
        \SATySFi;を使うにあたってはテキスト処理文脈を全く意識する必要がなかったであろうけれども，
        実のところユーザからは見えない裏側で
        密かに各コマンドがテキスト処理文脈を受け渡ししていたのである．
        なお，\codem{ctx}は単に変数名なので，第0引数に\codem{x}とか\codem{y}とか
        \codem{i-love-satysfi}といった違う名前を使っても構わない\footnote{
          ただし，既存のパッケージでは慣習的に第0引数を必ず\codem{ctx}という変数名にしているので，
          複数人で開発したり，既存パッケージを改造したりする場合は
          \codem{ctx}という変数名で統一した方が理解に齟齬を生じにくいかもしれない．
        }．
      }
      +p{
        さて，続いてコマンド定義の “中身” を見てみる．
        第0引数の\codem{ctx}と（各適用でユーザが与える）第1引数\codem{it}を使うのだが，
        まず\codem{size}に
        外から渡されてきたテキスト処理文脈\codem{ctx}が保持している
        フォントサイズを取り出して束縛する．これはプリミティヴ：

        \val?:(`get-font-size`)({get-font-size})%
          (Type.(context --> length));%

        を用いて行なう．取得したフォントサイズ\codem{size}は\type(Type.(length));型であり，

        \val?:(`*'`)({(\*')})(Type.(length --> (float --> length)));%

        を用いて\codem{size \*' 1.5}で${1.5}倍の長さを得る．
        フォントサイズの設定は

        \val?:(`set-font-size`)({set-font-size})%
          (Type.(length --> (context --> context)));%

        を用いて行なう．
        すなわち，古いテキスト処理文脈\codem{ctx}と設定するフォントサイズ\codem{size}に対して
        \codem{set-font-size size ctx}で
        フォントサイズの更新された新しいテキスト処理文脈が返ってくる．
        \codem{\\enlarge}の実装では，この新しいテキスト処理文脈を
        変数\codem{ctx-enlarge}に束縛している．
        なお，ここの一連の処理で
        \codem{ctx}の内容が “書き換えられる” わけではないことに注意されたい．
        単に\codem{ctx}の内容のうちフォントサイズに関するデータだけが
        \codem{size}に変更された新しいテキスト処理文脈がつくられて
        \codem{ctx-enlarge}という変数に束縛されているだけである．
        実際，\codem{ctx-enlarge}が束縛されたスコープでも
        依然として\codem{ctx}を使うことができ，
        かつそのテキスト処理文脈には元々のフォントサイズが保持されている．
      }
      +p{
        最も重要なのは最終行だ．ここで使われているプリミティヴ

        \val?:(`read-inline`)({read-inline})%
          (Type.(context --> (inline-text --> inline-boxes)));%

        は\ref-chapter(`overall-structure`);で説明した
        インライン変換器に相当し，\ref-figure(`conversion-to-inline-boxes`);
        に示されたような処理をしている．すなわち，
        \codem{read-inline \meta{ctx} \meta{it}}で
        テキスト処理文脈\codem{\meta{ctx}}の保持するフォントや
        文字サイズなどの情報をもとにインラインテキスト\codem{\meta{it}}を
        インラインボックス列へと変換する．
        そしてこれがきわめて重要な事項なのだが，
        インラインテキスト\codem{\meta{it}}に含まれている
        インラインコマンドの適用が評価されるのも，
        この\codem{read-inline}によるインラインボックス列への変換の最中である．
        このとき，\codem{read-inline}に第1引数として渡したテキスト処理文脈が，
        第2引数の\codem{\meta{it}}中の各コマンド適用を評価するときに
        第0引数として渡されるのである．
      }
    >
    +p{
      \REMAINS{コマンドが処理されるアニメーション}
    }
    +p{
      \REMAINS{let-inlineによるエイリアス定義は糖衣構文}
    }
    +p{
      \REMAINS{発展的なコマンド定義：line-break}
    }
  >
  +chapter?:(`line-breaking`){行分割処理}< #line-breaking; >
  +chapter?:(`typography`){文字組版}<
    +p{
      文字は組版処理の主役であり，そして最も人間くささゆえの複雑性を備えた組版処理対象だ．
    }
    +p{ \REMAINS{} }
  >
  +chapter?:(`graphics`){グラフィックス}< #graphics; >
  +chapter?:(`math`){数式組版}<
    +p{
      主に理工系の文書をしたためる者にとって，
      数式組版機能は水や空気のように当然のものとして組版処理システムに備わっていてほしいものだ．
      \TeX;/\LaTeX;が30年の長きに亘って使われ続けてきた大きな要因のひとつが，
      誰もが納得するような品質の数式組版機能を古くから提供している
      数少ない組版処理システムだったからであることにおそらく異論はないだろう．
    }
    +p{
      \SATySFi;も，\TeX;/\LaTeX;に肩を並べられるくらいの品質の数式組版機能を提供している．
      しかも，既に\ref-chapter(`getting-started`);で見たように，
      \LaTeX;そっくりの構文で書くことができる．
      数式を多大に含む文書を執筆したいという動機で既に盛んに\LaTeX;に触れていた人にとって，
      少なくとも数式の記法が\SATySFi;への移行に関する心理的障壁となることはまずないだろう．
      本章では，\SATySFi;に備わっている数式組版機能について，詳細を追って見ていくことにしよう．
    }
    +p{
      なお，繰り返しになるが，\SATySFi;での数式の記述はコードの見た目上\LaTeX;にそっくりなものの，
      裏でやっていることは両者で全然違う．
      \LaTeX;は字句解析（トークン化）に相当する処理を組版処理と同時進行で行ない，
      かつ構文木も一切構築せずパターンマッチでトークン列を書き換えていくのに対し，
      \SATySFi;は静的に構文解析して数式を構文木の形で保持している．
    }
    +p{ \REMAINS{} }
  >
  +chapter?:(`cross-reference`){相互参照}< #cross-reference; >
  +chapter?:(`page-breaking`){ページ分割処理}<
    +p{ \REMAINS{} }
  >
  +chapter?:(`primitives`){ファイル分割とモジュール}<
    +p{ \REMAINS{} }
  >
  +chapter?:(`future-work`){Future Work}<
    +p{
      \SATySFi;は現時点でも充分実用に耐える程度に機能を備えているが，
      今後さらに拡張していきたいと考えている点がいくつもある．
      本章ではこれについて簡潔に述べることとしよう．
      端的に言ってしまえば開発に協力してくださるかもしれない方への喧伝である．
    }
    +section{機能の拡張}<
      +subsection?:(`text-mode`){テキストモード}<
        +p{ \REMAINS{} }
      >
      +subsection{文字組版機能の拡張}<
        +p{ \REMAINS{縦書き，LTR/RTL，2段組み} }
        +p{ \REMAINS{OpenTypeフィーチャのON/OFF機能} }
        +p{ \REMAINS{合字やカーニング処理の言語ごとの切り替え} }
        +p{ \REMAINS{widow, orphan} }
        +p{ \REMAINS{数式のalignment tab} }
        +p{ \REMAINS{ページ分割できる表組版} }
        +p{ \REMAINS{行長が変わる段落} }
      >
      +subsection{言語機能の拡張}<
        +p{ \REMAINS{シグネチャ，多重モジュール} }
        +p{ \REMAINS{ファンクタか型クラス} }
        +p{ \REMAINS{パッケージマネージャ} }
        +p{ \REMAINS{レコードに関する型システムの拡張} }
        +p{ \REMAINS{末尾再帰最適化} }
      >
      +p{ \REMAINS{CFF系フォントの部分埋め込み} }
      +p{ \REMAINS{画像読み込みのGIF，PNG等対応} }
      +p{ \REMAINS{タグつきPDFの出力} }
      +p{ \REMAINS{相対パスの扱い，プリプロセッサ} }
      +p{ \REMAINS{文脈のエントリーの拡張機能} }
    >
    +section{既存機能の破壊的な変更}<
      +p{ \REMAINS{フォント読み込みの機構} }
      +p{ \REMAINS{line-breakのインターフェイス変更} }
      +p{ \REMAINS{graphicとgraphic list} }
    >
  >
  +chapter?:(`specification`){言語仕様}<
    +p{
      この章は，対象をより細かい粒度で理解しようとせずにはいられない，物好きな読者向けに用意した．
      全貌を形式的に記述するには\SATySFi;は大きすぎるので，
      根幹となる部分だけを抜き出したサブセットをいくつか定義し，
      それについて操作的意味論や型システムをフォーマルに記述することを試みた．
    }
    +section{テキストの扱いの形式的記述}<
      +subsection{構文}<
        +p{
          この節では，\SATySFi;に於ける
          テキストやボックス列の扱いを形式的に記述した，
          ごく小さなサブセットの言語を与える．
          項 ${\term!(Term.tme)}，値 ${\term!(Term.tmv)}，
          インラインテキスト要素 ${\term!(Term.tmit)}，
          ブロックテキスト要素 ${\term!(Term.tmbt)}
          は以下のBNFでそれぞれ定義される：

          \BNFs(Term.([
            (show tme, [
              List.map show [
                tmv; !vx; app tme tme; let-in vx tme (Some(tme));
                readI tme tme; readB tme tme;
              ];
            ]);
            (show tmv, [
              List.map show [
                tmc; lam vx tme; lamI vx tme; lamB vx tme;
                tmctx; textI (star tmit); textB (star tmbt);
                boxI (star tmib); boxB (star tmbb);
              ];
            ]);
            (show tmit, [
              List.map show [
                tmchar;
                app tme (star tme);
              ];
            ]);
            (show tmbt, [
              List.map show [
                app tme (star tme);
              ]
            ]);
          ]));%

          ここで
          メタな記法 ${\term!(Term.(star !${M}))} は
          ${0} 回以上の有限個の ${M} の連接を表し，
          ${\term!(Term.(!vx))} は変数を，
          ${\term!(Term.tmc)} は定数やプリミティヴを，
          ${\term!(Term.tmctx)} はテキスト処理文脈を，
          ${\term!(Term.tmchar)} はUnicodeコードポイントなどテキストの要素としての文字を
          それぞれ動くとする．
          ${\term!(Term.tmib)}は形式的には定義を与えないが，インラインボックス列の要素，すなわち
          どんなサイズのどんなフォントで組まれるかといった情報を含む
          “既に組めるようになっているテキスト” の要素にあたる．イメージとしては
          \as-latin-word{\BoxGraphics.roman{|i|n|l|i|n|e|}}の
          \as-latin-word{\BoxGraphics.roman{|i|}}とか
          \as-latin-word{\BoxGraphics.roman{|n|}}などひとつひとつが
          ${\term!(Term.tmib)} に該当する\footnote{
            実際にはカーニングや合字の処理，さらにはハイフネーション辞書に基づく
            ソフトハイフンの挿入などの処理があるため，“1文字1文字を別個に
            インラインテキストからインラインボックス列に変換している” わけではないが，
            ひとまずの近似的な理解としてはこれで十分である．
          }．
          ${\term!(Term.tmbb)} も同様に，形式的定義は与えないが
          “すでに組版処理をするための情報がすべて入っている，段落中の1行を表すデータ”
          におおよそ相当する．
        }
        +p{
          インラインテキスト要素およびブロックテキスト要素の
          ${\term!(Term.(appseq (tmesub ${0})
              [tmesub ${1}; !${\cdots}; tmesub ${n}]))}
          はコマンドの適用である．
          実際の\SATySFi;ではコマンドにあたる ${\term!(Term.(tmesub ${0}))} の部分は
          簡単のためコマンド名しか構文的に受けつけないようになっているが，
          ここでは定式化の都合上一般の項が書けるものとする．

          ${\term!(Term.(paren (readI (tmesub ${1}) (tmesub ${2}))))} は
          \codem{read-inline \metasub(${1}){e} \metasub(${2}){e}}に相当し，
          同様に
          ${\term!(Term.(paren (readB (tmesub ${1}) (tmesub ${2}))))} も
          \codem{read-block \metasub(${1}){e} \metasub(${2}){e}}に相当する．
          簡単のため部分適用できないようになっているが，

          \display-term(Term.(
            let-in ${r} ?:[vx; vy]
              (readI !vx !vy) None)
          );%

          などと定義して ${r} を使えば部分適用できるので気にしなくてよい\footnote{
            実際のプリミティヴの\codem{read-inline}も，正確にはこの ${r} に対応する．
          }．

          ${\term!(Term.(paren (lamI vx tme)))} は “インラインコマンド抽象” で，
          ${x} はテキスト処理文脈を受け取るための変数である．
          計算上の振舞いは通常のラムダ抽象 ${\term!(Term.(paren (lam vx tme)))} と
          全く同様の直観で理解できるものだが，型つけの都合上区別されている．
          ${\term!(Term.(paren (lamI vx tme)))} 自体を直接書く方法は
          \SATySFi;の処理系からは提供されておらず，
          “インラインコマンド抽象” は
          必ず\codem{let-inline}によってコマンド名に束縛する必要がある\footnote{
            不必要な複雑化を避ける意図がある．
            一応コマンド\codem{\meta{cmd}}に束縛されている
            “インラインコマンド抽象” を
            \codem{(command \meta{cmd})}で取り出すことはできるものの，
            \codem{get-initial-context}や\codem{set-math-command}などの
            プリミティヴに引数として渡す以外の本質的な用途はない．
          }．
          \codem{let-inline}によるコマンド定義の構文：

          \d-codem{
            let-inline \meta{x} \meta{cmd}
              \metasub(${1}){y} ${\cdots} \metasub(${n}){y} = \metasub(${1}){e}
            in \metasub(${2}){e}
          }%

          は以下の糖衣構文である：

          \display-term(Term.(
            let-in ${cmd}
              (lamI vx (lam ${y_1} !${\ldots\ \term!(lam ${y_n} (tmesub ${1}))}))
            (Some(tmesub ${2}))
          ));%

          “ブロックコマンド抽象” についても同様に，

          \d-codem{
            let-block \meta{x} \meta{cmd}
              \metasub(${1}){y} ${\cdots} \metasub(${n}){y} = \metasub(${1}){e}
            in \metasub(${2}){e}
          }%

          は以下の糖衣構文である：

          \display-term(Term.(
            let-in ${cmd}
              (lamB vx (lam ${y_1} !${\ldots\ \term!(lam ${y_n} (tmesub ${1}))}))
            (Some(tmesub ${2}))
          ));%
        }
        +p{
          最初に掲げたBNFを見てもしかすると意外に感じたかもしれないが，
          インラインテキスト ${\term!(Term.(textI tmIt))} と
          ブロックテキスト ${\term!(Term.(textB tmBt))} は
          それ自体（単に項なのではなく）値である．
          すなわち，プログラムの評価中に ${\term!(Term.(textI tmIt))} という形が出てきたら，
          （たとえ中にインラインコマンドが残っている状態でも）
          それ以上評価されずに函数やコマンドに渡されたりする．
          これは\SATySFi;言語を理解する上で非常に重要な点である．
          詳しくは次節の操作的意味論の際に説明する．
        }
      >
      +subsection{操作的意味論}<
        +p{
          操作的意味論はいわゆるbig step semanticsで定式化する．
          まず，項 ${\term!(Term.tme)} が値 ${\term!(Term.tmv)} へと評価されるという
          2項関係 ${\bs!(Term.tme)!(Term.tmv)} は次のように定義される：

          \math-list(Term.(${
            | \derive?:{\text!{(E-Val)}}{||}{\bs!(tmv)!(tmv)}

            | \derive?:{\text!{(E-App)}}{
                | \bs!(tmesub ${1})!(lam vx tme)
                | \bs!(tmesub ${2})!(tmvsub ${2})
                | \bs!(subst (tmvsub ${2}) vx tme)!(tmv)
                |}{\bs!(app (tmesub ${1}) (tmesub ${2}))!(tmv)}

            | \derive?:{\text!{(E-LetIn)}}{
                | \bs!(tmesub ${1})!(tmvsub ${1})
                | \bs!(subst (tmvsub ${1}) vx (tmesub ${2}))!(tmvsub ${2})
                |}{\bs!(let-in vx (tmesub ${1}) (Some(tmesub ${2})))!(tmvsub ${2})}

            | \derive?:{\text!{(E-ReadI)}}{
                | \bs!(tmesub ${1})!(tmctx)
                | \bs!(tmesub ${2})!(textI tmIt)
                | \bsI!(tmctx)!(tmIt)!(tmIb)
                |}{\bs!(readI (tmesub ${1}) (tmesub ${2}))!(boxI tmIb)}

            | \derive?:{\text!{(E-ReadB)}}{
                | \bs!(tmesub ${1})!(tmctx)
                | \bs!(tmesub ${2})!(textB tmBt)
                | \bsB!(tmctx)!(tmBt)!(tmBb)
                |}{\bs!(readB (tmesub ${1}) (tmesub ${2}))!(boxB tmBb)}
            |}));%

          インラインテキストの評価は以下のように定められる．すなわち，
          テキスト処理文脈 ${\term!(Term.tmctx)} の下で
          インラインテキスト ${\term!(Term.tmIt)} が
          インラインボックス列 ${\term!(Term.tmIb)} へ評価されるという
          3項関係 ${\bsI!(Term.tmctx)!(Term.tmIt)!(Term.tmIb)} は
          以下のように定義される：

          \math-list(Term.(${
            | \derive?:{\text!{(EI-Empty)}}{||}{
                \bsI!(tmctx)!(!${\epsilon})!(!${\epsilon})}

            | \derive?:{\text!{(EI-Char)}}{
                | \term!(tmib) \defeq
                     \app{\mathrm{Typeface}}{\term!(tmctx), \term!(tmchar)}
                | \bsI!(tmctx)!(tmIt)!(tmIb)
                |}{
                  \bsI!(tmctx)!(cat tmchar tmIt)!(cat tmib tmIb)
                }

            | \derive?:{\text!{(EI-Command)}}{
                | \bs!(tmesub ${0})!(lamI vx tme)
                | \bs!(appseq (paren (subst tmctx vx tme))
                    [tmesub ${1}; !${\cdots}; tmesub ${n}])!(boxI tmIbp)
                | \bsI!(tmctx)!(tmIt)!(tmIb)
                |}{
                  \bsI!(tmctx)!(cat (paren (appseq (tmesub ${0})
                    [tmesub ${1}; !${\cdots}; tmesub ${n}])) tmIt)!(cat tmIbp tmIb)
                }
            |}));%

          ここで
          ${\app{\mathrm{Typeface}}{\term!(Term.tmctx), \term!(Term.tmchar)}}
          はテキスト処理文脈 ${\term!(Term.tmctx)}（の文字サイズやフォントといった情報）
          に基づいて文字 ${\term!(Term.tmchar)} を “組める状態にしたもの” を表す．

          ブロックテキストについても，テキスト処理文脈 ${\term!(Term.tmctx)} の下で
          ブロックテキスト ${\term!(Term.tmBt)} が
          ブロックボックス列 ${\term!(Term.tmBb)} へ評価されるという3項関係
          ${\bsB!(Term.tmctx)!(Term.tmBt)!(Term.tmBb)} が
          同様に以下のように定義される：

          \math-list(Term.(${
            | \derive?:{\text!{(EB-Empty)}}{||}{
                \bsB!(tmctx)!(!${\epsilon})!(!${\epsilon})}

            | \derive?:{\text!{(EB-Command)}}{
                | \bs!(tmesub ${0})!(lamB vx tme)
                | \bs!(appseq (paren (subst tmctx vx tme))
                    [tmesub ${1}; !${\cdots}; tmesub ${n}])!(boxB tmBbp)
                | \bsB!(tmctx)!(tmBt)!(tmBb)
                |}{
                  \bsB!(tmctx)!(cat (paren (appseq (tmesub ${0})
                    [tmesub ${1}; !${\cdots}; tmesub ${n}])) tmBt)!(cat tmBbp tmBb)
                }
            |}));
        }
        +p{
          注目すべき評価規則は (E-ReadI) だ．
          この規則では，まず第1引数のテキスト処理文脈が評価され，続いて
          第2引数として渡された項 ${\term!(Term.tmesub ${2})} が評価され
          インラインテキスト ${\term!(Term.(textI tmIt))} となる．
          前節で述べたように，一般にこのインラインテキストの中にはコマンドの適用が含まれている．
          これらのコマンド適用の評価を “起動する” のがまさに
          ${\term!(Term.(paren (readI !${\text!{-}} !${\text!{-}})))}
          の仕事なのである．
          (E-ReadB) についても，同様のことが言える．
        }
        +p{
          実際には
          テキスト処理文脈 ${\term!(Term.tmctx)}
          の保持する情報を更新するプリミティヴや，
          テキスト処理文脈と
          ${\term!(Term.(boxI tmIb))} の形の項（つまりインラインボックス列）を受け取って
          適切に行分割し ${\term!(Term.(boxB tmBb))} の形の項（つまりブロックボックス列）
          を返すようなプリミティヴが備わっていて，
          これによって “意味のある” 処理が記述できるわけだが，
          核としては上記のような体系が\SATySFi;の基礎をなしている．
        }
      >
      +subsection{型システム}<
        +p{
          前節で定義した計算体系上に型システムを与える．
          実際の\SATySFi;の型システムはそれなりに巨大で，
          SML\#と同様のレコード \cite[`Ohori1995`];
          やラベルなしのオプション引数を扱えるようになっているが，
          一旦それらを除いて，テキストとボックス列に関わる根幹となる部分だけを
          抜き出して扱うことにする．
          基本型\type(Type.tymb);，
          単相型\type(Type.tymtau);，
          多相型\type(Type.tymsigma);
          は以下のBNFでそれぞれ定義される：

          \BNFs(Type.([
            (show tymb, [
              List.map show [
                context; inline-text; block-text;
                inline-boxes; block-boxes; of-math ${\cdots}
              ]
            ]);
            (show tymtau, [
              List.map show [
                tymalpha; tymb; tymtau --> tymtau;
                cmdI [star tymtau]; cmdB [star tymtau]
              ]
            ]);
            (show tymsigma, [
              List.map show [
                tymtau; forall ${\alpha} tymsigma;
              ]
            ]);
          ]));%

          ただし，\type(Type.tymalpha);は型変数を動くとする．
          型環境 ${\Gamma} の下で ${\term!(Term.tme)} に型\type(Type.tymtau);がつく
          という型判定の3項関係 ${\tj{\Gamma}!(Term.tme)!(Type.tymtau)} は
          以下の規則で与えられる：

          \math-list(Term.(Type.(${
            | \derive?:{\text!{(T-Const)}}{
                | \app{\Delta}{\term!(tmc)} \synteq \mtype!(tymtau)
                |}{\tj{\Gamma}!(tmc)!(tymtau)}

            | \derive?:{\text!{(T-Var)}}{
                | \app{\Gamma}{#vx} \geqslant \mtype!(tymtau)
                |}{\tj{\Gamma}!(!vx)!(tymtau)}

            | \derive?:{\text!{(T-Lam)}}{
                | \tj{
                    \overwrite{\Gamma}{#vx}{\mtype!(tymtaup)}
                  }!(tme)!(tymtau)
                |}{
                  \tj{\Gamma}!(lam vx tme)!(tymtaup --> tymtau)
                }

            | \derive?:{\text!{(T-LetIn)}}{
                | \tj{\Gamma}!(tmesub ${1})!(tymtausub ${1})
                | \tj{
                    \overwrite{\Gamma}{#vx}{
                      \app{\mathrm{Gen}}{\Gamma, \mtype!(tymtausub ${1})}
                    }
                  }!(tmesub ${2})!(tymtausub ${2})
                |}{
                  \tj{\Gamma}!(let-in vx
                    (tmesub ${1}) (Some(tmesub ${2})))!(tymtausub ${2})
                }

            | \derive?:{\text!{(T-App)}}{
                | \tj{\Gamma}!(tmesub ${1})!(tymtaup --> tymtau)
                | \tj{\Gamma}!(tmesub ${2})!(tymtaup)
                |}{\tj{\Gamma}!(app (tmesub ${1}) (tmesub ${2}))!(tymtau)}

            | \derive?:{\text!{(T-Context)}}{||}{
                \tj{\Gamma}!(tmctx)!(context)}

            | \derive?:{\text!{(T-ReadI)}}{
                | \tj{\Gamma}!(tmesub ${1})!(context)
                | \tj{\Gamma}!(tmesub ${2})!(inline-text)
                |}{\tj{\Gamma}!(readI (tmesub ${1}) (tmesub ${2}))!(inline-boxes)}

            | \derive?:{\text!{(T-ReadB)}}{
                | \tj{\Gamma}!(tmesub ${1})!(context)
                | \tj{\Gamma}!(tmesub ${2})!(block-text)
                |}{\tj{\Gamma}!(readB (tmesub ${1}) (tmesub ${2}))!(block-boxes)}

            | \derive?:{\text!{(T-BoxI)}}{||}{
                \tj{\Gamma}!(boxI tmIb)!(inline-boxes)
              }

            | \derive?:{\text!{(T-BoxB)}}{||}{
                \tj{\Gamma}!(boxB tmBb)!(block-boxes)
              }

            | \derive?:{\text!{(T-TextI)}}{
                | \tjI{\Gamma}!(tmIt)
                |}{
                  \tj{\Gamma}!(textI tmIt)!(inline-text)
                }

            | \derive?:{\text!{(T-TextB)}}{
                | \tjB{\Gamma}!(tmBt)
                |}{
                  \tj{\Gamma}!(textB tmBt)!(block-text)
                }

            | \derive?:{\text!{(T-LamI)}}{
                | \tj{
                    \overwrite{\Gamma}{#vx}{\mtype!(context)}
                  }!(tme)!(
                    tymtausub ${1} --> (of-math ${\cdots} -->
                      (tymtausub ${n} --> inline-boxes)))
                |}{
                  \tj{\Gamma}!(lamI vx tme)!(cmdI
                    [tymtausub ${1}; of-math ${\cdots}; tymtausub ${n}])
                }

            | \derive?:{\text!{(T-LamB)}}{
                | \tj{
                    \overwrite{\Gamma}{#vx}{\mtype!(context)}
                  }!(tme)!(
                    tymtausub ${1} --> (of-math ${\cdots} -->
                      (tymtausub ${n} --> block-boxes)))
                |}{
                  \tj{\Gamma}!(lamB vx tme)!(cmdB
                    [tymtausub ${1}; of-math ${\cdots}; tymtausub ${n}])
                }

            |})));%

          ただし ${\Delta} は定数をその型に写す写像，
          ${\mtype!(Type.tymsigma) \geqslant \mtype!(Type.tymtau)} は
          単相型 ${\mtype!(Type.tymtau)} が多相型 ${\mtype!(Type.tymsigma)} の
          インスタンスであること，
          ${\app{\mathrm{Gen}}{\Gamma, \mtype!(Type.tymtau)}} は
          単相型 ${\mtype!(Type.tymtau)} の
          型環境 ${\Gamma} に基づいた閉包である多相型をそれぞれ表す．
          インラインテキストおよびブロックテキストに対する型つけ規則は
          以下で与えられる：

          \math-list(Term.(Type.(${
            | \derive?:{\text!{(TI-Empty)}}{||}{
                \tjI{\Gamma}!(!${\epsilon})}

            | \derive?:{\text!{(TI-Char)}}{
                | \tjI{\Gamma}!(tmIt)
                |}{\tjI{\Gamma}!(cat tmchar tmIt)}

            | \derive?:{\text!{(TB-Empty)}}{||}{
                \tjB{\Gamma}!(!${\epsilon})}

            | \derive-multi?:{\text!{(TI-Command)}}!(7cm){
                | \tj{\Gamma}!(tmesub ${0})!(cmdI
                    [tymtausub ${1}; of-math ${\cdots}; tymtausub ${n}])
                | \tj{\Gamma}!(tmesub ${i})!(tymtausub ${i})
                    \text!{\quad;(for each ${i})}
                | \tjI{\Gamma}!(tmIt)
                |}{\tjI{\Gamma}!(cat (Term.paren (appseq (tmesub ${0})
                    [tmesub ${1}; !${\cdots}; tmesub ${n}])) tmIt)}

            | \derive-multi?:{\text!{(TB-Command)}}!(7cm){
                | \tj{\Gamma}!(tmesub ${0})!(cmdB
                    [tymtausub ${1}; of-math ${\cdots}; tymtausub ${n}])
                | \tj{\Gamma}!(tmesub ${i})!(tymtausub ${i})
                    \text!{\quad;(for each ${i})}
                | \tjB{\Gamma}!(tmBt)
                |}{\tjB{\Gamma}!(cat (Term.paren (appseq (tmesub ${0})
                    [tmesub ${1}; !${\cdots}; tmesub ${n}])) tmBt)}
            |})));%
        }
      >
    >
  >
>
