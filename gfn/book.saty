% -*- coding: utf-8 -*-
@import: settings
@import: preface
@import: introduction
@import: getting-started
@import: alias-command-definition
@import: overall
@import: line-breaking
@import: system-and-config
@import: typography
@import: graphics
@import: cross-reference
@import: page-breaking
@import: future-work
@import: specification
@import: bib

document (|
  title = {The \SATySFi;book};
  author = {T. Suwa};
  preface = preface;
  bibliography = bibliography;
|) '<
  +chapter?:(`introduction`){\SATySFi;の開発動機}< #introduction; >
  +chapter?:(`getting-started`){\SATySFi;簡易入門}< #getting-started; >
  +chapter?:(`basic-command-definition`){コマンド定義：基礎編}<
    +p{
      \ref-chapter(`getting-started`);で\pkg{stdjareport}を用いて
      \SATySFi;の基礎的なコマンドの用法を知った．
      ところで，マークアップ言語の大きな強みのひとつは
      自前でコマンドを定義することによって
      種々の自動処理を実現したり独自の意味マークアップを規定したりできる点にあったはずである．
      実際，\codem{+chapter}とか\codem{+p}とか\codem{\\dfn}とかいった
      コマンドたちは単に\pkg{stdjareport}クラスによって定義が提供されているだけであり，
      その気になればユーザでも同様の定義を書いたりできるはずだ．
      そろそろ自前でコマンドを定義したくてうずうずしている読者も多いかと思う．
      この章では，コマンド定義のごく基礎的な方法を紹介する．
      あらかじめ言ってしまうとここでの説明はとてもアドホックなものになっており，
      \SATySFi;をよく理解されたのちにこの章を読めば
      「こんな子供騙しな説明をしていたのか」と驚かれるかもしれないが，
      読者の様々なバックグラウンドを鑑み，
      まず最初の一歩としておおまかに把握してもらうには良い説明だろうと
      判断してのことなのでご容赦願いたいと思う．
      より深い理解を獲得し，より柔軟で幅広い種類の処理をコマンドとして定義するには，
      \ref-chapter(`overall-structure`);で
      \SATySFi;が行なっている組版処理の全体像を把握した上で
      \ref-chapter(`advanced-command-definition`);に臨んでいただきたい．
    }
    +section{簡単なエイリアス}< #alias-command-definition; >
    +section{プログラミング言語としての\SATySFi;}<
      +p{
        既に述べたように，\SATySFi;はいわゆる函数型らしい特徴を兼ね備えた
        組版処理向けのマークアップ言語である．
        むしろ，より正確を期して言い表すならば
        値呼びの函数型言語の上に組版処理用の種々の言語機能が分厚く搭載された
        DSL（domain-specific language, 領域特化言語）だ．
        プログラミング言語としての\SATySFi;の基礎的部分には
        OCamlに大変よく似た体系が採用されており，
        基礎的部分の理解を得るのに
        \cite[`Igarashi-OCaml`];や\cite[`Asai-OCaml`];
        といったOCamlに関する参考書，
        或いは
        \cite[`Igarashi-Program`];や\cite[`TaPL`];（およびその和訳 \cite[`TaPL-ja`];）
        といった計算機言語や型システムに関する基礎理論を扱った理工書で代用することも十分可能なほどである．
        とはいえ，OCamlなどの他言語から回り道せずとも\SATySFi;での最低限の直観を身につければ
        十分\SATySFi;でのプログラミングが可能であり，
        熱心に函数型プログラミングの基礎を習得したい読者ばかりではないであろうから，
        ここでも簡単にプログラミング言語としての\SATySFi;について解説する．
        また，OCamlと\SATySFi;との間には目的意識や美意識の違いに起因した多少の差異があるので，
        これについて（既にOCamlで流暢にプログラミングできる読者に対しても）
        \ref-subsection(`diff-from-ocaml`);で簡単に補足する．
      }
      +subsection{式と値}<
        +p{
          \SATySFi;には対話環境が特に整備されていないので，
          プログラムの計算結果をPDFに出力して確かめることにしよう．
          ひとまず以下のようなコードを見てほしい：

          \d-code(```
            @require: stdjareport

            let-inline \show-int n = embed-string (arabic n)
            let-inline \show-float x = embed-string (show-float x)
            let-inline \show-string s = embed-string s
            in

            document (|
              title = {Programming in \SATySFi;};
              author = {計 算太郎};
            |) '<
              +p{ Answer: \show-int(40 + 2); }
            >
          ```);%

          \codem{let-inline}から始まる，
          未知でありながら前節で見たインラインコマンドを定義する方法によく似た構文が3つ連なっているが，
          実際これはそれぞれ
          \codem{\\show-int}，\codem{\\show-float}，\codem{\\show-string}
          というインラインコマンドの定義である．
          この定義をどう読むのかは後々わかることになるので，
          今の段階ではそれぞれ
          「与えられた
          \meta-or{|整数|浮動小数点数|文字列|}
          を版面に（数値の場合十進法で）出力するコマンド」
          を定義するオマジナイだと思っていただきたい．
          注目されたいのは\codem{\\show-int}を使う部分，すなわち

          \d-code(```
            ​  +p{ Answer: \show-int(40 + 2); }
          ```);%

          である．丸括弧に囲まれた\codem{40 + 2}という怪しげな記述がある．
          とりあえず，この文書を\SATySFi;処理系にかけてみると，
          この段落に相当する部分は

          \d-block(open Sample in '<
            +p{ Answer: \show-int(40 + 2); }
          >);%

          と出力される．そう，${40} と ${2} の和が計算されているのである．
          平たく言えば，こういった “計算をする処理” がプログラムの仕事の根幹であり，
          “計算をする処理” をプログラムとして記述することをプログラミングと呼ぶ．
          \codem{40 + 2}のような記述は
          \dfnje{\index(`シキ`){式}}{expression}
          またはしばしば
          \dfnje{\index(`コウ`){項}}{term}と呼ばれ，
          式を適切な構文にしたがって組み立てることでプログラムが構築される\footnote{
            C言語やPythonなどの
            “手続き的な” 観点に強く基づいている計算機言語に馴染みのある読者は
            「式から文をつくり，文からプログラムを構築するのではないか？」
            と思われるかもしれないが，
            \SATySFi;に文の概念はない．
            というか，式の特殊な場合が “手続き的な” 言語に備わっている文に相当するのである．
            これはOCamlをはじめとする多くのいわゆる函数型言語に共通する性質である．
          }．
        }
        +p{
          \codem{40 + 2}の “計算が進んで” \codem{42}になったように，
          式は一般に “それ以上計算しない式” へと “うつりかわっていく”．
          この “うつりかわり” の過程を
          \dfnje{\index(`ヒョウカ`){評価}}{evaluation}
          またはしばしば
          \dfnje{\index(`カンヤク`){簡約}}{reduction}
          と呼び， “それ以上計算しない式” を
          \dfnje{\index(`コウブンテキアタイ`){構文的値}}{syntactic value}
          或いは単に
          \dfnje{\index(`アタイ`){値}}{value}
          と呼ぶ．
          プログラムの動作とは，式を評価して値を求めることなのである．
        }
        +p{
          もう少し複雑な計算をしてみよう．

          \d-code-and-block(```
            +p{ Answer: \show-int(1 + 2 * 3 - 4); }
          ```)(open Sample in '<
            +p{ Answer: \show-int(1 + 2 * 3 - 4); }
          >);%

          \codem{\*}は乗算のための2項演算子である．
          通常我々が「${1 + 2 \times 3 - 4}」と書いた時には
          ${\paren{1 + \paren{2 \times 3}} - 4} と扱われるのと同様に，
          \SATySFi;言語でも2項演算子の結合には優先順位がある．
          やはり日常的な数式と同様に，括弧で囲うと優先順位を指示できる：

          \d-code-and-block(```
            +p{ Answer: \show-int((1 + 2) * 3 - 4); }
          ```)(open Sample in '<
            +p{ Answer: \show-int((1 + 2) * 3 - 4); }
          >);%

          なお，\SATySFi;での整数は
          64bit環境であれば63bit符号つき整数，
          32bit環境であれば31bit符号つき整数である\footnote{
            この仕様は\SATySFi;の処理系の実装に使われているOCamlの
            \code(`int`);型の仕様に起因する．
          }．
        }
      >
      +subsection?:(`variables`){変数とその束縛}<
        +p{
          ただ単に整数の計算をするだけでは電卓を叩いているのと大して違いはないから，
          もう少し “プログラミングらしいこと” に踏み込もう．
          すなわち，\dfnje{変数}{variable}の使用である．
          変数は，\dfnje{変数名}{variable name}によって識別され，
          何らかの値を\dfnje{束縛する}{bind}ことのできる機構だ．
          変数名として使えるのは，

          \listing{
            * 1文字目はラテン小文字（\codem{a}–\codem{z}）

            * 2文字目以降は大小ラテン文字（\codem{a}–\codem{z}，\codem{A}–\codem{Z}），
              数字（\codem{0}–\codem{9}），
              またはハイフン（\codem{-}）
          }%

          を満たす，長さが1文字以上のコード中の文字列である．
          ただし，これに該当する文字列のうち
          以下に列挙した39種類は\dfnje{予約語}{reserved word}と呼ばれ，
          構文を示すなどの特別な用途で用いられることが定められたトークンなので，
          変数名には使えない\footnote{
            \codem{controls}と\codem{cycle}は今では特に使われないのだが，
            かつてグラフィックスに用いられていたTikZ風の構文の名残として予約語のままになっている．
          }：

          \tokens{
            |and|as
            |before|block-cmd
            |command|constraint|controls|cycle
            |do|direct
            |else|end
            |false|fun
            |if|in|inline-cmd
            |let|let-block|let-inline|let-math|let-mutable|let-rec
            |match|math-cmd|mod|module
            |not
            |of|open
            |sig|struct
            |then|true|type
            |val
            |when|while|with
            |}

          変数名に関して少しだけ注意を喚起しておくと，
          “整数を格納した変数\codem{x}から1引く式” を意図して
          \codem{x-1}と書くと，意図とは異なる結果になる．
          というのも，これは\codem{x-1}全体でひとつの変数名とみなされてしまうためだ\footnote{
            このような記述をすると，多くの場合は型検査器が
            「\codem{x-1}という未定義の変数が使われている」
            というエラーを出すが，
            \codem{x-1}という名前の変数が整数を格納する変数として
            本当に使われている場合はとても厄介で，発見困難なバグの原因になるだろう．
          }．回避策として，
          2項演算子を使うときには\codem{x - 1}のように
          必ず前後に空白文字をひとつずつ入れることを習慣づけるとよいだろう．
          前後に空白文字を入れていないことによりトークンの切り分け方が意図とは異なる結果になることは
          \codem{-}以外にも多くのパターンがあるので，
          2項演算子を式と式の間に中置して使うときには前後に空白文字を入れることを強く推奨する．
        }
        +p{
          さて，肝腎の変数への値の束縛は

          \d-codem{
            let \meta{x} = \metasub(${1}){expr} in \metasub(${2}){expr}
          }%

          という形をもつ\dfnje{let式}{let-expression}で行なう\footnote{
            ここにイタリック体で
            \codem{\meta{x}}とか\codem{\metasub(${1}){expr}}などと書いたのは
            “メタ文字” であり，
            実際にコード中に\codem{x}とか\codem{expr1}といった文字列を書いているわけではなく，
            適宜あてはめるべきものに読み替えよ，ということを指す記述である．
            以降もこの “メタ文字” は頻繁に登場するので是非慣れて頂きたい．
          }．
          \codem{\meta{x}}が束縛される変数名であり，
          \codem{\metasub(${1}){expr}}および
          \codem{\metasub(${2}){expr}}は式である．
          このlet式は，\codem{\metasub(${1}){expr}}を評価した結果の値を
          変数\codem{\meta{x}}に束縛し，
          そして\codem{\metasub(${2}){expr}}を評価するのに使う．
          要するに，\codem{\metasub(${2}){expr}}中では
          変数\codem{\meta{x}}が
          \codem{\metasub(${1}){expr}}を評価した結果の値として使えるのである．
          実際に使ってみよう：

          \d-code-and-block(```
            +p{ Answer:
              \show-int(
                let n = (1 + 2) * 3 - 4 in
                  n * n * n
              );
            }
          ```)(open Sample in '<
            +p{
              Answer:
              \show-int(
                let n = (1 + 2) * 3 - 4 in
                  n * n * n
              );
            }
          >);%

          あまりにも大したことのない例だが，期待どおり計算できていることがわかる．
        }
        +p{
          ここですでにC言語やPythonなどの “手続き的な” 言語に慣れ親しんでいる人は
          特によく注意されたいのだが，束縛は「代入」とは似て非なる概念である．
          \SATySFi;に於ける変数は
          （OCamlなどその他のいわゆる函数型言語の変数にも共通するのだが）
          “値を入れておき，適宜変更できる箱” ではない．
          むしろ，“値に別名をつけたもの” という直観の方が正確である．
        }
      >
      +subsection{基本的なデータ}<
        +p{
          \SATySFi;で扱えるデータは勿論整数だけではない．
          浮動小数点数，文字列，真偽値，さらには
          組版指定のための\dfnje{長さ}{length}の値などが扱える．
          長さについては\ref-subsection(`length`);で，
          真偽値は\ref-subsection(`conditionals`);で
          条件分岐とともに解説するので，
          ここではひとまず浮動小数点数と文字列について紹介する．
        }
        +p{
          まずは小数などの値を扱うためのデータ，
          \dfnje{浮動小数点数}{floating-point number}である．
          \SATySFi;での浮動小数点数の扱いは
          \dfn{IEEE754} \cite[`IEEE754`];に準拠するものとする．
          また，先走って型について述べておくと，
          浮動小数点数は\type(Type.float);型をつけて扱われる．
          浮動小数点数の値をPDFに出力して確認するために，
          最初に掲げたテンプレートの段落の部分を
          以下のように\codem{\\show-float}に変更しよう：

          \d-code(```
              +p{ Answer: \show-float(42.195); }
          ```);%

          整数の\codem{\\show-int}のときと同様に，
          上の\codem{42.195}と書いてあるところを変えて遊んでみる．
          浮動小数点数のリテラルは単純に\codem{42.195}とか\codem{3.14}などと書く．
          現在のところ「\code(`1e-5`);」のような指数表記は用意していない．
          小数部分が\codem{.0}の場合は\codem{5.0}を省略して\codem{5.}といった具合に書けるが，
          整数部分が\codem{0.}の場合は\codem{.5}といった具合には省略できない．
          浮動小数点数も整数と同様に加減乗除などの計算ができるが，
          演算子は\codem{+}や\codem{\*}ではなく，
          かわりに\codem{+.}や\codem{\*.}を使う：

          \d-code-and-block(```
            +p{ Answer: \show-float((1.1 +. 0.7) *. 2.4); }
          ```)(open Sample in '<
            +p{ Answer: \show-float((1.1 +. 0.7) *. 2.4); }
          >);%

          整数値と浮動小数点数との演算は，直接はできない．
          型については後述するが，\codem{1 +. 2.0}のような記述は型エラーとなる．
          評価されて整数値になる式\codem{\meta{expr}}
          を浮動小数点数に関する計算に用いたい場合は
          \codem{float \meta{expr}}で浮動小数点数に変換する：

          \d-code-and-block(```
            +p{ Answer: \show-float((float (1 + 2 * 3 - 4)) *. 2.4); }
          ```)(open Sample in '<
            +p{ Answer: \show-float((float (1 + 2 * 3 - 4)) *. 2.4); }
          >);%

          \codem{float}とそれに伴う式との結合は2項演算子より強いので，
          \codem{float 1 + 2 \* 3 - 4}と書くと
          \codem{(float 1) + 2 \* 3 - 4}と等価な式として解釈されてしまうことに注意．
          反対に，浮動小数点数へと評価される式\codem{\meta{expr}}を
          小数部分を切り捨てて整数値として使いたい場合は
          \codem{(round \meta{expr})}という形で書く：

          \d-code-and-block(```
            +p{ Answer: \show-int((round ((1.1 +. 0.7) *. 2.4)) * 2); }
          ```)(open Sample in '<
            +p{ Answer: \show-int((round ((1.1 +. 0.7) *. 2.4)) * 2); }
          >);%

          ただし，\codem{(round \meta{expr})}は
          \codem{\meta{expr}}の評価結果の浮動小数点数が
          正負無限，NaN，または小数部分を切り捨てた整数が
          \type(Type.int);型に収まらない場合の動作は未定義である．
          なお，ここで用いた\codem{float}および\codem{round}は
          実は\dfnje{函数}{function}と呼ばれるものであり，
          後の\ref-subsection(`functions`);で
          これらについてより一般性の高い説明を与える．
        }
        +p{
          続いては文字列である．文字列の “計算結果” を実際にPDFに出力するため，
          やはり最初に掲げたテンプレートの段落の部分を\codem{\\show-string}に変えて使おう：

          \d-code(```
              +p{ Answer: [\show-string(`this is a string`);] }
          ```);%

          この\codem{\`this is a string\`}の部分を色々変えて遊ぶのである．
          \codem{\\show-string( ${\cdots} )\;}のさらに外側が
          \codem{\[}と\codem{\]}で囲まれているが，
          これは単にインラインテキストの一部として書かれた四角括弧の文字で，
          \codem{\\show-string}によって表示される文字列の
          端がどこなのかを見やすくするためにつけているだけである．
          要するに表示させたい文字列値のいずれか一方の端が空白文字であるとき，
          本当にその端に空白文字が入っているかを確認する目的でつけている．
        }
        +p{
          さて，先走って登場してしまったが，\SATySFi;での文字列リテラルは
          両端をバッククォート（\codem{\`}）で囲って記述する．
          多くのプログラミング言語では文字列内容を二重引用符で囲い，
          キャリッジリターンや二重引用符などいくつかの特殊文字は
          バックスラッシュでエスケープして書くような方式が採られるが，
          \SATySFi;にはそのような文字列リテラルの記法はなく，
          代わりに一切エスケープの要らない
          バッククォートによるリテラルだけが備わっている．
          一切エスケープが要らないといっても，
          「\code(``foo`bar``);」のように
          バッククォートを文字列内容に含めたい場合はどうすればよいのだろう？\quad;
          これはMarkdownを書いた経験があれば想像しやすいが，
          バッククォートが内容に現れる場合は
          両端のバッククォートを2個ずつにするのである．
          これにより文字列内容の終端がどこであるかがわかる．
          試しにテンプレートの段落部分を

          \d-code(```
            +p{ Answer: [\show-string(``foo`bar``);] }
          ```);%

          にしてみると，結果は以下のようになる：

          \d-block(open Sample in '<
            +p{ Answer: [\show-string(``foo`bar``);] }
          >);%

          一般化して言うと，
          文字列内容として ${n} 個隣接したバッククォートを含めたいとき，
          左右で同数の ${\paren{n + 1}} 個以上の
          連続したバッククォートで両端を囲めばよい．
        }
        +p{
          ここで，良い意味で性格の悪い読者は
          コーナーケースに気づいたかもしれない：\quad;
          文字列内容の（少なくとも一方の）
          端にバッククォートがくる場合はどうすればよいのだろう？\quad;
          これは簡単で，文字列内容の端がバッククォートの場合は，
          文字列を括るためのバッククォートの連続と文字列内容の端のバッククォートとの間に
          空白文字を挿入するとよい．
          バッククォートで括られた内容は，
          両末端の空白文字の ${0} 個以上を除去して文字列内容にするのである：

          \d-code-and-block(```
            +p{ Answer: [\show-string(`` `bar``);] }
          ```)(open Sample in '<
            +p{ Answer: [\show-string(`` `bar``);] }
          >);%

          たしかに空白文字が除去され，左端がバッククォートになっていることがわかる．
          さて，読者が次に思うことはもう私にはよくわかっている：\quad;
          文字列内容の（いずれかの）末端を本当に空白文字にしたい場合はどうすればいいのだろう？\quad;
          この疑問にもしっかり答えられるので安心してほしい．
          もし左端の空白文字の ${0} 個以上の連続を無視させたくないのであれば，
          文字列の括る左側のバッククォートを\codem{\`}ではなく\codem{\#\`}にするのである．
          バッククォートが2個以上の場合も同様に\codem{\#\`\`}の要領で\codem{\#}を左につける．
          右端の空白文字の ${0} 個以上の連続を無視させたくない場合も同様に
          文字列を括る右側を\codem{\`}ではなく\codem{\`\#}とする．
          バッククォートが2個以上の場合も同様である：

          \d-code-and-block(```
            +p{ Answer: [\show-string(#`` `bar``);] }
          ```)(open Sample in '<
            +p{ Answer: [\show-string(#`` `bar``);] }
          >);%

          たしかに空白文字が残っている．これでようやく安心して文字列リテラルが使える．
        }
        +p{
          文字列リテラルが書けるようになったところで，文字列を構築する方法を伝授しよう．
          文字列の結合は2項演算子\codem{^}でできるほか，
          整数値に評価される式\codem{\meta{expr}}に対し，
          \codem{(arabic \meta{expr})}で整数値を十進法文字列にすることができる：

          \d-code-and-block(```
            +p{ Answer: [\show-string(
              `The result is `# ^ (arabic ((1 + 2) * 3 - 4)) ^ `!`
            );] }
          ```)(open Sample in '<
            +p{ Answer: [\show-string(
              `The result is `# ^ (arabic ((1 + 2) * 3 - 4)) ^ `!`
            );] }
          >);%

          ここで使った\codem{arabic}はやはり函数であり，これに関しては
          \ref-subsection(`functions`);でしっかりと扱う．
        }
        +p{
          なお，インラインテキスト\codem{\{ ${\cdots} \}}と
          文字列は異なる概念であることに注意されたい．
          前者はコマンドなどを内容に含んでいるが，
          後者は純粋にUnicodeコードポイント列である．
          ただし，文字列を
          （等価なテキストで構成された，コマンドを含まない）インラインテキストへと変換することは
          \codem{embed-string}という函数で行える．
          これについても\ref-subsection(`functions`);で扱う．
        }
      >
      +subsection{型システムの基礎}<
        +p{
          ところで，“文字列を整数値に足そうとする” とどうなるだろうか？\quad;
          結論から言うと，そのような計算は意味をなさず，
          しかも型検査器に弾かれて “計算を試みることさえさせてもらえない”．
          整数の計算に使った\codem{\\show-int}を含む最初のテンプレートで，
          試しに以下のように記述して処理してみよう：

          \d-code(```
            +p{ Answer: [\show-int(
              42 + `added string`
            );] }
          ```);%

          次のようなエラーが出るはずである：

          \console(```
            ! [Type Error] at "test.saty", line 12, characters 9-23:
                this expression has type
                  string,
                but is expected of type
                  int.
          ```);%

          ファイル名\code(`test.saty`);や行数などは実際にどう記述したかで変わるのだが，
          どうであれ実際に\codem{\`added string\`}が書かれている位置を指しているはずだ．
          上記のエラーは\SATySFi;の型検査器が出した\dfnje{型エラー}{type error}であり，
          その意味するところは（ほぼ直訳だが）
          「\codem{\`added string\`}という式は\type(Type.string);型の式だが，
          ここには\type(Type.int);型の式が書かれることが期待されている」だ．
          ここでようやく\SATySFi;の特徴たる\dfnje{型}{type}の登場となる\footnote{
            といっても，プログラミング言語のもつ特徴としては型はごく一般的な概念である．
            型システムを有していることではなく，
            型システムを組版処理を行なう処理系に持ち込んだことが
            \SATySFi;の顕著な特徴なのである．
          }．
          一旦上のような具体的な型エラーを離れ，型についての一般論の時間にしよう．
          型とは，非常に大雑把に言えば “値の種類による分類”，さらには
          “評価した結果どんな種類の値になることが事前にわかっているかに基づく式の分類”
          である．ここで “事前に” と言っているところが非常に重要だ．
          要するに，“計算を実際に行なわなくともどんな種類の値が結果として出てくるのかが
          式の字面\footnote{より正確には抽象構文木である．}だけからわかる”
          ような仕組みが型によって確立されているということであり，
          この仕組みが\dfnje{型システム}{type system}と呼ばれるものだ．
          型システムを反映して与えられたプログラムが整合しているかどうかを判定する機構が
          型検査器であり，この “整合しているかの検査” は
          プログラムをなす各部分の式に型がつくかどうかを判定することで行なわれる．
        }
        +p{
          式に型をつけることの直観は単純である．
          まず，整数値の型として（上の型エラーにも出てきたように）
          \type(Type.int);型が用意されている．
          最初から値であるような\codem{1}とか\codem{2}とか\codem{500000000}といった
          整数リテラルの式は単純にそのまま\type(Type.int);型がつけられる．
          重要なのは，まだ値でない，評価すると “何かしら計算が進む” 式の型つけだ．
          例えば，加算の式\codem{\metasub(${1}){expr} + \metasub(${2}){expr}}は
          どのように型で扱うかというと，
          「\codem{\metasub(${1}){expr} + \metasub(${2}){expr}}に何らかの型がつくなら
          それは\type(Type.int);型であり，そのためには
          \codem{\metasub(${1}){expr}}と
          \codem{\metasub(${2}){expr}}にそれぞれ\type(Type.int);型がつかねばならない」
          という規則が設けられているのである．
          これが型システムという仕組みの大枠だ．
          本当はもう少し一般性の高い仕組みなのだが，それは次節での函数の型つけの説明に譲る．
        }
        +p{
          さて，上で出た型エラーの話に戻る．
          このエラーの要因は，要するに
          \codem{\metasub(${1}){expr} + \metasub(${2}){expr}}という形の式に型をつけるには
          上記の説明どおり\codem{\metasub(${1}){expr}}と
          \codem{\metasub(${2}){expr}}のそれぞれに
          \type(Type.int);型がつくことが要請されるのだが，
          ここでは\codem{\metasub(${2}){expr}}が\codem{\`added string\`}という
          文字列リテラルであり，
          これは（\type(Type.string);型はつくが）
          \type(Type.int);型がつかないと定められている．
          したがって元の加算の式全体には型がつかないことになり，型検査で弾かれるのである．
        }
      >
      +subsection?:(`length`){長さ}<
        +p{
          型システムの基礎を把握してもらったところで，
          基礎的なデータのひとつである\dfnje{長さ}{length}と
          その型である\type(Type.length);型を紹介しよう．
          これはおそらく汎用のプログラミング言語には
          それ以上分解できない機能として搭載されているのをまず見ない
          データだろう．
          長さの値は振舞いの上ではほぼ浮動小数点数のようなものではある\footnote{
            現状，長さに関する演算がどのように振舞うかは厳密には規定しない．
            厳密に規定しなければどのように行分割されるかが “処理系依存” になってしまうので
            将来的には規定した方が望ましいのであろうが，
            今のところ公開されている\SATySFi;の処理系は
            著者が実装した1つ（およびそれを他者がforkし長さの扱いに関係しない箇所を改変したもの）
            しかないと思われるのでひとまず気にしなくてよい．
            なお．現在の処理系の実装では（後述する）DTPポイント単位の
            浮動小数点数で内部的に表現されている．
          }が，
          “長さ同士を乗算したものを長さとして使う” といった
          “意味をなさない計算” が安易にはできないように，
          つまりそういった計算をしようとする記述が型検査を通らないように，
          浮動小数点数とは型の上で区別されている．
          長さの定数リテラルは，\codem{2.5cm}とか\codem{-1inch}といった，
          次に該当する構文で書く：

          \d-codem{
            \meta-or{|-||}\meta-or{|〈非負で数値の浮動小数点数〉|〈非負整数〉|}〈単位〉
          }%

          ただし，\codem{〈単位〉}の部分は変数名と同一の規則の文字列である．
          これ全体が長さの定数リテラルをなす1トークンであり，
          負の符号と数値部分の間や数値部分と単位の間に空白文字を入れたりしてはいけない．
          具体的な単位については，あらかじめ定義された以下の
          （“状況” に依存しない，絶対的な）単位のみが使える：

          \listing{
            * \codem{mm}：\quad;
              ミリメートル

            * \codem{cm}：\quad;
              センチメートル

            * \codem{inch}：\quad;
              \dfnje{国際インチ}{international inch}（${1\math-unit!{inch}}を
              厳密に${2.54\math-unit!{cm}}と定めた単位）

            * \codem{pt}：\quad;
              \dfnje{DTPポイント}{DTP point}（${1\math-unit!{pt}}を
              厳密に${\paren{1/72}\math-unit!{inch}}と定めた単位）
          }%

          emやexなどといった，“現在の文字サイズ” に依存する
          相対的な長さの単位は使えないことに注意されたい．
          勿論実質的にem単位で長さを指定する方法は存在し，
          それについては後々わかることになる\footnote{
            大幅に先走って述べておくと，そのような処理は
            \codem{get-font-size}というプリミティヴを用いて実現する．
          }．
          さらに引っかかりやすいポイントは，ポイントという単位の定義だ．
          “point” と呼ばれる単位には歴史的に様々な定義が与えられてきた：

          \listing{
            * \dfnje{Didotポイント}{Dodot point}：\quad;


            * アメリカンポイント（1886年）：\quad;
              インチの厳密に${0.013837}倍．

            * JIS Z 8305に基づくもの（1962年）：\quad;
              厳密に${0.3514\math-unit!{mm}}．

            * \dfn{\TeX;ポイント}\code(`pt`);（1982年）：\quad;
              国際インチの厳密に${\paren{1/72.27}}倍．

            * \TeX;でのDidotポイント\code(`dd`);（1964年）：\quad;
              \TeX;ポイントの厳密に${\paren{1157/1238}}倍．

            * DTPポイント（1984年）：\quad;
              国際インチの厳密に${\paren{1/72}}倍．
              \dfn{PostScript} \cite[`PostScript`];
              の仕様で導入され，\dfnje{PostScriptポイント}{PostScript point}とも呼ばれる．
              CSSで扱われる\code(`pt`);，および
              \TeX;の\dfnje{ビッグポイント}{big point}\code(`bp`);も，
              これに等しい\footnote{
                ただし，\TeX;での長さの扱いは
                \dfnje{スケールドポイント}{scaled point} \code(`sp`);
                という\TeX;ポイントの厳密に ${\paren{1/65536}}倍の長さの整数倍として表現され，
                ビッグポイントも\TeX;ポイントの
                厳密に ${\paren{65781/65536}}倍として扱われているので，
                定義と実装で差がある．
                といっても\code(`sp`);は ${10^{-6}\math-unit!{mm}}のオーダーなので，
                視覚表現上はこの単位に対する丸め誤差を気にする必要がない．
              }．


          }%

          CSS，PostScript，PDF（および，\code(`bp`);という単位だが，\TeX;）
          などに広くまたがって互換性に優れた
          デファクトスタンダードとして確立されていることを鑑み，
          \SATySFi;は\codem{pt}の定義としてDTPポイントを採用した．
        }
        +p{
          長さに関する基礎的な演算を行なう式は次のとおりである：

          \listing{
            * \codem{\metasub(${1}){l} +' \metasub(${2}){l}}：\quad;
              長さ同士の加算．

            * \codem{\metasub(${1}){l} -' \metasub(${2}){l}}：\quad;
              長さ同士の減算．

            * \codem{\meta{l} \*' \meta{r}}：\quad;
              長さ\codem{\meta{l}}と浮動小数点数\codem{\meta{r}}を受け取り，
              \codem{\meta{l}}を\codem{\meta{r}}倍した長さを返す．

            * \codem{\metasub(${1}){l} /' \metasub(${2}){l}}：\quad;
              長さ\codem{\metasub(${1}){l}}が
              長さ\codem{\metasub(${1}){l}}の
              “何倍の長さであるか” の浮動小数点数を返す．
          }%
        }
      >
      +subsection?:(`functions`){函数定義}<
        +p{
          大抵のプログラミング言語には，頻出する計算手順に名前をつけ，
          その計算手順を1箇所にまとめて記述する方法が備わっている．
          多くの言語と同様に，\SATySFi;では\dfnje{函数}{function}がその役割を担う\footnote{
            函数のほかには，\dfn{Fortran90}などの言語に見られるように
            \dfnje{サブルーティン}{subroutine}と呼ばれる機構がこの役割を担っている言語もある．
          }．
          函数は，何らかの値を受け取り，それを加工して新たな値をつくる処理である．
          例として，円単位の金額を整数で受け取り，
          それをドル単位に換算する函数\codem{to-dollar}を定義してみよう．
          レートはひとまず9月24日19時23分(UTC)に基づいて${1}ドルを${112.73}円とする．
          これは以下のようにして定義できる：

          \d-code(```
            let to-dollar m-yen =
              let rate = 112.73 in
                (float m-yen) /. rate
            in
            （続きの式）
          ```);%

          函数の定義もlet式を用いて行なうのである．
          ここで登場する\codem{m-yen}は\dfn{仮引数}
          または単に\dfn{引数}と呼ばれるもので，
          函数\codem{to-dollar}の受け取る値が格納される変数である．
          ここで例示した\codem{to-dollar}はひとつだけ引数をとる函数だが，
          一般には任意に正整数個とれる．
          函数定義は，次のような構文によって為される：

          \d-codem{
            let \meta{f} \metasub(${1}){x} ${\cdots} \metasub(${n}){x} =
              \metasub(${1}){expr}
            in
              \metasub(${2}){expr}
          }%

          \codem{\meta{f}}が定義したい函数に与える名前であり，
          各\codem{\metasub(${i}){x}}は第 ${i} 引数である．
        }
        +p{
          さて，上で定義した函数\codem{to-dollar}を実際に使ってみよう．
          函数の定義は，パッケージの読み込みの記述から\codem{document}までの間の部分で行なえる．
          すなわち，以下のようになる：

          \d-code(```
            @require: stdjareport

            let-inline \show-int n = embed-string (arabic n)
            let-inline \show-float x = embed-string (show-float x)
            let-inline \show-string s = embed-string s
            in

            let to-dollar m-yen =
              let rate = 112.73 in
                (float m-yen) /. rate
            in

            document (|
              （以降略）
          ```);%

          それでは実際に\codem{to-dollar}を使って円単位の金額をドル単位に換算してみよう．
          函数\codem{\meta{f}}に式\codem{\meta{expr}}の計算結果を渡したいときは
          \codem{\meta{f} \meta{expr}}と書く．
          これを函数\codem{\meta{f}}の式\codem{\meta{expr}}への\dfnje{適用}{application}
          とか式\codem{\meta{expr}}による函数\codem{\meta{f}}の\dfnje{呼び出し}{call}
          と呼ぶ．また，ここで評価結果が\codem{\meta{f}}に渡される式\codem{\meta{expr}}のことを
          \codem{\meta{f}}の\dfn{実引数}と呼ぶ．
          やや厄介なことに，仮引数だけでなくこの実引数も単に\dfn{引数}と呼ばれることが多い．
          しかし「引数」が仮引数の意であるか実引数の意であるかは
          ほとんどの場合使用されている文脈から判断できるので，
          特に違いを強調する必要のない場合は両者ともに引数と書くことにする．
        }
        +p{
          函数\codem{\meta{f}}の式\codem{\meta{expr}}への適用は，次のような流れで評価される：

          \listing{
            * 実引数\codem{\meta{expr}}が評価されて値\codem{\meta{value}}になる．

            * 函数\codem{\meta{f}}の定義
              \codem{let \meta{f} \meta{x} = \meta{e} in ${\cdots}}
              が “思い返される”．

            * 仮引数\codem{\meta{x}}が\codem{\meta{value}}に束縛された下で
              “定義の本体” である式\meta{e}が評価され，その結果が適用の式全体の評価結果となる．
          }%

          不正確ながら大雑把に言ってしまえば，
          函数定義中の仮引数が実引数で置き換えられたものの計算するのが函数適用である．
          さて，実際に\codem{to-dollar}を適用したのが以下だ：

          \d-code-and-block(```
            +p{ Answer: \show-float(to-dollar 10000); }
          ```)(open Sample in '<
            +p{ Answer: \show-float(to-dollar 10000); }
          >);%

          やはり大雑把に言えば，\codem{to-dollar}の “定義本体” の中の\codem{m-yen}がすべて
          \codem{10000}に置き換わったものの計算結果が出ているわけである．
          というわけで10000円は大体88.7ドルくらいであることが計算できた．
        }
        +p{
          函数それ自体にも，整数などと同様に型がつけられる．
          \type(Type.tymtausub ${1});型の引数をとって
          \type(Type.tymtausub ${2});型の値を返す函数には
          \type(Type.(tymtausub ${1} --> tymtausub ${2}));
          という型がつくと定められている．
          例えば，上で定義した\codem{to-dollar}は
          \type(Type.(int --> float));型をもつ．
          このことを以降

          \val({to-dollar})(Type.(int --> float));%

          とコロン（${:}）を挟んで式とそれにつく型を並べることで表記する．
        }
        +p{
          さて，引数が1個の函数はよいとして，複数の引数をとる函数も
          同様の例を通じて説明する．
          先ほどの\codem{to-dollar}は交換のレートが決め打ちされていた．
          今度はレートも引数にして，その都度変えられるようにしてみたい．
          その定義が以下である：

          \d-code(```
            let to-dollar-2 rate m-yen =
              (float m-yen) /. rate
          ```);%

          レート\codem{rate}が第1引数に，日本円の額面\codem{m-yen}が第2引数になるように改めたのである．
          さて，9月26日16時44分 (UTC) のレートは${1}ドル${112.95}円であった．
          このレートであらためて計算してみよう．
          引数が ${n} 個あるとき，函数適用は
          \codem{\meta{f} \metasub(${1}){expr} ${\cdots} \metasub(${n}){expr}}
          という形で書く：

          \d-code-and-block(```
            +p{ Answer: \show-float(to-dollar-2 112.95 10000); }
          ```)(open Sample in '<
            +p{ Answer: \show-float(to-dollar-2 112.95 10000); }
          >);%
        }
        +p{
          ところで，引数が複数個ある函数はどのような型がつくのだろう？\quad;
          結論から言うと，引数を ${n} 個とり，各第 ${i} 引数の型が\type(Type.tymtausub ${i});，
          返り値の型が\type(Type.tymtau);であるような函数には

          \quote{
            \type(Type.(tymtausub ${1} --> (of-math ${\cdots} --> (tymtausub ${n} --> tymtau))));
          }%

          という型がつく．例えば上で定義した\codem{to-dollar-2}は
          \type(Type.(float --> (int --> float)));という型をもつという具合である．
          この矢印が連なった型は実は新たな記法などではなく，
          括弧を省略せずに書くと

          \quote{
            \type(Type.(tymtausub ${1} --> (synt-paren (tymtausub ${2} -->
              (synt-paren (of-math ${\cdots} --> (synt-paren (tymtausub ${n} --> tymtau))))))));
          }%

          という型である．つまり
          “矢印で構築される函数の型\type(Type.(tymtau --> tymtaup));の
          \type(Type.tymtaup);の側がさらに函数の型になっている” という構造が
          繰り返されてできているのが上記の型なのである．
          だが，どうして ${n} 引数函数の型がこのように表されるのだろうか？\quad;
          これは次のような考察に基づくものだ：

          \quote{
            \type(Type.tymtausub ${1});型の第1引数と
            \type(Type.tymtausub ${2});型の第2引数を受け取って
            \type(Type.tymtau);型の値を返す函数は，
            \type(Type.tymtausub ${1});型の第1引数を受け取って
            「\type(Type.tymtausub ${2});型の第2引数を受け取って
            \type(Type.tymtau);型の値を返す函数」を返す函数ともみなせる．
          }%

          これはいわゆる函数型言語が基盤とする理論の中でも初歩となる重要な点で，
          この考察に基づく “変換” を\dfnje{カリー化}{currying}と呼ぶ．
          このことは次に説明する\dfnje{部分適用}{partial application}を
          念頭に置くととても自然に理解できる．
          部分適用とは，簡単に言えば “一部の引数しか渡さないこと” である．
          先ほど定義した\codem{to-dollar-2}に，
          第1引数であるレートの値のみ渡して部分適用することにより
          別の函数を定義してみよう：

          \d-code(```
            let to-dollar-par = to-dollar-2 112.73
          ```);%

          この\codem{to-dollar-par}は
          「日本円での額面を受け取り，それをレート${112.73}円/ドルに基づいてドルの額面にして返す函数」
          であり，型として\type(Type.(int --> float));をもつ．
          \type(Type.(int --> string));型の函数に引数として\type(Type.int);型を渡すと
          返り値の型が\type(Type.string);型であるのと全く同様に，
          \type(Type.(float --> (synt-paren (int --> float))));型の\codem{to-dollar-2}に
          \type(Type.float);型の式を渡す記述だから\type(Type.(int --> float));型なのである．
          こうして定義した\codem{to-dollar-par}は，
          最初に掲げた\codem{to-dollar}と等価な振舞いをする函数になっている．

          また，部分適用と対応するように，実は複数の実引数の適用

          \d-codem{
            \meta{f} \metasub(${1}){expr} ${\cdots} \metasub(${n}){expr}
          }%

          も，括弧を略さずに書くと

          \d-codem{
            (((\meta{f} \metasub(${1}){expr}) \metasub(${2}){expr}) ${\cdots} ) \metasub(${n}){expr}
          }%

          である．これは函数適用\codem{\metasub(${1}){expr} \metasub(${2}){expr}}に於いて
          \codem{\metasub(${1}){expr}}が\type(Type.(tymtau --> tymtaup));型を，
          \codem{\metasub(${2}){expr}}が\type(Type.(tymtau));型をもつことが
          検査されることから考えると自然だろう．
          平均的な型システムの入門的解説に比べるとかなり駆け足になってしまったが，
          以上が函数につけられる型と部分適用の仕組みだ．
        }
        +p{
          ところで，これもいわゆる函数型言語が基盤とする理論としては重要な点なのだが，
          函数はいちいちlet式で名前をつけて扱う必要はない．
          例えば，上でlet式で定義した\codem{to-dollar-2}は
          \codem{to-dollar-2}と名前をつけずとも以下のように\dfn{無名函数}\footnote{
            理論的には\dfnje{ラムダ抽象}{${\lambda}-abstraction}と呼ばれるものである．
          }で書ける：

          \d-code(```
            (fun rate m-yen -> (float m-yen) /. rate)
          ```);%

          勿論この例ではわざわざこう書く必要はないのだが，
          後述する高階函数では役立つことが多い．
          「役立つことが多い」などと，
          あたかも無名函数が “後から言語機能に足された瑣末なもの” であることを
          示唆するかのような言い方になってしまったが，
          実はこの無名函数はlet式による函数の定義よりも言語機能として基盤にあるものだ．
          函数を定義するlet式

          \d-codem{
            let \meta{f} \metasub(${1}){x} ${\cdots} \metasub(${n}){x} =
              \metasub(${1}){expr} in \metasub(${2}){expr}
          }%

          は，実は以下の糖衣構文にすぎない：

          \d-codem{
            let \meta{f} = (fun \metasub(${1}){x} ${\cdots} \metasub(${n}){x} -\>
              \metasub(${1}){expr}) in \metasub(${2}){expr}
          }%

          つまり，前者は処理系で内部的に（構文解析が終わり，型検査が始まる前に）
          後者に変換されているのである．
          後者のlet式は\ref-subsection(`variables`);で最初に紹介したlet式そのものである．
          すなわち，函数定義は単に変数束縛の一種だったのである．
          “函数” と “変数” の垣根がないことは，
          \SATySFi;が拠り所とするML系言語の重要な特徴である\footnote{
            いわゆる函数型言語にあっても，“函数” と “変数” とが
            別個の概念としてある言語は存在する．
            \dfn{Common Lisp}などが有名である．
          }．
          ちなみに，もっといえば

          \codem{
            (fun \metasub(${1}){x} ${\cdots} \metasub(${n}){x} -\>
              \meta{expr})
          }%

          も

          \codem{
            (fun \metasub(${1}){x} -\> (fun \metasub(${2}){x} -\> ${\cdots} (fun \metasub(${n}){x} -\>
              \meta{expr}) ${\cdots}))
          }%

          の糖衣構文である．これは先ほど部分適用で説明したこととも対応しており，
          要するに ${n} 引数をとる函数とは “1引数函数が ${n} 重入れ子になったもの”
          である，ということだ．
        }
        +p{
          すでに述べたが，浮動小数点数や文字列などのデータの説明で登場した
          \codem{arabic}，\codem{float}，\codem{round}は，
          それぞれ以下のような型をもつプリミティヴの函数である：

          \listing{
            * \codem{arabic} : \type(Type.(int --> string));
            * \codem{float} : \type(Type.(int --> float));
            * \codem{round} : \type(Type.(float --> int));
          }%

          函数につく型については上記の説明ですでによく把握されているだろうから，
          それぞれにこのような型がつくことはもはや当然のように感じられるだろう．
        }
        +p{
          さらには，2項演算子も実は函数である．
          \codem{\metasub(${1}){expr} + \metasub(${2}){expr}}は
          実は\codem{(+) \metasub(${1}){expr} \metasub(${2}){expr}}
          という函数適用の糖衣構文であり，2項演算子\codem{+}の正体は
          \codem{(+)}という3トークンからなる特殊な名前をもつ変数なのである．
          \codem{(+)}は\type(Type.(int --> (int --> int)));という型をもち，
          それゆえに\type(Type.(int));型のつかない引数を与えると
          型検査器にエラーを返されていたのである．
          さらに，2項演算子は（通常の変数名の函数と同様に）自分で定義することもできる．
          使える名前は，
          \codem{\meta-or{|+|-|\*|/|^|\&|\||!|:|=|\<|\>|~|'|.|?|}}を
          \codem{\meta{opsymb}}と表すとして

          \listing{
            * \codem{\meta-or{|\*|/|}\meta-star{\meta{opsymb}}}
            * \codem{\meta-or{|+|-|}\meta-star{\meta{opsymb}}}
            * \codem{^\meta-star{\meta{opsymb}}}
            * \codem{\meta-or{|=|\>|\<|}\meta-star{\meta{opsymb}}}
            * \codem{\&\meta-plus{\meta{opsymb}}}
            * \codem{\|\meta-plus{\meta{opsymb}}}
          }%

          にマッチするもののうち，以下に該当しないものである\footnote{
            \codem{--}は実質的に使われなくなっているが，
            歴史的経緯から特殊なトークンとして残存している．
          }：

          \tokens{|=|--|-\>|}%

          結合の強さは先に挙げたものほど強いとする．
          いずれも左結合である．
        }
      >
      +subsection?:(`conditionals`){真偽値と条件分岐}<
        +p{
          真偽値は “正しいか正しくないか” を表すデータであり，\type(Type.bool);型をつけて扱う．
          \type(Type.bool);型のつく式はおおよそ “命題” に対応し，
          \type(Type.bool);型の値としては
          真に対応する ${\term!(Term.truev)} と
          偽に対応する ${\term!(Term.falsev)} との2種類のみがある．
        }
        +p{
          真偽値に関連する言語機能として，
          “何が成り立っているかによってその先の処理を変える” 記述，
          すなわち\dfnje{条件分岐}{conditional branching}がある．
          例として整数の絶対値函数\codem{abs}を定義してみよう：

          \d-code(```
            let abs n =
              if n < 0 then - n else n
          ```);%

          ここで使われる
          \codem{if \metasub(${0}){expr}
            then \metasub(${1}){expr} else \metasub(${2}){expr}}
          が条件分岐に使われる\dfnje{if式}{if-expression}であり，
          直観的には
          「\metasub(${0}){expr}が成り立つならば\metasub(${1}){expr}を，
          そうでないならば\metasub(${2}){expr}を評価する」
          を意味する．
          型つけの規則としては，
          \codem{\metasub(${0}){expr}}は\type(Type.bool);型であることと，
          \codem{\metasub(${1}){expr}}と\codem{\metasub(${2}){expr}}とに
          同一の型がつくことが要請される．
          ここでの例は，整数を比較する2項演算子\codem{\<}を用いて
          与えられた引数が\codem{0}未満であるかどうかを判定しており，
          負の値であった場合は符号を反転し，非負の値であった場合はそのまま返す，
          ということを記述している．
          ちなみに，条件分岐の話とは関係ないが，
          注意深い人は\codem{- n}という部分が新しい構文であることに気づいただろう．
          これは\codem{-}という名前の2項演算子のみに与えられた特殊な機能で，
          大雑把に言えば “左側の引数を省略した場合は\codem{0}として扱う” というものだ．
          要するに符号の反転を自然に書くための機能である\footnote{
            浮動小数点数用の\codem{-.}や長さ用の\codem{-'}には，
            この機能は現状備わっていない．将来的に追加したいとは考えている．
          }．ともあれ，この\codem{abs}の動作を確認してみる：

          \d-code-and-block(```
            +p{ Answer: \show-int(abs (abs (1 - 2) * 3 - 4)); }
            +p{ Answer: \show-int(abs (abs (1 + 2) * 3 - 4)); }
          ```)(open Sample in '<
            +p{ Answer: \show-int(abs (abs (1 - 2) * 3 - 4)); }
            +p{ Answer: \show-int(abs (abs (1 + 2) * 3 - 4)); }
          >);%
        }
        +p{
          論理演算として
          選言\codem{\|\|} : \type(Type.(bool --> (bool --> bool)));，
          連言\codem{\&\&} : \type(Type.(bool --> (bool --> bool)));，
          否定\codem{not} : \type(Type.(bool --> bool));
          などが用意されており，これを用いてより複雑な条件の指定ができる．
          最初から使える種々の演算は\ref-subsection(`arithmetic`);に掲載したので参照されたい．
        }
      >
      +subsection{型システムと型推論の恩恵}<
        +p{
          式に型がつくことで，その式を評価しても
          “値の種類に由来するエラー” は起きないということが保証される．
          というか，型システムはこういったエラーを
          プログラムを評価せず事前に検出して弾くためにあるわけである．
          型なしの言語（いわゆる動的型つき言語\footnote{
            「動的型」と言ったときの「型」は，
            ここで説明した型の概念とは似て非なるもので，
            “実行時にデータの種類を示すものとして値についているタグ”
            であることに注意されたい．
            繰り返しになるが，この本で使用しているのと同様の意で
            「型」と言った時は “式に対して事前にわかる分類”
            である．動的型との混同を避けて
            俗に静的型と呼ばれることもある．
            歴史的には動的型を指して「型」という語を使う方が
            ずっと後発の用法である．
          }）に馴染みの深い読者なら，もしかすると
          「静的型を入れず，
          整数値に文字列を足す処理が書かれたら前者を十進文字列にして
          文字列結合にするように\codem{+}を定義すればよいのでは？\quad;
          逐一\codem{arabic}で整数値を文字列値へ変換する処理を
          明示的に書く必要もないし楽になるだろう」
          などと考えるかもしれない．
          だが，
          \codem{\metasub(${1}){expr} + \metasub(${2}){expr}}
          の形の式の計算結果が整数値にも文字列値にもなりうるというのは
          そんなに “うれしいこと” ではない．
          式に型をつけないという言語設定を仮定した下で，次のような函数を考えよう：

          \d-code(```
            let f x =
              let y = 42 + x in
                y / 2
          ```);%

          型なしの言語だったりして，
          整数値と文字列値の加算が許容されるとしよう．
          このとき，上記の\codem{f}に渡される\codem{x}の “値の種類” によっては，
          除算\codem{y / 2}に於いて
          \codem{y}が文字列値など整数値でない場合も扱わねばならないことになる．
          除算の定義をどうするか，ここで2通りの選択肢がある：

          \listing{
            * 整数値以外が左側にきた場合は実行時エラーとする．

            * 整数値以外が左側にきた場合，結果を必ず\codem{0}にしたり，
              何も処理せずその値を返したりと，
              とにかく何かしらそれらしい値を返して実行時エラーにはしない．
          }%

          前者を採用した場合，
          これはまさに型システムを入れることで除外したかった
          “値の種類による実行時の破綻” だ．
          「この実行時エラーを許容してもよいから静的に型をつけたくない」
          という主義の人もいるかもしれないが，
          ほとんどの場合その決断は割りに合わないと言ってよい．
          型なしの言語で数千行規模のプログラムを書くと
          （静的型つきの言語で書いた場合に比べて）
          急速に保守が困難になることは想像に難くないし，
          経験的にもそうであることが多いはずだ．
          もし貴方が数千行規模のプログラムを型なしの言語で書いて保守しており，
          かつ特に苦労していると思っていないなら，
          それは単に型なし言語のデバッグの労苦に飼い慣らされていて，
          静的型つきの言語の世界観から見れば大部分は要らぬ苦労をしているだけ，
          という可能性は非常に高い．

          一方で後者を採用した場合，
          計算が失敗することはないが，
          些細な間違いに対してもデバッグが非常に困難になる．
          どこで意図しない計算が生じているか
          事細かに追わないとわからないからだ．
          特に組版処理のように “扱う値の種類” が多い場合，
          “種類の違い” による意図しない計算は生じるリスクが大きく，
          致命的に修正困難な状況に陥りやすいだろう．
          要するに，“値の種類によらず計算に失敗しないようにする” ことも
          “そんなに嬉しくない” のである．
        }
        +p{
          とにかく，人間はプログラムを書く際にはひたすら間違い続ける．
          しかもその間違いは，かなりしょうもないものであることが経験的に多そうだ．
          型検査器は人間の犯すミスのうち或る種の不整合を丁寧にも事細かに指摘してくれる．
          決してお節介なお婆さんではない．
          「“式の種類” に関して不整合のあるプログラムを書いたときに
          型検査器がその不整合を教えてくれ，
          それに基づいて該当箇所をスムーズに修正できる」という利点は，
          「“異なる種類” への値の変換を\codem{arabic}のような形で明示的に書かなければならない」
          という多少の厄介さを補ってあまりがありすぎるほどの恩恵である．
          また，これは非常に誤解が多いのだが，
          プログラムに静的に型をつけるのに
          \dfnje{型註釈}{type annotation}，
          つまり各変数にどのような型をつけるかを明示した註釈が必要なわけでは
          必ずしもない\footnote{
            「静的型つきの言語は逐一変数につく型を書かないといけないから面倒」
            という誤解は，おそらくC言語のような型註釈が省略できない
            （或る意味特殊な）静的型つき言語の存在によるところが大きそうだ．
            一般に静的型つき言語で変数の型註釈が省略できないわけでは決してない．
          }．
          適切に型システムを設計すれば，与えられたプログラムが “整合している” 限り，
          全部または一部の変数にどのような型がつくか，型推論で求められるのである．
          特に\SATySFi;を含めOCaml，F\#，Standard ML，Haskellなど多くの言語の型システムが
          その理論的基盤としている
          \dfn{Damas–Hindley–Milner多相}\footnote{
            \dfn{Hindley–Milner多相}，\dfn{Damas–Milner多相}，
            \dfn{let多相}，\dfn{冠頭多相}などとも呼ばれる．
          } \cite[`Hindley1969`; `Milner1978`];は，
          型推論が\dfnje{完全性}{completeness}をもつ，
          すなわち変数に一切型註釈のない式に対しても
          必ずその式につく “最も一般的な型” である\dfnje{主要型}{principal type}
          が存在してかつそれを求めるアルゴリズムが知られているという性質があり，
          それゆえに特に\SATySFi;やOCamlでは
          よほど複雑な機能を使わない限り基本的に型註釈を書かなくてよいという状況が達成されている．
          つまり型註釈が現実的にプログラマの手を煩わせることはほとんどない．
          むしろ型註釈が省略できすぎるので，
          （2週間後の自分が見てプログラムを読めなくなることのないように）
          型検査器からすればなくてもよい型註釈を可読性のために入れるくらいである\footnote{
            Haskellはlet多相を基盤としていながらも
            \dfnje{型クラス}{typeclass}がある影響で
            型註釈が省略できない場合が顕著にみられ，
            それゆえかトップレヴェルで定義する函数には必ず型註釈を入れる慣習がある．
            たまに「型が函数定義の本体であって，実装はオマケにすぎない」
            という主張をする人がいるが，これは
            （\dfnje{篩型}{refinement type} \cite[
              `FreemanPfenning1991PLDI`; `KnowlesFlanagan2007ESOP`;
              `RondonKawaguchiJhala2008PLDI`;
            ];のような，
            通常の型よりもずっと強力な型を扱う型システムでもない限り）
            過言気味だ．
            型から実装が決まるわけでは決してないためだ．
            例えば返り値の型が\type(Type.bool);の函数なら，
            “最後に\codem{not}をかませるような実装に変更する” だけで
            元と同一の型がつくが振舞いの全く異なる函数の実装ができてしまう．
          }．
          こうした考察から多くの言語には型システムによる静的な検査が搭載されており，
          我々のコーディングを型検査器が支えてくれるようになっている．
          \SATySFi;も，そんな言語のひとつである．
        }
      >
      +subsection{タプル}<
        +p{
          \dfnje{タプル}{tuple}とは “複数の式を並べてひとまとめにした式” であり，
          数学的に言えば直積に相当するものだ．タプルは式として次のような形をもつ：

          \d-codem{
            (\metasub(${1}){expr}, ${\ldots}, \metasub(${n}){expr})
          }%

          ただし ${n \geq 2}．
          各式\codem{\metasub(${i}){expr}}が\type(Type.tymtausub ${i});をもつとき，
          上記のタプルは以下のような型をもつ：

          \quote{
            \type(Type.(product [tymtausub ${1}; tymtausub ${2};
              of-math ${\cdots}; tymtausub ${n}]));
          }%

          代表的な用途として，“複数の値を返り値にしたい時” がある．
          例として，2つの整数を受け取ってその除算の商と剰余を一緒に返す函数\codem{div-rem}を定義してみる：

          \d-code(```
            let div-rem m n =
              (m / n, m mod n)
          ```);%

          こうして定義した\codem{div-rem}には
          \type(Type.(int --> (int --> product [int; int])));型がつく\footnote{
            型の記法では，${\ast} は ${\to} より結合が強いとする．
            すなわちここでは
            \type(Type.(int --> (int --> synt-paren (product [int; int]))));
            を指す．
          }．
          一方で，これを使う側はどうしたらよいのだろう？\quad;
          このために，タプルを “分解” する方法が用意されている．
          \dfnje{パターンマッチ}{pattern matching}と呼ばれる構文である．
          パターンマッチは条件分岐を強化したようなもので，
          “値の形” によって分岐させる機構である．
          \codem{div-rem}を用いて，
          “第1引数の整数以上の値にするには第2引数を少なくとも何倍すればよいか” を返す函数
          \codem{make-exceed}を定義してみる：

          \d-code(```
            let make-exceed n q =
              match div-rem n q with
              | (m, 0) -> m
              | (m, _) -> m + 1
          ```);%

          ここで登場した次のような構文の式がパターンマッチを実現する
          \dfnje{match式}{match-expression}である：

          \d-codem{
            match \meta{expr} with
            \| \metasub(${1}){pat} -\> \metasub(${1}){expr} \| ${\cdots} \|
              \metasub(${n}){pat} -\> \metasub(${n}){expr}
          }%

          ただし ${n \geq 1}で，\codem{with}の直後の\codem{\|}は省略してもよい．
          各\codem{\metasub(${i}){pat}}は\dfnje{パターン}{pattern}と呼ばれるものであり，
          “値の形” を表す．
          パターンの中には変数または\dfnje{ワイルドカード}{wildcard}である\codem{\_}を含めてよく，
          そこは “どんな形でもマッチする” ものと扱われる．
          match式は，まず\codem{\meta{expr}}を評価し，その結果得られた値が
          各パターン\codem{\metasub(${i}){pat}}のどれに合致する “形” をしているかを
          先に挙げたパターンほど優先で選択し，パターン中の変数を該当箇所の実際の値に束縛してから，
          それに対応する式\codem{\metasub(${i}){expr}}を評価する．
          上記の例では，\codem{div-rem}が返すタプルの2番目の値，
          つまり剰余に相当する部分が\codem{0}である場合は，
          変数\codem{m}をタプルの1番目の値に束縛し，そのパターンに対応する式である\codem{m}を返す．
          つまり，この場合は単に割った商を返している．
          一方で，最初のパターンにマッチしなかった場合は，
          2番目のパターンにマッチさせ，同様に変数\codem{m}を用いて商を取り出し，
          それに\codem{1}を加えて返す．
          パターンの順番は重要である．もし上の例で
          \codem{\| (m, _) -\> m + 1}を\codem{\| (m, 0) -\> m}よりも先に書いていたら，
          定義される\codem{make-exceed}は単に “商に${1}足して返す函数” になってしまう
          （つまり，\codem{n}が\codem{q}で割り切れる場合の返り値が異なる）．
          型の観点からは，各\codem{\metasub(${i}){expr}}の型はすべて一致する必要があり，
          その一致した型がmatch式全体のもつ型になる．
          また，パターンがひとつだけのmatch式
          \codem{match \meta{expr} with \metasub(${1}){pat} -\> \metasub(${1}){expr}}
          は\codem{let}を用いて

          \d-codem{
            let \metasub(${1}){pat} = \meta{expr} in \metasub(${1}){expr}
          }%

          という糖衣構文で書くことができる．別の例として
          “長さと平面座標を受け取り，その座標を ${+x} 方向に与えられた長さだけ移動させる函数”
          \codem{shift-x}を定義してみよう：

          \d-code(```
            let shift-x len point =
              let (x, y) = point in
              (x +' len, y)
          ```);%

          このように\codem{let}でタプルを分解できるのである．
          こうして定めた\codem{shift-x}は
          \type(Type.(length --> (product [length; length] --> product [length; length])));
          型をもつ．
          さらには，パターンを引数に直接書くこともできる．
          以下のように書いても，上での定義と等価に振舞う函数が定義できる：

          \d-code(```
            let shift-x len (x, y) =
              (x +' len, y)
          ```);%

          駆け足気味であったが，以上がタプルとパターンマッチの基礎である．
        }
      >
      +subsection{代数的データ型}<
        +p{
          \dfnje{代数的データ型}{algebraic data type, ADT}は
          \REMAINS{代数的データ型}
        }
        +p{
          \REMAINS{itemize}
        }
      >
      +subsection{再帰函数}<
        +p{
          \REMAINS{再帰函数}
        }
      >
      +subsection{レコード}<
        +p{
          \REMAINS{レコード}
        }
      >
      +subsection{手続き}<
        +p{
          \REMAINS{手続き}
        }
      >
      +subsection?:(`arithmetic`){算術に関するプリミティヴ}<
        +p{
          主な “算術演算” 用のプリミティヴについてまとめて紹介する：

          \vals-explain({|+|-|\*|})(tyarithI) {
            整数の加算，減算，乗算．
          }%
          \vals-explain({|/|mod|})(tyarithI) {
            整数の除算と剰余．
            \codem{mod}は通常の変数名と同様だが，例外的に2項演算子である．
            いずれも第2引数に\codem{0}が与えられた場合は実行時エラーとなる．
          }%
          \vals-explain({|==|\<\>|})(tycompI) {
            整数の等号と不等号．
          }%
          \vals-explain({|\>|\<|\>=|\<=|})(tycompI) {
            “大なり”，“小なり”，“大なりイコール”，“小なりイコール”．
          }%

          % -- 真偽値 --
          \vals-explain({|\&\&|\|\||})(tylogical) {
            連言と選言．
          }%
          \val-explain({not})(Type.(bool --> bool)) {
            否定．
          }%

          % -- 浮動小数点数 --
          \val-explain({float})(Type.(int --> float)) {
            整数を浮動小数点数に変換する．
          }%
          \val-explain({round})(Type.(float --> int)) {
            浮動小数点数を，小数部分を切り捨てて整数に変換する．
            引数が正負無限やNaN，あるいは小数部分を切り捨てた整数が\type(Type.int);型で
            表現不可能なときの結果は未定義．
          }%
          \vals-explain({|+.|-.|\*.|/.|})(tyarithF) {
            浮動小数点数の加算，減算，乗算，除算．
          }%
          \vals-explain({|sin|cos|tan|})(tysine) {
            正弦，余弦，正接函数．
          }%
          \vals-explain({|asin|acos|atan|})(tysine) {
            アークサイン，アークコサイン，アークタンジェント．
            すなわち，それぞれ正弦，余弦，正接函数の “逆函数” である．
          }%
          \val-explain({atan2})(Type.(float --> (float --> float))) {
            \codem{atan2 \meta{y} \meta{x}}で
            \codem{\meta{y} /. \meta{x}}のアークタンジェントを返すが，
            \codem{\meta{y}}と\codem{\meta{x}}の符号が象限の決定に用いられる．
            返される値は ${-\pi} から ${\pi} の間の値である．
          }%

          % -- 長さ --
          \vals-explain({|+'|-'|})(Type.(length --> (length --> length))) {
            長さの加算と減算．
          }%
          \val-explain({\*'})(Type.(length --> (float --> length))) {
            長さのスカラー倍．
          }%
          \val-explain({/'})(Type.(length --> (length --> float))) {
            長さの “除算”．
          }%
          \vals-explain({|\>'|\<'|})(Type.(length --> (length --> bool))) {
            長さの “大なり” と “小なり”．
          }%

          % -- 文字列 --
          \val-explain({^})(Type.(string --> (string --> string))) {
            文字列の結合．
          }%
          \val-explain({arabic})(Type.(int --> string)) {
            整数を十進文字列に変換する．
          }%
          \val-explain({show-float})(Type.(float --> string)) {
            浮動小数点数を十進文字列に変換する．
          }%
          \val-explain({string-same})(Type.(string --> (string --> bool))) {
            文字列の等価性の判定．
            バイト列として等価かどうかの判定であり，
            Unicodeによって規定された正規化等は行なわない．
          }%
          \val-explain({string-sub})(Type.(string --> (int --> (int --> string)))) {
            \codem{string-sub \meta{s} \meta{i} \meta{l}}で
            文字列\codem{\meta{s}}の第\codem{\meta{i}}番目の文字を先頭とする
            長さ\codem{\meta{l}}の部分文字列を取り出す．
            文字数はUnicodeコードポイント単位．
            \codem{\meta{i}}と\codem{\meta{l}}による
            指定が部分文字列の範囲でない場合は実行時エラーが出る．
          }%
          \val-explain({string-length})(Type.(string --> int)) {
            与えられた文字列がUnicodeコードポイント単位で何文字かを返す．
          }%
          \val-explain({string-unexplode})(Type.(list int --> string)) {
            与えられた整数列の各整数をUnicodeコードポイントと解釈した文字列を返す．
            Unicodeコードポイントの範囲にない整数が与えられた場合の動作は未定義．
          }%
          \val-explain({embed-string})(Type.(string --> inline-text)) {
            文字列をインラインテキストに変換する．
          }%

%          \val-explain({regexp-of-string})(Type.()) {}
%          \val-explain({string-match})(Type.()) {}
%          \val-explain({split-on-regexp})(Type.()) {}

          \val-explain({split-into-lines})%
            (Type.(string --> list (product [int; string]))) {
              与えられた文字列を各行に分解してリストを返す．
              返されるリストの各要素\codem{(\meta{i}, \meta{s})}は
              “インデントが\codem{\meta{i}}個挿入された内容文字列\codem{\meta{s}}の行”
              に相当する．
            }%

           \val-explain({!})%
             (Type.(forall ${\alpha} (ref tymalpha --> tymalpha))) {
               \codem{!\meta{r}}で可変参照\codem{\meta{r}}の参照する現在の値を返す．
             }%
           \val-explain({::})(Type.(forall ${\alpha}
             (tymalpha --> (list tymalpha --> list tymalpha)))) {
               リストの “コンス”，すなわち第1引数を第2引数のリストの先頭につけてできるリストを返す．
             }%
           \val-explain({\|\>})(Type.(forall ${\alpha} (forall ${\beta}
             (tymalpha --> ((tymalpha --> tymbeta) --> tymbeta))))) {
               前後逆の函数適用，すなわち
               \codem{\meta{x} \|\> \meta{f}}で
               \codem{\meta{f} \meta{x}}に同じ．
               ただし，式\codem{\meta{x}}と\codem{\meta{f}}の評価に
               ともに “副作用” がある場合は評価順序の逆転に注意を要する．
             }%
           \val-explain({display-message})(Type.(string --> unit)) {
             与えられた文字列を1行として標準出力に表示する．
           }%
        }
      >
      +subsection?:(`diff-from-ocaml`){OCamlとの顕著な差異}<
        +p{
          すでに述べたように
          プログラミング言語としての\SATySFi;は
          OCamlにかなり近いものとなっているが，
          非互換な違いがいくつか顕著にある．
        }
        +desc{変数名}{
          おそらくコードの見た目上これが最も目につく違いである．
          変数名はラテン小文字から始まり，
          2文字目以降は大小ラテン文字，数字，ハイフンのいずれかでなければならない．
          アンダースコア（\codem{_}）や
          引用符（\codem{'}）は使えないことに注意．
        }
        +desc{再帰函数の定義}{
          再帰函数の定義には，OCamlの\code(`let rec`);の代わりに
          \codem{let-rec}を用いる．これで1トークンである．
        }
        +desc{型コンストラクタの構文}{
          \SATySFi;では，型コンストラクタ\codem{\meta{tyconstr}}の “適用” は
          \codem{\metasub(${1}){ty} ${\cdots} \metasub(${n}){ty} \meta{tyconstr}}
          という形で書く．これはOCamlの
          \codem{(\metasub(${1}){ty}, ${\ldots}, \metasub(${n}){ty}) \meta{tyconstr}}
          および ${n = 1}の場合の
          \codem{\metasub(${1}){ty} \meta{tyconstr}}
          という形の構文とは明確に異なる．そのかわり，
          OCamlでの\code(`int list list`);のような括弧を省いた “適用” を書くことはできず，
          必ず\codem{(int list) list}と括弧をつけることになる．
        }
        +desc{コンストラクタ}{
          \SATySFi;では，ヴァリアント型のコンストラクタはすべて1引数である．
          \codem{None}のように引数のないコンストラクタの使用は
          \codem{None()}のようにユニット値が省略されているものとして扱われているほか，
          OCamlでは

          \d-code(```
            type foo = Foo of int * int
          ```);%

          と

          \d-code(```
            type foo = Foo of (int * int)
          ```);%

          とで定義される型が異なるが，\SATySFi;では完全に一致する．
        }
        +desc{レコード}{
          まずレコード式を囲む括弧が
          \code(`{`); ${\cdots} \code(`}`);
          の代わりに
          \codem{(\| ${\cdots} \|)}である\footnote{
            これは\codem{\{ ${\cdots} \}}の記法を
            インラインテキストのために明け渡したからである．
          }．
          また，レコード型はnominalではなくstructuralであり，
          したがってレコード式\codem{(\| ${\cdots} \|)}は
          それにつく型を\codem{type ${\cdots}}で宣言せずとも
          書くことができる．
          これは\SATySFi;の型システムがレコードに関して
          \dfn{SML\#}と同様のもの \cite[`Ohori1995`];
          を採用しているからである（詳細は元論文を参照せよ）．
          これに加え，
          OCamlに備わっているような，
          特定のフィールドをmutableにするような機能はなく，
          必ず全てのフィールドがimmutableである．
        }
        +desc{可変参照}{
          可変参照はOCamlのように多相函数\code(`ref`);で作るのではなく，

          \d-codem{
            let-mutable \meta{x} \<- \metasub(${1}){expr} in \metasub(${2}){expr}
          }%

          という構文で作るように限定されている．これはOCamlの

          \d-codem{
            let \meta{x} = ref \metasub(${1}){expr} in \metasub(${2}){expr}
          }%

          と同等である．破壊的代入も，OCamlのように\code(`:=`);ではなく，
          \codem{\meta{x} \<- \meta{expr}}と書く．
          \codem{\<-}が多相な2項演算子なのではなく，
          \codem{\meta{x} \<- \meta{expr}}全体が式をなすひとつの構文である．
        }
      >
    >
  >
  +chapter?:(`overall-structure`){文書が処理される仕組み}< #overall; >
%  +chapter?:(`type-system`){型システム}<
%    +p{
%      既に\ref-chapter(`introduction`);で述べたとおり，
%      \SATySFi;の最大の特徴は型検査器を備えているおかげで
%      或る種の入力の誤りを実際に組版処理を始めるよりも前に検出してすばやく報告できることにある．
%      本章では，この型検査器を実現している型システムについて見ていくことにしよう．
%    }
%    +p{ \REMAINS{} }
%  >
  +chapter?:(`advanced-command-definition`){コマンド定義：発展編}<
    +p{
      \ref-chapter(`basic-command-definition`);
      で基礎的なコマンド定義の方法およびプログラミング言語としての\SATySFi;について習得し，
      \ref-chapter(`overall-structure`);で\SATySFi;の処理系の全体像，
      および各工程がどのように定式化されているかについて概観した．
      これらの前提知識を把握した下で，この章ではようやくフォントや文字色，行送りといった，
      “組版上の装飾的な視覚情報” にも関わる処理を行なうコマンドの実装方法を習得する．
    }
    +section?:(`text-processing-context`){テキスト処理文脈}<
      +p{
        \ref-chapter(`overall-structure`);でも既に述べたが，
        組版処理はインラインテキスト・ブロックテキストといった
        “テキストの情報” だけが与えられてもできない．
        すなわち，どのフォントのどんなサイズで組むか\footnote{
          活版印刷の慣習としては，“font” という語は
          各字形が同一のデザインに則っているだけでなく
          サイズも相等しいひと揃いの活字のセットを指したようだが，
          \SATySFi;でフォントと言う場合は
          （字形やそれに関するメトリックのひとかたまりに紐づけられた）フォント名，
          拡大縮小比率，ベースライン調整率
          の3つ組を指す．詳しくは\ref-chapter(`typography`);で述べる．
        }，段落の幅や行送りはどの程度の長さにするか，
        といった情報が “テキストの情報” に加えて必要である．
        これらの
        “テキストには表れていないが組版処理上必要な情報”
        を，\SATySFi;は
        \dfnje{\index(`テキスト処理文脈`){テキスト処理文脈}}{text-processing context}
        という機構に保持させて扱う．
        抽象的な説明を続けてもおそらく要領を得ないであろうから，
        具体例を用いて説明しよう．
        例えば，文字サイズを1.5倍に変更するコマンド\codem{\\enlarge}を考える：

        \d-code-and-block(```
          +p{ 内側の\enlarge{文字が\enlarge{1.5倍}の大きさに}なります． }
        ```)(open Sample in '<
          +p{ 内側の\enlarge{文字が\enlarge{1.5倍}の大きさに}なります． }
        >);%

        このような\codem{\\enlarge}は次のように定義できる：

        \d-code(```
          let-inline ctx \enlarge it =
            let size = get-font-size ctx in
            let ctx-enlarge = set-font-size (size *' 1.5) ctx in
              read-inline ctx-enlarge it
        ```);%

        唐突に全部見せられてもあまり実感が湧かないであろうから少しずつ説明するが，
        まず1行目から見慣れない文法である．
        \codem{let-inline}を用いてインラインコマンドを定義する構文は
        \ref-chapter(`basic-command-definition`);で既に紹介したが，
        ここでは\codem{let-inline}と定義されるコマンド名\codem{\\enlarge}との間に
        \codem{ctx}なる何かがある．
        実はこれこそがテキスト処理文脈を受け取る “第0引数” の変数だ．
        コマンドの適用が評価されるとき，
        ユーザが与えた通常の引数に加えて，コマンドが使われている箇所のすぐ外側の
        テキスト処理文脈がこの変数\codem{ctx}に渡され，
        コマンドの実装中で使える，というわけである．
        ここまで\pkg{stdjareport}など
        何らかのクラスファイルが提供するマークアップ等の方式に従って
        \SATySFi;を使うにあたってはテキスト処理文脈を全く意識する必要がなかったであろうけれども，
        実のところユーザからは見えない裏側で
        密かに各コマンドがテキスト処理文脈を受け渡ししていたのである．
        なお，\codem{ctx}は単に変数名なので，第0引数に\codem{x}とか\codem{y}とか
        \codem{i-love-satysfi}といった違う名前を使っても構わない\footnote{
          ただし，既存のパッケージでは慣習的に第0引数を必ず\codem{ctx}という変数名にしているので，
          複数人で開発したり，既存パッケージを改造したりする場合は
          \codem{ctx}という変数名で統一した方が理解に齟齬を生じにくいかもしれない．
        }．
      }
      +p{
        さて，続いてコマンド定義の “中身” を見てみる．
        第0引数の\codem{ctx}と（各適用でユーザが与える）第1引数\codem{it}を使うのだが，
        まず\codem{size}に
        外から渡されてきたテキスト処理文脈\codem{ctx}が保持している
        フォントサイズを取り出して束縛する．これはプリミティヴ：

        \val?:(`get-font-size`)({get-font-size})%
          (Type.(context --> length));%

        を用いて行なう．取得したフォントサイズ\codem{size}は\type(Type.(length));型であり，

        \val?:(`*'`)({(\*')})(Type.(length --> (float --> length)));%

        を用いて\codem{size \*' 1.5}で${1.5}倍の長さを得る．
        フォントサイズの設定は

        \val?:(`set-font-size`)({set-font-size})%
          (Type.(length --> (context --> context)));%

        を用いて行なう．
        すなわち，古いテキスト処理文脈\codem{ctx}と設定するフォントサイズ\codem{size}に対して
        \codem{set-font-size size ctx}で
        フォントサイズの更新された新しいテキスト処理文脈が返ってくる．
        \codem{\\enlarge}の実装では，この新しいテキスト処理文脈を
        変数\codem{ctx-enlarge}に束縛している．
        なお，ここの一連の処理で
        \codem{ctx}の内容が “書き換えられる” わけではないことに注意されたい．
        単に\codem{ctx}の内容のうちフォントサイズに関するデータだけが
        \codem{size}に変更された新しいテキスト処理文脈がつくられて
        \codem{ctx-enlarge}という変数に束縛されているだけである．
        実際，\codem{ctx-enlarge}が束縛されたスコープでも
        依然として\codem{ctx}を使うことができ，
        かつそのテキスト処理文脈には元々のフォントサイズが保持されている．
      }
      +p{
        最も重要なのは最終行だ．ここで使われているプリミティヴ

        \val?:(`read-inline`)({read-inline})%
          (Type.(context --> (inline-text --> inline-boxes)));%

        は\ref-chapter(`overall-structure`);で説明した
        インライン変換器に相当し，\ref-figure(`conversion-to-inline-boxes`);
        に示されたような処理をしている．すなわち，
        \codem{read-inline \meta{ctx} \meta{it}}で
        テキスト処理文脈\codem{\meta{ctx}}の保持するフォントや
        文字サイズなどの情報をもとにインラインテキスト\codem{\meta{it}}を
        インラインボックス列へと変換する．
        そしてこれがきわめて重要な事項なのだが，
        インラインテキスト\codem{\meta{it}}に含まれている
        インラインコマンドの適用が評価されるのも，
        この\codem{read-inline}によるインラインボックス列への変換の最中である．
        このとき，\codem{read-inline}に第1引数として渡したテキスト処理文脈が，
        第2引数の\codem{\meta{it}}中の各コマンド適用を評価するときに
        第0引数として渡されるのである．
      }
    >
    +p{
      \REMAINS{コマンドが処理されるアニメーション}
    }
    +p{
      \REMAINS{let-inlineによるエイリアス定義は糖衣構文}
    }
    +p{
      \REMAINS{発展的なコマンド定義：line-break}
    }
  >
  +chapter?:(`line-breaking`){行分割処理}< #line-breaking; >
  +chapter?:(`system-and-config`){システムと設定ファイル}< #system-and-config; >
  +chapter?:(`typography`){文字組版}< #typography; >
  +chapter?:(`graphics`){グラフィックス}< #graphics; >
  +chapter?:(`math`){数式組版}<
    +p{
      主に理工系の文書をしたためる者にとって，
      数式組版機能は水や空気のように当然のものとして組版処理システムに備わっていてほしいものだ．
      \TeX;/\LaTeX;が30年の長きに亘って使われ続けてきた大きな要因のひとつが，
      誰もが納得するような品質の数式組版機能を古くから提供している
      数少ない組版処理システムだったからであることにおそらく異論はないだろう．
    }
    +p{
      \SATySFi;も，\TeX;/\LaTeX;に肩を並べられるくらいの品質の数式組版機能を提供している．
      しかも，既に\ref-chapter(`getting-started`);で見たように，
      \LaTeX;そっくりの構文で書くことができる．
      数式を多大に含む文書を執筆したいという動機で既に盛んに\LaTeX;に触れていた人にとって，
      少なくとも数式の記法が\SATySFi;への移行に関する心理的障壁となることはまずないだろう．
      本章では，\SATySFi;に備わっている数式組版機能について，詳細を追って見ていくことにしよう．
    }
    +p{
      なお，繰り返しになるが，\SATySFi;での数式の記述はコードの見た目上\LaTeX;にそっくりなものの，
      裏でやっていることは両者で全然違う．
      \LaTeX;は字句解析（トークン化）に相当する処理を組版処理と同時進行で行ない，
      かつ構文木も一切構築せずパターンマッチでトークン列を書き換えていくのに対し，
      \SATySFi;は静的に構文解析して数式を構文木の形で保持している．
    }
    +p{ \REMAINS{} }
  >
  +chapter?:(`cross-reference`){相互参照}< #cross-reference; >
  +chapter?:(`page-breaking`){ページ分割処理}< #page-breaking; >
  +chapter?:(`future-work`){Future Work}< #future-work; >
  +chapter?:(`specification`){言語仕様}< #specification; >
>
