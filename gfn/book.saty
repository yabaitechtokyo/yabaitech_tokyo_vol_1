% -*- coding: utf-8 -*-
@import: settings
@import: preface
@import: introduction
@import: getting-started
@import: alias-command-definition
@import: programming
@import: overall
@import: line-breaking
@import: system-and-config
@import: typography
@import: graphics
@import: cross-reference
@import: page-breaking
@import: future-work
@import: specification
@import: bib

document (|
  title = {The \SATySFi;book};
  author = {Takashi SUWA};
  preface = preface;
  bibliography = bibliography;
|) '<
  +chapter?:(`introduction`){\SATySFi;の開発動機}< #introduction; >
  +chapter?:(`getting-started`){\SATySFi;簡易入門}< #getting-started; >
  +chapter?:(`basic-command-definition`){コマンド定義：基礎編}<
    +p{
      \ref-chapter(`getting-started`);で\pkg{stdjareport}を用いて
      \SATySFi;の基礎的なコマンドの用法を知った．
      ところで，マークアップ言語の大きな強みのひとつは
      自前でコマンドを定義することによって
      種々の自動処理を実現したり独自の意味マークアップを規定したりできる点にあったはずである．
      実際，\codem{+chapter}とか\codem{+p}とか\codem{\\dfn}とかいった
      コマンドたちは単に\pkg{stdjareport}クラスによって定義が提供されているだけであり，
      その気になればユーザでも同様の定義を書いたりできるはずだ．
      そろそろ自前でコマンドを定義したくてうずうずしている読者も多いかと思う．
      この章では，コマンド定義のごく基礎的な方法を紹介する．
      あらかじめ言ってしまうとここでの説明はとてもアドホックなものになっており，
      \SATySFi;をよく理解されたのちにこの章を読めば
      「こんな子供騙しな説明をしていたのか」と驚かれるかもしれないが，
      読者の様々なバックグラウンドを鑑み，
      まず最初の一歩としておおまかに把握してもらうには良い説明だろうと
      判断してのことなのでご容赦願いたいと思う．
      より深い理解を獲得し，より柔軟で幅広い種類の処理をコマンドとして定義するには，
      \ref-chapter(`overall-structure`);で
      \SATySFi;が行なっている組版処理の全体像を把握した上で
      \ref-chapter(`advanced-command-definition`);に臨んでいただきたい．
    }
    +section{簡単なエイリアス}< #alias-command-definition; >
    +section{プログラミング言語としての\SATySFi;}< #programming; >
  >
  +chapter?:(`overall-structure`){文書が処理される仕組み}< #overall; >
  +chapter?:(`advanced-command-definition`){コマンド定義：発展編}<
    +p{
      \ref-chapter(`basic-command-definition`);
      で基礎的なコマンド定義の方法およびプログラミング言語としての\SATySFi;について習得し，
      \ref-chapter(`overall-structure`);で\SATySFi;の処理系の全体像，
      および各工程がどのように定式化されているかについて概観した．
      これらの前提知識を把握した下で，この章ではようやくフォントや文字色，行送りといった，
      “組版上の装飾的な視覚情報” にも関わる処理を行なうコマンドの実装方法を習得する．
    }
    +section?:(`text-processing-context`){テキスト処理文脈}<
      +p{
        \ref-chapter(`overall-structure`);でも既に述べたが，
        組版処理はインラインテキスト・ブロックテキストといった
        “テキストの情報” だけが与えられてもできない．
        すなわち，どのフォントのどんなサイズで組むか\footnote{
          活版印刷の慣習としては，“font” という語は
          各字形が同一のデザインに則っているだけでなく
          サイズも相等しいひと揃いの活字のセットを指したようだが，
          \SATySFi;でフォントと言う場合は
          （字形やそれに関するメトリックのひとかたまりに紐づけられた）フォント名，
          拡大縮小比率，ベースライン調整率
          の3つ組を指す．詳しくは\ref-chapter(`typography`);で述べる．
        }，段落の幅や行送りはどの程度の長さにするか，
        といった情報が “テキストの情報” に加えて必要である．
        これらの
        “テキストには表れていないが組版処理上必要な情報”
        を，\SATySFi;は
        \dfnje{\index(`テキスト処理文脈`){テキスト処理文脈}}{text-processing context}
        という機構に保持させて扱う．
        抽象的な説明を続けてもおそらく要領を得ないであろうから，
        具体例を用いて説明しよう．
        例えば，文字サイズを1.5倍に変更するコマンド\codem{\\enlarge}を考える：

        \d-code-and-block(```
          +p{ 内側の\enlarge{文字が\enlarge{1.5倍}の大きさに}なります． }
        ```)(open Sample in '<
          +p{ 内側の\enlarge{文字が\enlarge{1.5倍}の大きさに}なります． }
        >);%

        このような\codem{\\enlarge}は次のように定義できる：

        \d-code(```
          let-inline ctx \enlarge it =
            let size = get-font-size ctx in
            let ctx-enlarge = set-font-size (size *' 1.5) ctx in
              read-inline ctx-enlarge it
        ```);%

        唐突に全部見せられてもあまり実感が湧かないであろうから少しずつ説明するが，
        まず1行目から見慣れない文法である．
        \codem{let-inline}を用いてインラインコマンドを定義する構文は
        \ref-chapter(`basic-command-definition`);で既に紹介したが，
        ここでは\codem{let-inline}と定義されるコマンド名\codem{\\enlarge}との間に
        \codem{ctx}なる何かがある．
        実はこれこそがテキスト処理文脈を受け取る “第0引数” の変数だ．
        コマンドの適用が評価されるとき，
        ユーザが与えた通常の引数に加えて，コマンドが使われている箇所のすぐ外側の
        テキスト処理文脈がこの変数\codem{ctx}に渡され，
        コマンドの実装中で使える，というわけである．
        ここまで\pkg{stdjareport}など
        何らかのクラスファイルが提供するマークアップ等の方式に従って
        \SATySFi;を使うにあたってはテキスト処理文脈を全く意識する必要がなかったであろうけれども，
        実のところユーザからは見えない裏側で
        密かに各コマンドがテキスト処理文脈を受け渡ししていたのである．
        なお，\codem{ctx}は単に変数名なので，第0引数に\codem{x}とか\codem{y}とか
        \codem{i-love-satysfi}といった違う名前を使っても構わない\footnote{
          ただし，既存のパッケージでは慣習的に第0引数を必ず\codem{ctx}という変数名にしているので，
          複数人で開発したり，既存パッケージを改造したりする場合は
          \codem{ctx}という変数名で統一した方が理解に齟齬を生じにくいかもしれない．
        }．
      }
      +p{
        さて，続いてコマンド定義の “中身” を見てみる．
        第0引数の\codem{ctx}と（各適用でユーザが与える）第1引数\codem{it}を使うのだが，
        まず\codem{size}に
        外から渡されてきたテキスト処理文脈\codem{ctx}が保持している
        フォントサイズを取り出して束縛する．これはプリミティヴ：

        \val?:(`get-font-size`)({get-font-size})%
          (Type.(context --> length));%

        を用いて行なう．取得したフォントサイズ\codem{size}は\type(Type.(length));型であり，
        \codem{\*'}を用いて\codem{size \*' 1.5}で${1.5}倍の長さを得る．
        フォントサイズの設定は

        \val?:(`set-font-size`)({set-font-size})%
          (Type.(length --> (context --> context)));%

        を用いて行なう．
        すなわち，古いテキスト処理文脈\codem{ctx}と設定するフォントサイズ\codem{size}に対して
        \codem{set-font-size size ctx}で
        フォントサイズの更新された新しいテキスト処理文脈が返ってくる．
        \codem{\\enlarge}の実装では，この新しいテキスト処理文脈を
        変数\codem{ctx-enlarge}に束縛している．
        なお，ここの一連の処理で
        \codem{ctx}の内容が “書き換えられる” わけではないことに注意されたい．
        単に\codem{ctx}の内容のうちフォントサイズに関するデータだけが
        \codem{size}に変更された新しいテキスト処理文脈がつくられて
        \codem{ctx-enlarge}という変数に束縛されているだけである．
        実際，\codem{ctx-enlarge}が束縛されたスコープでも
        依然として\codem{ctx}を使うことができ，
        かつそのテキスト処理文脈には元々のフォントサイズが保持されている．
      }
      +p{
        最も重要なのは最終行だ．ここで使われているプリミティヴ

        \val?:(`read-inline`)({read-inline})%
          (Type.(context --> (inline-text --> inline-boxes)));%

        は\ref-chapter(`overall-structure`);で説明した
        インライン変換器に相当し，\ref-figure(`conversion-to-inline-boxes`);
        に示されたような処理をしている．すなわち，
        \codem{read-inline \meta{ctx} \meta{it}}で
        テキスト処理文脈\codem{\meta{ctx}}の保持するフォントや
        文字サイズなどの情報をもとにインラインテキスト\codem{\meta{it}}を
        インラインボックス列へと変換する．
        そしてこれがきわめて重要な事項なのだが，
        インラインテキスト\codem{\meta{it}}に含まれている
        インラインコマンドの適用が評価されるのも，
        この\codem{read-inline}によるインラインボックス列への変換の最中である．
        このとき，\codem{read-inline}に第1引数として渡したテキスト処理文脈が，
        第2引数の\codem{\meta{it}}中の各コマンド適用を評価するときに
        第0引数として渡されるのである．
        興味のある読者は，これについて\ref-chapter(`specification`);を眺めるとよいかもしれない．
      }
      +p{
        \REMAINS{コマンドが処理されるアニメーション}
      }
      +p{
        ちなみに，ここで説明の例に挙げた
        \codem{get-font-size}および\codem{set-font-size}とほぼ同様の感覚で使えるプリミティヴが
        \SATySFi;にはいくつも備わっている．この本でそれらを順を追って説明していくのだが，
        \codem{set-font-size}程度の比較的簡単な部類のものには以下がある：

        \val-explain({set-text-color})(Type.(color --> (context --> context))) {
          \codem{\meta{ctx} \|\> set-text-color \meta{color}}で
          現在の文字色を\codem{\meta{color}}に更新したテキスト処理文脈を返す．
          例えば\codem{\meta{ctx} \|\> set-text-color (RGB(0., 0., 0.5))}は
          文字を紺色で “描く” ように更新したテキスト処理文脈を返す．
        }%

        \val-explain({get-text-color})(Type.(context --> color)) {
          テキスト処理文脈に保持されている文字色を返す．
        }%
      }
    >
    +section{コマンド定義の糖衣構文}<
      +p{
        ところで，インラインコマンドを定義する構文：

        \d-codem{
          let-inline \meta{ctx} \meta{cmd} \metasub(${1}){x} ${\cdots} \metasub(${n}){x} = \meta{expr}
        }%

        は\ref-chapter(`basic-command-definition`);で解説したlet式と同様に

        \d-codem{
          let-inline \meta{ctx} \meta{cmd} =
            (fun \metasub(${1}){x} ${\cdots} \metasub(${n}){x} -\> \meta{expr})
        }%

        の糖衣構文である．これはあまり意識する必要はないが，知っていると部分適用などを駆使して
        コマンド適用が簡潔に書けたりして便利である．
        より詳しく知りたい場合は\ref-chapter(`specification`);を参照されたい．

        さらに言うと，おそらくこちらは少し意外に感じられるかと思うが，
        \ref-chapter(`basic-command-definition`);で登場した
        テキスト処理文脈を受け取らない\codem{let-inline}によるコマンド定義の構文：

        \d-codem{
          let-inline \meta{cmd} \metasub(${1}){x} ${\cdots} \metasub(${n}){x} = \meta{expr}
        }%

        は，実は

        \d-codem{
          let-inline \meta{ctx} \meta{cmd} =
            (fun \metasub(${1}){x} ${\cdots} \metasub(${n}){x} -\>
              read-inline \meta{ctx} \meta{expr})
        }%

        の糖衣構文である．ただし，\codem{\meta{ctx}}は\codem{\meta{expr}}に自由出現しない変数名を
        ひとつ選んだものである．
        要するに外から渡されるテキスト処理文脈を
        そのままインラインテキスト\codem{\meta{expr}}のインライン変換に使うだけ，ということである．
        こちらの第0引数を取らない構文は
        \codem{=}より前に書いてある変数の個数で\codem{read-inline}が “挿入” される場所が
        決定されるので，

        \d-codem{
          let-inline \meta{cmd} =
            (fun \metasub(${1}){x} ${\cdots} \metasub(${n}){x} -\> \meta{expr})
        }%

        と書いても意図通りには脱糖衣されないことに注意されたい．
      }
    >
    +section{行分割を行なうコマンド}<
      +p{
        行分割処理に相当するプリミティヴは

        \val({line-break})(Type.(bool --> (bool --> (context --> (inline-boxes --> block-boxes)))));%

        である．これは
        \codem{line-break \metasub(${1}){b} \metasub(${2}){b} \meta{ctx} \meta{ib}}
        の形で使われ，行分割された結果であるブロックボックス列を返してくれる．
        引数はそれぞれ以下を指示する\footnote{
          このインターフェイスは設計した著者もあまり美しいとは思えないのだが，
          頻出のプリミティヴであるため互換性の都合上存続している．
          将来の非互換なヴァージョンで姿を変えるかもしれない．
        }：

        \listing{
          * \codem{\metasub(${1}){b}}；\quad;
            は組み上がった段落の直前でページ分割してよいか否か

          * \codem{\metasub(${2}){b}}：\quad;
            組み上がった段落の直後でページ分割してよいか否か

          * \codem{\meta{ctx}}；\quad;
            行長や行送りなどを取り出すためのテキスト処理文脈

          * \codem{\meta{ib}}：\quad;
            行分割対象となるインラインボックス列
        }%

        \codem{\metasub(${1}){b}}および\codem{\metasub(${2}){b}}は
        あくまで組み上がった段落の前後でページ分割してよいかどうかの指定であり，
        段落中での改ページには干渉しないことに注意されたい．
        典型的な利用場面としては，
        章節の題の直後で改ページされないように指定することなどが挙げられる．
        この文脈で「段落」が指すのはあくまで “文字が適切に行分割されて行が連なったもの” であり，
        文書上のマークアップで段落と扱われるデータであるとは限らない．
        章題も文字が一度行方向に並べられ，
        （ほとんどの場合は1箇所も行分割されないとはいえ，形式上は）行分割処理を経て
        行がページの進行方向に連なるものへと組み上げられた結果という意味では
        立派な「段落」なのである．
      }
      +p{
        行分割が実際にどのようなアルゴリズムで行なわれるかについては
        \ref-chapter(`line-breaking`);を参照してもらうとして，
        ここでは行分割処理が “インターフェイスとしてどのように使えるのか” を扱う．
        和文組版での段落を組むブロックコマンド\codem{+p}の，
        最もシンプルな定義は次のようなものだ：

        \d-code(```
          let-block ctx +p it-inner =
            let ib-indent = inline-skip (get-font-size ctx *' 0.88) in
            let ib-inner = read-inline ctx it-inner in
              line-break true true ctx
                (ib-indent ++ ib-inner ++ inline-fil)
        ```);%

        \codem{+p}はユーザが与える引数\codem{it-inner}としてインラインテキストを受け取る．
        最初に定義している\codem{ib-indent}は
        いわゆる字下げのための “白いインラインボックス列” だ\footnote{
          活版印刷でいうところの\dfn{クワタ}の役割をするものである．
        }．これの定義には

        \val({inline-skip})(Type.(length --> inline-boxes));%

        というプリミティヴを用いている．\codem{inline-skip \meta{l}}という形で使い，
        長さ\codem{\meta{l}}だけ文字の進行方向に幅をもつ，伸縮しない空白をつくる\footnote{
          何らかの “許容範囲” で伸縮する空白は
          \codem{inline-glue}というプリミティヴを用いてつくる．
          これについては\ref-chapter(`line-breaking`);を参照されたい．
        }．ここの例で与えられている長さは
        \codem{get-font-size}を用いて取得した現在の文字サイズを${0.88}倍したものである．
        ${0.88}という数字を決め打ちでハードコードしてしまっているが，
        これは欧文に対する和文のデフォルトの\dfn{拡大率}を表している．
        フォントに於ける拡大率の概念については
        \ref-chapter(`system-and-config`);および\ref-chapter(`typography`);で扱うので，
        今は特に気にしなくてよい．
        こうして段落の字下げ部分ができたところで，
        続いて段落の本領であるテキスト内容の処理にとりかかる．
        ここはそれほど変哲はなく，前述の\codem{read-inline}と現在の文脈\codem{ctx}を用いて
        インラインテキスト\codem{it-inner}を “字幅などをもつ，組める状態” である
        インラインボックス列へと変換し，変数\codem{ib-inner}をそれに束縛する．
      }
      +p{
        最後はこれらをつなげて行分割して仕上げである．
        インラインボックス列同士を結合させる処理は

        \val({++})(Type.(inline-boxes --> (inline-boxes --> inline-boxes)));%

        というプリミティヴによって行なう．これを用いて
        \codem{ib-indent ++ ib-inner}
        とすることで，行分割して段落に組み上げたい内容が完成する．
        と言いたいところだが，
        実はこれを\codem{line-break}の第4引数として渡すと意図どおりにはならない．
        というのも，\codem{line-break}が行なうのは
        “各行を最後の端まで使い切っている段落への整形” だからだ．
        つまり，\codem{ib-indent ++ ib-inner}を
        \codem{line-break}の第4引数に渡すと，
        最終行も行長いっぱいに伸びるように組まれた段落になっている
        ブロックボックス列が返ってくる．
        たしかに段落の最終行が行長に対してかなり短いものは
        \dfnje{オーファン}{orphan}と呼ばれて避けられるので，
        極端に短い最終行がない段落という意味では良いかもしれないが，
        常に最終行を最後までぴっちりと行長を使い切って組むことは全く意図していない．
        「最終行は途中でも終わってよい」ということを
        行分割処理を行なう機構に教えてあげるにはどうすればよいのだろう？\quad;
        こういった使えるのが次のプリミティヴである：

        \val({inline-fil})(Type.(inline-boxes));%

        これは “途中で行分割されることはないが，
        周囲の要請に応じてどこまでも伸ばせる，任意の非負の長さをもてる空白” である\footnote{
          \TeX;ユーザなら，\code(`\fil`);に相当する機構だと言えば
          おそらくすぐわかるだろう．ちなみに現在のところは\code(`\fill`);に相当する機構，
          つまり “より強い無限身長グルー” は\SATySFi;には備わっていない．
        }．
        これをインラインボックス列の最後に結合させることで，
        「最終行は途中のどこで終わってもよい」ということを行分割処理を担う機構に間接的に教えられるのである．
        したがって行分割させるインラインボックス列は
        \codem{ib-indent ++ ib-inner ++ inline-fil}
        ということになる．
        この\codem{+p}の使用例はあらためて掲げる必要もないだろう．
        この本の本文中の段落は上に掲げた定義と本質的に同等な定義の\codem{+p}を用いて組まれており，
        いたるところに使用例があるからだ．以上が行分割処理の非常にオーソドックスな用例である．
      }
    >
  >
  +chapter?:(`line-breaking`){行分割処理}< #line-breaking; >
  +chapter?:(`system-and-config`){システムと設定ファイル}< #system-and-config; >
  +chapter?:(`typography`){文字組版}< #typography; >
  +chapter?:(`graphics`){グラフィックス}< #graphics; >
  +chapter?:(`math`){数式組版}<
    +p{
      主に理工系の文書をしたためる者にとって，
      数式組版機能は水や空気のように当然のものとして組版処理システムに備わっていてほしいものだ．
      \TeX;/\LaTeX;が30年の長きに亘って使われ続けてきた大きな要因のひとつが，
      誰もが納得するような品質の数式組版機能を古くから提供している
      数少ない組版処理システムだったからであることにおそらく異論はないだろう．
    }
    +p{
      \SATySFi;も，\TeX;/\LaTeX;に肩を並べられるくらいの品質の数式組版機能を提供している．
      しかも，既に\ref-chapter(`getting-started`);で見たように，
      \LaTeX;そっくりの構文で書くことができる．
      数式を多大に含む文書を執筆したいという動機で既に盛んに\LaTeX;に触れていた人にとって，
      少なくとも数式の記法が\SATySFi;への移行に関する心理的障壁となることはまずないだろう．
      本章では，\SATySFi;に備わっている数式組版機能について，詳細を追って見ていくことにしよう．
    }
    +p{
      なお，繰り返しになるが，\SATySFi;での数式の記述はコードの見た目上\LaTeX;にそっくりなものの，
      裏でやっていることは両者で全然違う．
      \LaTeX;は字句解析（トークン化）に相当する処理を組版処理と同時進行で行ない，
      かつ構文木も一切構築せずパターンマッチでトークン列を書き換えていくのに対し，
      \SATySFi;は静的に構文解析して数式を構文木の形で保持している．
    }
    +p{ \REMAINS{} }
  >
  +chapter?:(`cross-reference`){相互参照}< #cross-reference; >
  +chapter?:(`page-breaking`){ページ分割処理}< #page-breaking; >
  +chapter?:(`future-work`){Future Work}< #future-work; >
  +chapter?:(`specification`){言語仕様}< #specification; >
>
