% -*- coding: utf-8 -*-
@import: settings
@import: preface
@import: introduction
@import: getting-started
@import: alias-command-definition
@import: overall
@import: bib

document (|
  title = {The \SATySFi;book};
  author = {T. Suwa};
  preface = preface;
  bibliography = bibliography;
|) '<
  +chapter?:(`introduction`){\SATySFi;の開発動機}< #introduction; >
  +chapter?:(`getting-started`){\SATySFi;簡易入門}< #getting-started; >
  +chapter?:(`basic-command-definition`){コマンド定義：基礎編}<
    +p{
      \ref-chapter(`getting-started`);で\pkg{stdjareport}を用いて
      \SATySFi;の基礎的なコマンドの用法を知った．
      ところで，マークアップ言語の大きな強みのひとつは
      自前でコマンドを定義することによって
      種々の自動処理を実現したり独自の意味マークアップを規定したりできる点にあったはずである．
      実際，\codem{+chapter}とか\codem{+p}とか\codem{\\dfn}とかいった
      コマンドたちは単に\pkg{stdjareport}クラスによって定義が提供されているだけであり，
      その気になればユーザでも同様の定義を書いたりできるはずだ．
      そろそろ自前でコマンドを定義したくてうずうずしている読者も多いかと思う．
      この章では，コマンド定義のごく基礎的な方法を紹介する．
      あらかじめ言ってしまうとここでの説明はとてもアドホックなものになっており，
      \SATySFi;をよく理解されたのちにこの章を読めば
      「こんな子供騙しな説明をしていたのか」と驚かれるかもしれないが，
      読者の様々なバックグラウンドを鑑み，
      まず最初の一歩としておおまかに把握してもらうには良い説明だろうと
      判断してのことなのでご容赦願いたいと思う．
      より深い理解を獲得し，より柔軟で幅広い種類の処理をコマンドとして定義するには，
      \ref-chapter(`overall-structure`);で
      \SATySFi;が行なっている組版処理の全体像を把握した上で
      \ref-chapter(`advanced-command-definition`);に臨んでいただきたい．
    }
    +section{簡単なエイリアス}< #alias-command-definition; >
    +section{プログラミング言語としての\SATySFi;}<
      +p{
        既に述べたように，\SATySFi;はいわゆる函数型らしい特徴を兼ね備えた
        組版処理向けのマークアップ言語である．
        むしろ，より正確を期して言い表すならば
        函数型言語の上に組版処理用の種々の言語機能が分厚く搭載された
        DSL（domain-specific language, 領域特化言語）だ．
        プログラミング言語としての\SATySFi;の基礎的部分には
        OCamlに大変よく似た体系が採用されており，
        基礎的部分の理解を得るのにOCamlに関する参考書で代用することも十分可能なほどである．
        とはいえ，OCamlなどの他言語から回り道せずとも\SATySFi;での最低限の直観を身につければ
        十分\SATySFi;でのプログラミングが可能であり，
        熱心に函数型プログラミングの基礎を習得したい読者ばかりではないであろうから，
        ここでも簡単にプログラミング言語としての\SATySFi;について解説する．
        また，OCamlと\SATySFi;との間には目的意識や美意識の違いに起因した多少の差異があるので，
        これについて（既にOCamlで流暢にプログラミングできる読者に対しても）簡単に補足する．
      }
      +p{
        \REMAINS{プログラミングの解説}
      }
    >
  >
  +chapter?:(`overall-structure`){文書が処理される仕組み}< #overall; >
  +chapter?:(`type-system`){型システム}<
    +p{
      既に\ref-chapter(`introduction`);で述べたとおり，
      \SATySFi;の最大の特徴は型検査器を備えているおかげで
      或る種の入力の誤りを実際に組版処理を始めるよりも前に検出してすばやく報告できることにある．
      本章では，この型検査器を実現している型システムについて見ていくことにしよう．
    }
    +p{ \REMAINS{} }
  >
  +chapter?:(`advanced-command-definition`){コマンド定義：発展編}<
    +p{
      \ref-chapter(`basic-command-definition`);
      で基礎的なコマンド定義の方法およびプログラミング言語としての\SATySFi;について習得し，
      \ref-chapter(`overall-structure`);で\SATySFi;の処理系の全体像，
      および各工程がどのように定式化されているかについて概観した．
      これらの前提知識を把握した下で，この章ではようやくフォントや文字色，行送りといった，
      “組版上の装飾的な視覚情報” にも関わる処理を行なうコマンドの実装方法を習得する．
    }
    +section?:(`text-processing-context`){テキスト処理文脈}<
      +p{
        \ref-chapter(`overall-structure`);でも既に述べたが，
        組版処理はインラインテキスト・ブロックテキストといった
        “テキストの情報” だけが与えられてもできない．
        すなわち，どのフォントのどんなサイズで組むか\footnote{
          活版印刷の慣習としては，“font” という語は
          各字形が同一のデザインに則っているだけでなく
          サイズも相等しいひと揃いの活字のセットを指したようだが，
          \SATySFi;でフォントと言う場合は
          （字形やそれに関するメトリックのひとかたまりに紐づけられた）フォント名，
          拡大縮小比率，ベースライン調整率
          の3つ組を指す．詳しくは\ref-chapter(`typography`);で述べる．
        }，段落の幅や行送りはどの程度の長さにするか，
        といった情報が “テキストの情報” に加えて必要である．
        これらの
        “テキストには表れていないが組版処理上必要な情報”
        を，\SATySFi;は
        \dfnje{\index(`テキスト処理文脈`){テキスト処理文脈}}{text-processing context}
        という機構に保持させて扱う．
        抽象的な説明を続けてもおそらく要領を得ないであろうから，
        具体例を用いて説明しよう．
        例えば，文字サイズを1.5倍に変更するコマンド\codem{\\enlarge}を考える：

        \d-code-and-block(```
          +p{ 内側の\enlarge{文字が\enlarge{1.5倍}の大きさに}なります． }
        ```)(open Sample in '<
          +p{ 内側の\enlarge{文字が\enlarge{1.5倍}の大きさに}なります． }
        >);%

        このような\codem{\\enlarge}は次のように定義できる：

        \d-code(```
          let-inline ctx \enlarge it =
            let size = get-font-size ctx in
            let ctx-enlarge = set-font-size (size *' 1.5) ctx in
              read-inline ctx-enlarge it
        ```);%

        唐突に全部見せられてもあまり実感が湧かないであろうから少しずつ説明するが，
        まず1行目から見慣れない文法である．
        \codem{let-inline}を用いてインラインコマンドを定義する構文は
        \ref-chapter(`basic-command-definition`);で既に紹介したが，
        ここでは\codem{let-inline}と定義されるコマンド名\codem{\\enlarge}との間に
        \codem{ctx}なる何かがある．
        実はこれこそがテキスト処理文脈を受け取る “第0引数” の変数だ．
        コマンドの適用が評価されるとき，
        ユーザが与えた通常の引数に加えて，コマンドが使われている箇所のすぐ外側の
        テキスト処理文脈がこの変数\codem{ctx}に渡され，
        コマンドの実装中で使える，というわけである．
        ここまで\pkg{stdjareport}など
        何らかのクラスファイルが提供するマークアップ等の方式に従って
        \SATySFi;を使うにあたってはテキスト処理文脈を全く意識する必要がなかったであろうけれども，
        実のところユーザからは見えない裏側で
        密かに各コマンドがテキスト処理文脈を受け渡ししていたのである．
        なお，\codem{ctx}は単に変数名なので，第0引数に\codem{x}とか\codem{y}とか
        \codem{i-love-satysfi}といった違う名前を使っても構わない\footnote{
          ただし，既存のパッケージでは慣習的に第0引数を必ず\codem{ctx}という変数名にしているので，
          複数人で開発したり，既存パッケージを改造したりする場合は
          \codem{ctx}という変数名で統一した方が理解に齟齬を生じにくいかもしれない．
        }．
      }
      +p{
        さて，続いてコマンド定義の “中身” を見てみる．
        第0引数の\codem{ctx}と（各適用でユーザが与える）第1引数\codem{it}を使うのだが，
        まず\codem{size}に
        外から渡されてきたテキスト処理文脈\codem{ctx}が保持している
        フォントサイズを取り出して束縛する．これはプリミティヴ：

        \val?:(`get-font-size`)({get-font-size})%
          (Type.(context --> length));%

        を用いて行なう．取得したフォントサイズ\codem{size}は\type(Type.(length));型であり，

        \val?:(`*'`)({(\*')})(Type.(length --> (float --> length)));%

        を用いて\codem{size \*' 1.5}で${1.5}倍の長さを得る．
        フォントサイズの設定は

        \val?:(`set-font-size`)({set-font-size})%
          (Type.(length --> (context --> context)));%

        を用いて行なう．
        すなわち，古いテキスト処理文脈\codem{ctx}と設定するフォントサイズ\codem{size}に対して
        \codem{set-font-size size ctx}で
        フォントサイズの更新された新しいテキスト処理文脈が返ってくる．
        \codem{\\enlarge}の実装では，この新しいテキスト処理文脈を
        変数\codem{ctx-enlarge}に束縛している．
        なお，ここの一連の処理で
        \codem{ctx}の内容が “書き換えられる” わけではないことに注意されたい．
        単に\codem{ctx}の内容のうちフォントサイズに関するデータだけが
        \codem{size}に変更された新しいテキスト処理文脈がつくられて
        \codem{ctx-enlarge}という変数に束縛されているだけである．
        実際，\codem{ctx-enlarge}が束縛されたスコープでも
        依然として\codem{ctx}を使うことができ，
        かつそのテキスト処理文脈には元々のフォントサイズが保持されている．
      }
      +p{
        最も重要なのは最終行だ．ここで使われているプリミティヴ

        \val?:(`read-inline`)({read-inline})%
          (Type.(context --> (inline-text --> inline-boxes)));%

        は\ref-chapter(`overall-structure`);で説明した
        インライン変換器に相当し，\ref-figure(`conversion-to-inline-boxes`);
        に示されたような処理をしている．すなわち，
        \codem{read-inline \meta{ctx} \meta{it}}で
        テキスト処理文脈\codem{\meta{ctx}}の保持するフォントや
        文字サイズなどの情報をもとにインラインテキスト\codem{\meta{it}}を
        インラインボックス列へと変換する．
        そしてこれがきわめて重要な事項なのだが，
        インラインテキスト\codem{\meta{it}}に含まれている
        インラインコマンドの適用が評価されるのも，
        この\codem{read-inline}によるインラインボックス列への変換の最中である．
        このとき，\codem{read-inline}に第1引数として渡したテキスト処理文脈が，
        第2引数の\codem{\meta{it}}中の各コマンド適用を評価するときに
        第0引数として渡されるのである．
      }
    >
    +p{
      \REMAINS{コマンドが処理されるアニメーション}
    }
    +p{
      \REMAINS{let-inlineによるエイリアス定義は糖衣構文}
    }
    +p{
      \REMAINS{発展的なコマンド定義：line-break}
    }
  >
  +chapter?:(`line-breaking`){行分割処理}<
    +section{行分割処理の概要}<
      +p{
        行分割処理に於いて，見た目が十分整うように行を段落に切り分けるのはそれほど自明ではない．
        まずは行を切り分けて良い箇所の決定である．
        例えばラテン文字やキリル文字といった “欧文” は基本的に

        \listing{
          * 単語間の空白
          * ハイフネーション上許容される単語の途中の箇所
        }%

        のいずれかでしか行を分けてはいけないという制約があるし，
        和文でも

        \listing{
          * 開き括弧の直後
          * 小書きの「っ」や音引き「ー」の直前
        }%

        など，行を分けてはいけない箇所の “規定” がいくらかある．
        このほか，例えば読点の直後で行を分けた場合は行の途中の読点とは違って
        読点の後ろに2分アキを入れない，
        つまりいわゆる “全角幅” の半分の空白を設けないなどといった，
        行末が揃っているように見せるための “規則” もある．
        こういった，行を切り分けてよい箇所・いけない箇所の区別と切り分けた場合の特別な処理を
        \SATySFi;で実装するにあたっては，
        まず多言語対応の組版を意図して
        \dfn{Unicode Line Breaking Algorithm} \cite[`unicode-lb`]; に
        原則従うことにし，
        特にひとまず和文・欧文の混植を優先して実現することを目的としていたので
        この和文の組版規則については『\dfn{日本語組版処理の要件}』\cite[`jlreq`];，
        通称\dfn{JLreq}にできるだけ従って実装した．
        ハイフネーションについては，やはり偉大な先駆者である\TeX;処理系に倣って
        \dfn{Liang–Knuthアルゴリズム} \cite[`liang-knuth`]; をもとに実装した．
      }
      +p{
        また実際に切り分ける箇所を決定する処理も自明ではない．
        前から順に詰められるだけ詰めて切り分けるという単純な貪欲アルゴリズムでは
        後ろの行が前に比べて過度に間延びして美しく見えないような出力もできてしまうから，
        “段落全体を見渡してから行分割箇所を決める” ような処理を効率的に行なう必要があるのである．
        この行分割に関しては，\dfn{Knuth–Plassアルゴリズム} \cite[`knuth-plass`]; と呼ばれる，
        \TeX;で採用されたものとおおよそ同様の処理を独自に拡張して用いることにした．
        このアルゴリズムでは，端的に言えば
        \dfn{最短経路問題}に帰着することで適切な行分割箇所を選んでいる．
        独自に拡張したのは，\inline-frame{\inline-frame{入れ子になった枠}のついた部分でも
        途中で行分割できるようにしたこと}に関してである．
      }
    >
    +section{行分割に関するプリミティヴ}<
      +subsection{行分割候補箇所}<
        +p{
          \ref-chapter(`advanced-command-definition`);に於いて，
          行分割処理そのものを担うプリミティヴが

          \val?:(`line-break`)({line-break})(Type.(bool --> (bool -->
            (context --> (inline-boxes --> block-boxes)))));%

          であることは既に紹介したが，分割される箇所の候補がどのように決定され，
          その処理にユーザやパッケージ開発者がどのように介入できるかについてはまだ触れていなかった．
          これについて以下で少し解説する．
        }
        +p{
          \SATySFi;では，行分割の候補となる箇所がインラインボックス列の中に含まれており，
          そのいずれも

          \listing{
            * そこで行分割されなかった場合の内容 ${b_0}
            * そこで行分割された場合に直前の行末に入る内容 ${b_1}
            * そこで行分割された場合に直後の行頭に入る内容 ${b_2}
            * そこで行分割された場合に加算される
              \dfnje{\index(`ペナルティチ`){ペナルティ値}}{penalty} ${p}
          }%

          からなる4つの情報 ${\tuple{|b_0|b_1|b_2|p|}} をもつ．
          逆に，これらの情報をもたない箇所では行分割しない\footnote{
            厳密に言うと例外がある．
            ブロックボックス列を “段落の一部として埋め込む” 機能を担う
            \codem{embed-block-breakable}というプリミティヴによって
            生成されたインラインボックス列は，その直前で必ず行分割される．
          }．
          この4つ組を備えた箇所を以降
          単に\dfnje{
            \index(`ギョウブンカツコウホカショ`){行分割候補箇所}
          }{line break opportunity}
          と呼ぶことにしよう．
          ペナルティ値は実際の行分割箇所を決定するにあたって参考にされ，
          この値が大きいほどその候補箇所での行分割が抑制される\footnote{
            一応（行分割を促進する意図で）負の値を指定することもできるが，
            現在の実装は負の値が渡されることを想定していないので，
            行分割が実際に促進される保証はない．
          }．これについては\ref-subsection(`penalty`);で後述する．
        }
        +p{
          行分割候補箇所は，
          インラインテキストからインラインボックス列に変換する過程で現れる．
          この際に，例えば空白文字は
          ${b_0} が（単語間の空白として適切な程度に）多少伸縮する空白，
          ${b_1} と ${b_2} が空っぽであるような行分割候補箇所に変換される．
          “table” という文字列は，
          ${b_0} が
          \as-latin-word{\BoxGraphics.roman{|t|a|b|l|e|}}，
          ${b_1} が
          \as-latin-word{\BoxGraphics.roman{|t|a|-|}}，
          ${b_2} が
          \as-latin-word{\BoxGraphics.roman{|b|l|e|}}
          であるような行分割候補箇所へと変換される．
          すなわち，途中で行分割する必要がなければ単に行中で
          \as-latin-word{\BoxGraphics.roman{|t|a|b|l|e|}}と組まれるように，
          途中でハイフネーションを行なって分割する方が周辺の要素の並びから望ましいと判断される場合は
          その行末が\as-latin-word{\BoxGraphics.roman{|t|a|-|}}で
          次の行頭が\as-latin-word{\BoxGraphics.roman{|b|l|e|}}になるように，
          それぞれ指定した行分割候補箇所になるのである\footnote{
            実際のハイフネーション処理はもう少しだけ複雑である．
            単語中でハイフネーションが可能な箇所は2箇所以上あったりするからだ．
          }．
          インラインテキストがどのようにインラインボックス列に変換され，
          どのように行分割候補箇所が現れるかは，
          前述のとおり基本的には
          Unicode Line Breaking Algorithm \cite[`unicode-lb`];
          と『日本語組版処理の要件』\cite[`jlreq`];に基づいているが，
          多言語組版を想定して将来的には
          ユーザやパッケージ開発者が介入して変更できるようにしたいと考えている．
        }
        +p{
          行分割候補箇所はインラインテキストからインラインボックス列への変換過程で生成されるだけでなく，
          “手動で” 挿入することもできる．これに用いるのがプリミティヴ：

          \val?:(`discretionary`)({discretionary})(Type.(int -->
            (inline-boxes --> (inline-boxes --> (inline-boxes --> inline-boxes)))));%

          である．使い方は至極単純で，
          \codem{discretionary \meta{p}
            \metasub(${0}){ib} \metasub(${1}){ib} \metasub(${2}){ib}}
          でペナルティ値 ${p} が\codem{\meta{p}}，
          各 ${b_i} がそれぞれ\codem{\metasub(${i}){ib}}であるような
          行分割候補箇所が生成される．
          なお，\codem{discretionary}の引数に渡した\codem{\metasub(${i}){ib}}の中に
          さらに入れ子で行分割候補箇所が含まれている場合，
          その箇所では決して行分割されない．つまり，そこでは必ず ${b_0} の内容が選ばれる．
        }
      >
      +subsection?:(`penalty`){ペナルティ値}<
        +p{
          インラインテキストからインラインボックス列への変換の過程で
          与えられる各行分割候補箇所のペナルティ値 ${p} は，基本的に
          \codem{read-inline}の第1引数として渡したテキスト処理文脈に基づいて決定される．
          単語間空白から変換される行分割候補箇所 ${\tuple{|p|b_0|b_1|b_2|}} は，
          デフォルトでは\footnote{
            プリミティヴ
            \index(`get-initial-context`)?:({\code(`get-intial-context`);}){
              \codem{get-initial-context}
            }が返すテキスト処理文脈では，の意．
          } ${p = 100} であり，${b_1} と ${b_2} は空である．
          ${b_0} は伸縮する空白であり，\dfnje{\index(`グルー`){グルー}}{glue}と呼ばれる．
          これについては\ref-subsection(`glue`);で後述する．
          ${p} はプリミティヴ：

          \val?:(`set-word-break-penalty`)({set-word-break-penalty})%
            (Type.(int --> (context --> context)));%

          により変更することができる．すなわち，
          テキスト処理文脈\codem{\meta{ctx}}と
          単語間空白の行分割候補箇所に対して設定したいペナルティ値\codem{\meta{p}}に対して
          \codem{set-word-break-penalty \meta{p} \meta{ctx}}で
          ペナルティ値が\codem{\meta{p}}に更新されたテキスト処理文脈が返される．
          ${b_1} と ${b_2} も変更することができ，

          \val?:(`set-every-word-break`)({set-every-word-break})%
            (Type.(inline-boxes --> (inline-boxes --> (context --> context))));%

          によって行なう．すなわち
          \codem{set-every-word-break \metasub(${1}){ib} \metasub(${2}){ib}}
          で\codem{\metasub(${i}){ib}}をそれぞれ
          単語間空白の行分割候補箇所の ${b_i} に設定する．
          現在単語間空白の ${b_1} と ${b_2} に設定されている内容を取得するのは

          \val?:(`get-every-word-break`)({get-every-word-break})%
            (Type.(context --> product [inline-boxes; inline-boxes]));%

          による．
          \REMAINS{行分割に於けるペナルティ}
        }
        +example{
          フランス語の表記の或る流儀では，
          引用符であるギュメに囲まれた部分が複数行に亘って続く場合，
          2行目以降の先頭にも開く側の引用符を置く．
          このような処理を自動でやってくれる引用符のコマンド，
          すなわち以下のような記述と組版結果を実現するような
          コマンド\codem{\\q}を定義したい：

          \d-code-and-block(```
            +p{
              \q{
                The original problem to be solved was
                for fine French typesetting,
                in which guillemets are placed
                running down the left side of a paragraph,
                as in this paragraph,
                so long as material is being quoted.
              }
              Since \TeX; breaks paragraphs in arbitrary places,
              it was impossible to develop a robust macro package
              that could, in a single pass, place the guillemets
              in the right positions.
            }
          ```)(open Sample in '<
            +p-alph{
              \q{
                The original problem to be solved was
                for fine French typesetting,
                in which guillemets are placed
                running down the left side of a paragraph,
                as in this paragraph,
                so long as material is being quoted.
              }
              Since \TeX; breaks paragraphs in arbitrary places,
              it was impossible to develop a robust macro package
              that could, in a single pass, place the guillemets
              in the right positions.
            }
          >);%

          これは\codem{set-every-word-break}を使えばおおよそ実現できる：

          \d-code(```
            let-inline ctx \q inner =
              let ib-after = read-inline ctx {«\ } in
              let ctxq =
                ctx |> set-every-word-break inline-nil ib-after
              in
                read-inline ctxq {« #inner; »}
          ```);%

          要するに「単語間空白で行分割された場合は次の行頭にギュメの開く側をつける」という指示を
          ギュメの内側のインラインテキストを変換するときに使うテキスト処理文脈に与えることで
          所望の処理を実現している．
          \REMAINS{ハイフネーションの場合}
        }
        +p{
          ハイフネーションによるペナルティもテキスト処理文脈が保持しており，単語間空白と同様に

          \val?:(`set-hyphen-penalty`)({set-hyphen-penalty})%
            (Type.(int --> (context --> context)));%

          によって変更することができる．
          デフォルトでは ${100} に設定されている．
        }
      >
      +subsection?:(`glue`){グルー}<
        +p{
          行分割の際，単語間の空白や和文の文字の間などの箇所は
          両端を揃えるために多少伸縮するのであった．
          これは\dfnje{\index(`グルー`){グルー}}{glue}と呼ばれる仕組みによって実装されている．
          グルーは

          \listing{
            * 自然な長さ ${l_0}
            * 収縮の基準となる非負の長さ ${l_1}
            * 伸長の基準となる非負の長さ ${l_2}
          }%

          の3つの情報 ${\tuple{|l_0|l_1|l_2|}} からなっている．
          インラインテキストからインラインボックス列へ変換される過程で
          単語間空白などから生じるが，
          プリミティヴ：

          \val?:(`inline-glue`)({inline-glue})%
            (Type.(length --> (length --> (length --> inline-boxes))));%

          を用いて “手づくりする” こともできる．すなわち
          \codem{inline-glue
            \metasub(${0}){l} \metasub(${1}){l} \metasub(${2}){l}}
          で各 ${l_i} が\codem{\metasub(${i}){l}}のグルーが返される．
          なお，段落先頭の字下げなど伸縮せず一定の長さのものは
          \dfnje{スキップ}{skip}と呼ばれ\footnote{
            \dfnje{カーン}{kern}と呼ばれることの方が一般的かもしれないが，
            現在の\SATySFi;では慣習的にスキップと呼んでいる．
          }，プリミティヴ：

          \val?:(`inline-skip`)({inline-skip})%
            (Type.(length --> inline-boxes));%

          でつくることができる\footnote{
            生成されるインラインボックス列の内部表現が異なるものの，
            振舞いの上では\codem{inline-skip \meta{l}}は
            \codem{inline-glue \meta{l} 0pt 0pt}と等価である．
            このため，\codem{inline-skip}は
            将来的にプリミティヴからパッケージで定義される函数へと “降格” するかもしれない．
          }．
          \REMAINS{グルーからのバッドネスの算出}
        }
        +p{
          インラインテキストがインラインボックス列に変換される過程で
          単語間空白がどのようなグルーに変換されるかは，
          \codem{read-inline}に第1引数として渡されたテキスト処理文脈が保持している
          フォントサイズ ${s} および
          浮動小数点数のパラメータ ${r_0}，${r_1}，${r_2} によって決まり，
          それぞれ ${l_i \defeq r_i s} で定められる．
          デフォルトでは ${r_0 = 0.33}，${r_1 = 0.08}，${r_2 = 0.16}
          になっているが，プリミティヴ：

          \val?:(`set-space-ratio`)({set-space-ratio})%
            (Type.(float --> (float --> (float --> (context --> context)))));%

          によって変更できる．すなわち
          \codem{set-space-ratio
            \metasub(${0}){r} \metasub(${1}){r} \metasub(${2}){r} \meta{ctx}}
          でテキスト処理文脈\codem{\meta{ctx}}を
          各 ${r_i} が\codem{\metasub(${i}){r}}になるように更新したものを返す．
        }
      >
      +p{ \REMAINS{inline-fil} }
    >
  >
  +chapter?:(`typography`){文字組版}<
    +p{
      文字は組版処理の主役であり，そして最も人間くささゆえの複雑性を備えた組版処理対象だ．
    }
    +p{ \REMAINS{} }
  >
  +chapter?:(`graphics`){グラフィックス}<
    +p{
      版面を構成する文字以外の要素で重要なのがグラフィックスである．
      本章では，本文の囲み枠，表の罫線，幾何図形，直交座標系のグラフ，グラフ理論のグラフ，可換図式，
      さらには数式中の “連続的に伸縮する” 括弧といった多様な対象を描画する用途で活用できる
      \SATySFi;のグラフィックスの機能について紹介する．
      一読すればわかるようにグラフィックス用のプリミティヴは非常にプリミティヴなのだが，
      そのプリミティヴさゆえに，思い立てばユーザの手によって非常に柔軟な描画が指定できる．
      また，頻出する図形や囲み枠の指定については
      \pkg{gr}，\pkg{deco}，\pkg{hdecoset}，\pkg{vdecoset}
      などのライブラリで提供されており，図形定義に活用できる．
    }
    +section{パス}<
      +p{
        \dfnje{\index(`パス`){パス}}{path}は
        曲線や閉曲線およびそれが占める領域を定めた情報であり，
        グラフィックスを構成する最も基本的な単位だ．
        パスの構築は

        \listing{
          * \index(`point`){\type(Type.(point));型}：
              \type(Type.(product [length; length]));と同義，
              “${2} 次元座標” や “${2} 次元ベクトル” の型として使う
        }

        という型シノニムと

        \listing{
          * \index(`pre-path`){\type(Type.(pre-path));型}：
              \dfnje{\index(`ミカンパス`){未完パス}}{pre-path}，
              すなわちまだ閉じたり終了したりしていない伸ばす途中のパスの型
          * \index(`path`){\type(Type.(path));}型：
              完成したパスの型
        }%

        という2つの基本型を用いて，以下に挙げるようなプリミティヴで行なう．
        座標はページの左下を ${\tuple{|0|0|}} とする絶対座標で，
        版面上の右向きが ${+x}方向，上向きが ${+y} 方向である\footnote{
          ${y} 座標が上向きに伸びるのは違和感があるかもしれないが，
          これはPDFの仕様の “最も基本的な座標系” にそのまま従ったものだ．
        }．
        これだけ聞くと絶対座標でパスの各点を指定することについては
        あまりにもプリミティヴすぎるのではないかと違和感を覚えるかもしれないが，
        以下で紹介するプリミティヴ\codem{shift-path}を用いて相対座標を扱うことができるので，
        ひとまず心配しないでいただきたい．

        \val-explain?:(`start-path`)({start-path})%
          (Type.(point --> pre-path)) {
            第1引数に指定した点から未完パスを開始する．
          }
        \val-explain?:(`line-to`)({line-to})%
          (Type.(point --> (pre-path --> pre-path))) {
            \codem{\meta{prepath} \|\> line-to \meta{v}}で
            未完パス\codem{\meta{prepath}}を終点から
            点\codem{\meta{v}}へと線分で延長したものを返す．
          }
        \val-explain?:(`bezier-to`)({bezier-to})%
          (Type.(point --> (point --> (point --> (pre-path --> pre-path))))) {
            \codem{\meta{prepath} \|\>
              bezier-to \metasub(${1}){u} \metasub(${2}){u} \meta{v}}
            で未完パス\codem{\meta{prepath}}を
            終点から点\codem{\meta{v}}へとBézier曲線で延長したものを返す．
            \codem{\metasub(${1}){u}}と\codem{\metasub(${2}){u}}は制御点である．
          }
        \val-explain?:(`close-with-line`)({close-with-line})%
          (Type.(pre-path --> path)) {
            未完パスを受け取り，起点と終点を線分で結んで閉じてできるパスを返す．
          }
        \val-explain?:(`close-with-bezier`)({close-with-bezier})%
          (Type.(point --> (point --> (pre-path --> path)))) {
            \codem{\meta{prepath} \|\>
              close-with-bezier \metasub(${1}){u} \metasub(${2}){u}}で
            未完パス\codem{\meta{prepath}}の起点と終点を
            制御点\codem{\metasub(${1}){u}}，\codem{\metasub(${2}){u}}の
            Bézier曲線で結んで閉じてできるパスを返す．
          }
        \val-explain?:(`terminate-path`)({terminate-path})%
          (Type.(pre-path --> path)) {
            未完パスを受け取り，開いたままのパスとして返す．
          }
        \val-explain?:(`unite-path`)({unite-path})%
          (Type.(path --> (path --> path))) {
            2つのパスを統合して1つにする．
            これはドーナツ形など中空のパスをつくるのに必須である\footnote{
              点がパスの “内側” であるか否かは，
              その点を囲んでいるパスの回転数の総和の偶奇によって決まっている．
            }．
          }
        \val-explain?:(`shift-path`)({shift-path})%
          (Type.(point --> (path --> path))) {
            \codem{\meta{path} \|\> shift-path \meta{v}}で
            パス\codem{\meta{path}}の位置を\codem{\meta{v}}だけずらす．
          }
        \val-explain?:(`get-path-bbox`)({get-path-bbox})%
          (Type.(path --> product [point; point])) {
            パスを受け取り，そのパスのバウンディングボックスの左下と右上の座標の組を返す．
            すなわち，与えられたパスが占める領域のうち
            ${x} 座標がとる最小値と ${y} 座標がとる最小値の組
            ${\tuple{|x_{\mathrm{min}}|y_{\mathrm{min}}|}}と，
            ${x} 座標がとる最大値と ${y} 座標がとる最大値の組
            ${\tuple{|x_{\mathrm{max}}|y_{\mathrm{max}}|}}との組を返す．
          }
      }
    >
    +section{グラフィックス指定}<
      +p{
        パス，つまり\type(Type.(path));型の値は，単に曲線や閉曲線のデータ，
        さらにいえばどんな領域を占めているかの情報であり，それ自体が描けるものではない．
        実際にそのパスに基づいて文書中に図形を挿入するには，
        それがどんな色で塗られるかとか，あるいはどんな枠線で描かれるかといった情報を与える必要がある．
        パスに加えてそれらの情報を持っているのが\type(Type.(graphics));型の値である．
        これは以下のプリミティヴを用いてつくる．

        \val-explain?:(`fill`)({fill})%
          (Type.(color --> (path --> graphics))) {
            \codem{fill \meta{color} \meta{path}}で
            パス\codem{\meta{path}}の内側を色\codem{\meta{color}}で塗った
            グラフィックスを返す．
          }
        \val-explain?:(`stroke`)({stroke})%
          (Type.(length --> (color --> (path --> graphics)))) {
            \codem{stroke \meta{t} \meta{color} \meta{path}}で
            パス\codem{\meta{path}}を幅\codem{\meta{t}}，
            色\codem{\meta{color}}の線として描いたグラフィックスを返す．
          }
        \val-explain?:(`draw-text`)({draw-text})%
          (Type.(point --> (inline-boxes --> graphics))) {
            \codem{draw-text \meta{v} \meta{ib}}で
            位置\codem{\meta{v}}を参照点として
            インラインボックス列\codem{\meta{ib}}を置いたグラフィックスを返す．
          }
        \val-explain?:(`shift-graphics`)({shift-graphics})%
          (Type.(point --> (graphics --> graphics))) {
            第1引数の分だけ第2引数のグラフィックスの座標をずらす．
          }
        \val-explain?:(`get-graphics-bbox`)({get-graphics-bbox})%
          (Type.(graphics --> product [point; point])) {
            \codem{get-path-bbox}と同じ要領で
            与えられたグラフィックスのバウンディングボックスを返す．
            ストロークの太さは考慮されないことに注意．
          }
      }
      +p{
        さて，グラフィックスの構成は上に掲げたプリミティヴを用いればよいが，
        実際に本文中にグラフィックスを挿入するにはどうすればいいのだろうか．
        このために用意されているのがプリミティヴ：

        \val?:(`inline-graphics`)({inline-graphics})%
          (Type.(length --> (length --> (length -->
            ((point --> list graphics) --> inline-boxes)))));%

        である．これは
        \codem{inline-graphics \meta{w} \meta{h} \meta{d} \meta{grf}}
        という形で使うことでインラインボックス列を得る．
        最初の3つの引数は寸法の指定で，
        \codem{\meta{w}}が横幅，
        \codem{\meta{h}}が高さ，
        \codem{\meta{d}}が深さである．
        要するにグラフィックスは大きい1文字のようなものとして扱うのだが，
        どのような寸法の文字として扱って欲しいかを指定しているのである．
        そして重要なのは第4引数\codem{\meta{grf}}で，
        これは座標を受け取ってグラフィックスのリストを返す函数である．
        \SATySFi;はまずグラフィックスの内容が確定していない段階で
        寸法だけを用いて（行分割処理やページ分割処理を経て）
        実際に版面のどの位置に配置されるかを決定し，
        位置が確定してからその参照点${\tuple{|x|y|}}を
        指定されていた函数\codem{\meta{grf}}に引数として渡す．
        そしてその返り値としてできたグラフィックスのリストをそこに描き込む，
        という仕組みになっている．
      }
      +example{
        指定されたテキストが現在のフォントで占める領域と同じ範囲をバツ印つきの長方形の枠にして
        出力するコマンド，すなわち以下のような記述と組版結果を実現するコマンド
        \codem{\\area}を考える：

        \d-code-and-block(```
          +p{ The quick brown fox jumps over the lazy dog. }
          +p{ The quick \area{brown} fox jumps over the \area{lazy} dog. }
        ```)(open Sample in '<
          +p-alph{ The quick brown fox jumps over the lazy dog. }
          +p-alph{ The quick \area{brown} fox jumps over the \area{lazy} dog. }
        >);%

        このような\codem{\\area}は次のように
        \codem{inline-graphics}および
        \index(`get-natural-metrics`)?:({\code(`get-natural-metrics`);})%
          {\codem{get-natural-metrics}}
        を用いて定義することができる：

        \d-code(```
          let-inline ctx \area it =
            let ib = read-inline ctx it in
            let (w, h, d) = get-natural-metrics ib in
            let thickness = 0.5pt in
            let color = Color.black in
              inline-graphics w h d (fun (x, y) ->
                [
                  stroke thickness color
                    (start-path (x, y -' d)
                      |> line-to (x +' w, y -' d)
                      |> line-to (x +' w, y +' h)
                      |> line-to (x, y +' h)
                      |> close-with-line);

                  stroke thickness color
                    (start-path (x, y -' d)
                      |> line-to (x +' w, y +' h)
                      |> terminate-path);

                  stroke thickness color
                    (start-path (x, y +' h)
                      |> line-to (x +' w, y -' d)
                      |> terminate-path);
                ]
              )
        ```);
      }
      +p{
        なお，上での説明からもわかるとおり，
        第4引数\codem{\meta{grf}}の “中身” が評価されるタイミングは
        注意が必要である．\REMAINS{続き}

      }
    >
    +section{囲み枠}<
      +p{ \REMAINS{囲み枠} }
    >
    +section{表組版}<
      +p{ \REMAINS{表組版} }
    >
    +section{画像}<
      +p{ \REMAINS{画像挿入} }
    >
  >
  +chapter?:(`math`){数式組版}<
    +p{
      主に理工系の文書をしたためる者にとって，
      数式組版機能は水や空気のように当然のものとして組版処理システムに備わっていてほしいものだ．
      \TeX;/\LaTeX;が30年の長きに亘って使われ続けてきた大きな要因のひとつが，
      誰もが納得するような品質の数式組版機能を古くから提供している
      数少ない組版処理システムだったからであることにおそらく異論はないだろう．
    }
    +p{
      \SATySFi;も，\TeX;/\LaTeX;に肩を並べられるくらいの品質の数式組版機能を提供している．
      しかも，既に\ref-chapter(`getting-started`);で見たように，
      \LaTeX;そっくりの構文で書くことができる．
      数式を多大に含む文書を執筆したいという動機で既に盛んに\LaTeX;に触れていた人にとって，
      少なくとも数式の記法が\SATySFi;への移行に関する心理的障壁となることはまずないだろう．
      本章では，\SATySFi;に備わっている数式組版機能について，詳細を追って見ていくことにしよう．
    }
    +p{
      なお，繰り返しになるが，\SATySFi;での数式の記述はコードの見た目上\LaTeX;にそっくりなものの，
      裏でやっていることは両者で全然違う．
      \LaTeX;は字句解析（トークン化）に相当する処理を組版処理と同時進行で行ない，
      かつ構文木も一切構築せずパターンマッチでトークン列を書き換えていくのに対し，
      \SATySFi;は静的に構文解析して数式を構文木の形で保持している．
    }
    +p{ \REMAINS{} }
  >
  +chapter?:(`cross-reference`){相互参照}<
    +p{
      \dfnje{相互参照}{cross reference}とは，
      章節や図表の番号といった
      “内容そのものに関係なく割り当てられ，かつ文書中の他の場所から指し示すときに使われる”
      情報を自動的に取り扱う機能である．
      \ref-chapter(`introduction`);でも述べたように，
      相互参照はマークアップ方式の組版処理システムが（WYSIWYG方式のそれに比べて）
      簡潔に実現することを得意としやすい機能だ．
    }
    +p{
      \SATySFi;での相互参照の実現方法は\LaTeX;でのそれと基本的に同様であり，
      “1回目の処理で相互参照用のIDとその内容を紐づけて外部ファイルに記録しておき，
      2回目の処理で補完する” 方式をとっている．
      ここで相互参照のIDとそれに紐づけられた（番号などの）内容を記録しておく外部ファイルが
      \ref-chapter(`getting-started`);で登場し即座に無視されていた
      \path{\meta{foo}.satysfi-aux}，すなわち
      \dfnje{補助ファイル}{auxiliary file}なのである．
      なお，上で述べた “1回目で記録して2回目で補完する” をより正確に言えば
      “毎回組版処理が始まるときに（既に存在すれば）補助ファイルを読み込み，
      相互参照のIDと内容の紐づけが不動点に達するまで組版処理を繰り返す” である\footnote{
        相互参照の紐づけがいつまでも不動点に到達しないような意地悪な記述をすることも（残念ながら）できる．
        この意地悪な挙動を型システムなどの言語機能によって排除することは原理的に難しい．
        \SATySFi;は，相互参照の紐づけが不動点に達していなくても，あらかじめ定められた打ち切り回数に到達したら

        \console(`could not reach to fixpoint when resolving cross references.`);%

        とログを表示して終了する．
        打ち切り回数は ${8} 回である（今のところこれを変更する方法は提供していない）．
      }．
      \SATySFi;を使用している際に，
      型検査を通った文書の処理でしばしば

      \console(```
        needs another trial for solving cross references...
        evaluating texts (2nd trial) ...
      ```);%

      などとログを出して最初からもう一度組版処理を始め，やがて

      \console(```
        all cross references were solved.
      ```);%

      などと報告して（正常にPDFを出力して）終了するのに気づいた方も多いだろうが，
      これは相互参照の紐づけが不動点に達するまで組版処理を繰り返しているのである．
    }
    +p{
      実現方法からもわかるように，相互参照はかなり原始的な定式化によって成り立っている．
      これはひとえに相互参照を必ず “1回の処理” で整合させるのは本質的に困難であることに起因する．
      “1回の処理” で整合させる本質的な困難さを感じ取れる大雑把な例を以下に挙げてみよう：\quad;
      相互参照で或る章節のページ番号を挿入したいとする．
      そのページ番号がいくつなのかはページ分割をするまでわからないから，
      ページ番号としてどのような内容を本文中に挿入したらよいのか事前には決められない．
      \codem{inline-graphics}と同様の要領で内容をあらかじめ未定にしておいて
      ページ分割後に内容を決定してはどうかと考えるかもしれないが，
      ページ番号の内容がグリフ列として版面上どれだけの幅を占めるかさえ事前にはわからない．
      このように，内容がページ分割結果に依存する処理は（どこでページ分割するかも当然ながら内容に依存しているので）
      “1回の処理” で整合させることが一般にきわめて困難なのである．
    }
    +p{
      仕組みが原始的なだけあって，相互参照機能を実現しているプリミティヴは非常に単純だ．
      以下の2種類のみである：

      \val-explain?:(`register-cross-reference`)({register-cross-reference})%
        (Type.(string --> (string --> unit))) {
          \codem{register-cross-reference \meta{key} \meta{value}}で
          相互参照のID\codem{\meta{key}}から内容\codem{\meta{value}}への紐づけを登録する．
          既に\codem{\meta{key}}から何らかの内容への紐づけが登録されていた場合は
          上書きされ，また古い内容と新しい内容が文字列として異なっていた場合は
          相互参照が不動点に達していないという理由で\SATySFi;処理系に再処理を促す．
          \codem{\meta{key}}からの紐づけが元々登録されていなかった場合も
          同様に再処理を促す．
        }%

      \val-explain?:(`get-cross-reference`)({get-cross-reference})%
        (Type.(string --> (option string))) {
          \codem{get-cross-reference \meta{key}}という形で使い，
          既に\codem{\meta{key}}に紐づけられた
          何らかの内容\codem{\meta{value}}が登録されている場合は
          \codem{Some(\meta{value})}が返される．
          \codem{\meta{key}}に紐づけられた内容が登録されていない場合は
          \codem{None}を返す．
        }%

      なお，登録されていない相互参照ID\codem{\meta{key}}が\codem{get-cross-reference}によって取得を試みられ，
      そのまま相互参照が不動点に達して終了した場合，\SATySFi;は

      \console(```
        some cross references were not solved:
      ```);

      という文言とともにそのような\codem{\meta{key}}を列挙して報告する．
    }
    +example{
      \codem{register-cross-reference}と\codem{get-cross-reference}を用いた
      相互参照コマンドの実装例は，
      \SATySFi;のリポジトリの\path{lib-satysfi/dist/packages}
      にある\pkg{stdjabook}などを参考にすると良いだろう．
    }
    +p{
      \REMAINS{余力があれば小さい例をつくる}
    }
  >
  +chapter?:(`page-breaking`){ページ分割処理}<
    +p{ \REMAINS{} }
  >
  +chapter?:(`text-mode`){テキストモード}<
    +p{ \REMAINS{} }
  >
  +chapter?:(`primitives`){プリミティヴ一覧}<
    +p{ \REMAINS{} }
  >
  +chapter?:(`future-work`){Future Work}<
    +p{
      \SATySFi;は現時点でも充分実用に耐える程度に機能を備えているが，
      今後さらに拡張していきたいと考えている点がいくつもある．
      本章ではこれについて簡潔に述べることとしよう．
      端的に言ってしまえば開発に協力してくださるかもしれない方への喧伝である．
    }
    +section{機能の拡張}<
      +subsection{文字組版機能の拡張}<
        +p{ \REMAINS{縦書き，LTR/RTL，2段組み} }
        +p{ \REMAINS{OpenTypeフィーチャのON/OFF機能} }
        +p{ \REMAINS{合字やカーニング処理の言語ごとの切り替え} }
        +p{ \REMAINS{widow, orphan} }
        +p{ \REMAINS{数式のalignment tab} }
        +p{ \REMAINS{ページ分割できる表組版} }
        +p{ \REMAINS{行長が変わる段落} }
      >
      +subsection{言語機能の拡張}<
        +p{ \REMAINS{シグネチャ，多重モジュール} }
        +p{ \REMAINS{ファンクタか型クラス} }
        +p{ \REMAINS{パッケージマネージャ} }
        +p{ \REMAINS{レコードに関する型システムの拡張} }
        +p{ \REMAINS{末尾再帰最適化} }
      >
      +p{ \REMAINS{CFF系フォントの部分埋め込み} }
      +p{ \REMAINS{画像読み込みのGIF，PNG等対応} }
      +p{ \REMAINS{タグつきPDFの出力} }
      +p{ \REMAINS{相対パスの扱い，プリプロセッサ} }
      +p{ \REMAINS{文脈のエントリーの拡張機能} }
    >
    +section{既存機能の破壊的な変更}<
      +p{ \REMAINS{フォント読み込みの機構} }
      +p{ \REMAINS{line-breakのインターフェイス変更} }
      +p{ \REMAINS{graphicとgraphic list} }
    >
  >
  +chapter?:(`specification`){言語仕様}<
    +p{
      この章は，対象をより細かい粒度で理解しようとせずにはいられない，物好きな読者向けに用意した．
      全貌を形式的に記述するには\SATySFi;は大きすぎるので，
      根幹となる部分だけを抜き出したサブセットをいくつか定義し，
      それについて操作的意味論や型システムをフォーマルに記述することを試みた．
    }
    +p{ \REMAINS{} }
  >
>
