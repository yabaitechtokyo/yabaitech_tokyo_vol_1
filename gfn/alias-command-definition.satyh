% -*- coding: utf-8 -*-
@import: settings

let alias-command-definition = '<
  +p{
    まずは非常に簡素な例から考える．
    例えば\pkg{stdjareport}の提供する\codem{\\dfn}というコマンド名が気に入らず，
    \codem{\\new-word}という名前で書きたいとしよう．
    要するに，\codem{\\new-word\{（新出単語）\}}と書いたら\codem{\\dfn\{（新出単語）\}}
    に “勝手に変わってくれる” ようなコマンド\codem{\\new-word}を定義したいとする．
  }
  +p{
    これを実現するために，プリアンブルに手を加えよう．文書ファイルの
    \codem{\@require}や\codem{\@import}が並ぶ箇所と\codem{document}との間には，
    コマンド定義を書くことができる．
    \ref-chapter(`getting-started`);で扱った例の
    本文中の\codem{\\dfn}を\codem{\\new-word}に書き換え，
    \codem{\\new-word}の定義をプリアンブルに追加してみよう：

    \d-code(```
      @require: stdjareport

      let-inline \new-word it =
        {\dfn{#it;}}

      in
      document (|
        title = {サンプル文書};
        author = {組 版太郎};
      |) '<
        +chapter{はじめての章}<
          +p{
            \SATySFi;でのはじめての段落の記述です．
            段落は\new-word{ブロックコマンド}で実現されています．
          }
        >
      >
    ```);

    \codem{let-inline}云々とあるのが\codem{\\new-word}の定義である．
    コマンドの定義はプログラミング言語で言うところの函数の定義によく似ており，
    \codem{it}がインラインテキストが格納される引数にあたる．
    そして受け取った引数をインラインテキスト中で使っているのが\codem{\#it\;}である．
    コマンド定義は

    \d-code(```
      let-inline （定義したいインラインコマンド名） （0個以上の引数） =
        {（置き換え後の記述）}
    ```);%

    という形で書くことになる．
    おそらく中級以上の\LaTeX;ユーザなら\code(`\newcommand`);を想起するだろう．
    実際，\SATySFi;での上記のような\codem{\\new-word}の定義は，
    \code(`\dfn`);が定義されている下で\code(`\newWord`);を定義する
    以下の\LaTeX;コードとほぼ等価なものと考えてよい．

    \d-code(```
      \newcommand{\newWord}[1]{\dfn{#1}}
    ```);

    この定義中の\code(`#1`);が\SATySFi;での\codem{\#it\;}に相当するのである．
    引数を要しないコマンドも同様に定義できる．例えば

    \d-code(```
      let-inline \Cde =
        {ともあれ，カルタゴは滅ぶべきであると考える次第である．}
    ```);

    と定義すれば，インラインテキスト中で \codem{\\Cde\;}と打つだけで
    「ともあれ，カルタゴは滅ぶべきであると考える次第である．」と書いているのと等価になってくれる．
    日本語を読み書きできる古代ローマ人にとっては重宝するだろう．
  }
  +p{
    ブロックコマンドの自前定義についても，以下のような構文によってインラインコマンドと同様に行なえる：

    \d-code(```
      let-block （定義したいブロックコマンド名） （0個以上の引数） =
        '<（置き換え後の記述）>
    ```);%

    ただし，またも\codem{\<}ではなく\codem{'\<}であることに注意されたい．
    不恰好だが残念ながらこればかりは気をつけてもらうしかない．
    この機構を用いると，例えば
    段落末に必ず「ともあれ，カルタゴは滅ぶべきであると考える次第である．」という1文をつけ加えて
    段落をつくるコマンド\codem{+pCde}は

    \d-code(```
      let-block +pCde t = '<
        +p{
          #t;
          ともあれ，カルタゴは滅ぶべきであると考える次第である．
        }
      >
    ```);%

    という具合に定義できる．以降\codem{+p}の代わりにこの\codem{+pCde}を使えば
    自動で末尾に文が挿入されるからやはり便利である．
    このほか，古代ローマ人以外にも便利な例としては次のようなブロックコマンドが定義できる：

    \d-code(```
      let-block +no-proof bt = '<
        #bt;
        +p{証明は読者への演習課題とする．}
      >
    ```);

    今度は引数がブロックテキストであることに注意されたい．ブロックテキストが格納された変数\codem{bt}も，
    ブロックテキスト中に\codem{\#bt\;}と書くことでそこに内容を埋め込むことができる．
    この定義は要するに，与えられたブロックテキストの後ろに
    「証明は読者への演習課題とする．」と書かれた段落をくっつけるコマンドの定義になっている．
    以下のようにして理工書の執筆に使えば大変便利である．

    \d-code(```
      +no-proof<
        +lemma{
          （証明がめんどくさい補題の内容）
        }
      >
    ```);
  }
>
