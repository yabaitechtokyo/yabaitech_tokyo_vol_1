% -*- coding: utf-8 -*-
@import: settings

let overall = '<
  +p{
    \SATySFi;のおおよその用法は既に\ref-chapter(`getting-started`);で説明したが，
    もしかすると他のマークアップ言語ないし組版処理システムではあまり意識することのない
    “インライン” なる概念と “ブロック” なる概念の区別を不思議に感じたかもしれない．
    この区別は\SATySFi;がどのように組版処理の工程を定式化して扱っているかに起因しており，
    本章ではその定式化を概観することにする．
    \SATySFi;での組版処理工程の定式化は，各工程に対応するプリミティヴに
    どのように型をつけて静的な検査を実現しているかという点とも密接に関わってくるので，
    是非\ref-chapter(`type-system`);と併せて読んでいただきたい．
  }
  +section{\SATySFi;の全体像}<
    +p{
      模式的に描くと，\SATySFi;の全体像は\ref-figure(`overall-structure`);のようになっている．
      \figure?:(`overall-structure`){\SATySFi;の全体像}<
        +p{
          \REMAINS{全体像の図}
        }
      >
      図中で\SATySFi;処理系の構造は左右に大別されて描かれているが，このうち
      入力に近い左側を\dfn{フロントエンド}，右側を\dfn{バックエンド}と呼ぶ．
    }
    +p{
      フロントエンドは入力側から順に
      \dfn{字句解析器}，\dfn{構文解析器}，\dfn{型検査器}からなっている．
      ソースファイルが\SATySFi;へ渡されると，
      まず字句解析器にしたがってソースファイルの内容がトークン列に切り分けられる．
      字句解析器には

      \listing{
        * プログラムを読み取る状態
        * インラインテキストを読み取る状態
        * ブロックテキストを読み取る状態
        * コメントを読み取る状態
        * ${\vdots}
      }%

      といったいくつかの状態があり，
      ソースファイルを読み取る過程でスタックを用いて括弧の対応などを検査しつつ
      これらの状態を適宜遷移する．
      明らかに括弧の対応が取れていなかったり，
      現在の状態に対して正当なソースファイルで出現するはずのない文字に遭遇したりすると，
      その時点で

      \console(`
        ! [Syntax error at Lexer] （エラー位置とその内容）
      `);%

      という形でエラーが報告される．
      続いてトークン列化されたデータは構文解析器によって
      （\SATySFi;の文法にしたがって）構文木に組み上げられる．
      この時点で構文木に組み上げられないトークン列の組み合わせが見つかった場合は

      \console(`
        ! [Syntax error at Parser] （エラー位置）
      `);%

      という形でエラーが報告される．
      字句解析器でエラーが出るか構文解析器でエラーが出るかには，
      ユーザにとってはそれほど大きな違いはない．
      いずれも何らかのミスを含んでいるために構文木に組み上げられないソースファイルが
      処理系に渡され，型検査器にかけるまでもなく入力がおかしいとわかったため弾かれたということである．
      ここまでの処理は，ほとんどのマークアップ言語やプログラミング言語に共通の処理である\footnote{
        字句解析と構文解析でのエラーを区別せず “syntax error” として提示する言語も多い．
        ブラウザなどマークアップ言語を扱う処理系が
        構文に対するエラーを明示的に提示しているのを見た経験は少ないかもしれないが，
        これは大抵の場合処理系がミスに対してかなり “寛容” につくられていて，
        なんとかミスを整合させようと何らかの強引な修正を行なうからだ．
        ちなみに，処理系がミスに “寛容” なのは別に望ましいことではなく，むしろ逆である．
        それは税関が “寛容” だと密輸が横行するのと同様の意味に於いてであり，
        実際この世界にはブラウザの “寛容さ” にかまけた
        杜撰なソースのWebページに溢れている．
      }．
      字句解析でも構文解析でもエラーが出ず構文木に組み上げられた入力は，
      次に型検査器で調べられることになる．
      型システムに馴染みのない読者に向けて簡単に言えば，引数の種類や個数が合っていないとか
      リストと真偽値を足し合わせる計算を記述しているといった “或る種の不整合” が
      入力に含まれていないかを検査するのである．
      ここでの検査に通れば実際に組版処理を行なっている最中に “或る種の不整合” に基づく
      処理の失敗が起こらないことが（数学的に）保証されており，
      それゆえに実際に組版処理を行なわずとも入力ミスを素早く検出できるである．
      何らかの不整合が含まれている場合，型検査器はその不整合を

      \console(`
        ! [Syntax error at Typechecker] （エラー位置とその内容）
      `);%

      という形で報告する．ユーザはこれにしたがって
      型検査器についての解説は\ref-chapter(`type-system`);で行なう．
      また，字句解析器・構文解析器・型検査器を厳密に形式的に記述した解説は
      \ref-chapter(`specification`);で与えることにする．
    }
    +p{
      さて，フロントエンドでの各種処理と検査をめでたく通過した入力データは，
      バックエンドによって実際に組版処理にかけられる．
      \REMAINS{}
    }
  >
  +section{ボックス列}<
  >
  +section{処理文脈}<
  >
  +section{行分割処理}<
  >
  +section{ページ分割処理}<
  >
>
