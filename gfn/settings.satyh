% -*- coding: utf-8 -*-
@require: deco
@require: code
@require: color
@require: itemize
@require: hdecoset
@import: book-class


let-inline ctx \REMAINS msg =
  let pads = (2pt, 2pt, 2pt, 2pt) in
  let ctx =
    ctx |> Book.set-cjk-font Book.font-cjk-gothic
        |> set-text-color Color.red
  in
    inline-frame-inner pads (Deco.simple-frame 1pt Color.red Color.yellow)
      (read-inline ctx {要加筆： #msg;})


let-inline ctx \quad =
  let sz = Book.get-cjk-font-size ctx in
    inline-skip sz


let-inline ctx \size sz it =
  read-inline (ctx |> set-font-size sz) it


let-inline ctx \italic it =
  read-inline (ctx |> Book.set-latin-font Book.font-latin-italic) it


let-inline \dfnje itj ite =
  {\dfn{#itj;}(\italic{#ite;})}


let set-mono-font ctx =
  ctx |> set-font Latin (`lmmono`, 1., 0.)
      |> set-hyphen-penalty 100000


let-inline ctx \pkg it =
  read-inline (ctx |> set-mono-font) it


let-inline ctx \path it =
  read-inline (ctx |> set-mono-font) it


let strut h d =
  inline-graphics 0pt h d (fun _ -> [])


let-inline ctx \codem it =
  let ib =
    strut 8pt 3pt ++ read-inline (ctx |> set-mono-font) it
  in
  let pads = (2pt, 2pt, 2pt, 2pt) in
  let decoset = HDecoSet.rectangle-round-fill 4pt 2pt (Color.gray 0.9) in
    script-guard Latin (inline-frame-breakable pads decoset ib)


let-inline ctx \github it =
  read-inline (ctx |> set-mono-font) it


let-inline ctx \twitter it =
  read-inline (ctx |> set-mono-font) it


let-inline \person-github itn itg =
  {#itn; (\github{#itg;})}


let display-code-scheme ctx s =
    let decoset =
      let back-color = Gray(0.875) in
      let deco (x, y) w h d =
        [
          fill back-color (Gr.rectangle (x, y -' d) (x +' w, y +' h));
        ]
      in
      (deco, deco, deco, deco)
    in
      Code.scheme decoset Color.black ctx s


let-inline ctx \d-code s =
  let bb = display-code-scheme ctx s in
    inline-fil ++ embed-block-breakable ctx bb


module BoxGraphics = struct

  let-inline ctx \roman its =
    let ctx =
      ctx |> Book.set-latin-font Book.font-latin-roman
          |> set-font-size 10mm
    in
    let pads = (0pt, 0pt, 0pt, 0pt) in
    let deco (x, y) w h d =
      let rect = Gr.rectangle (x, y -' d) (x +' w, y +' h) in
      [
        fill (Gray(0.875)) rect;
        stroke 0.5pt Color.black rect;
      ]
    in
      its |> List.map (fun it ->
        inline-frame-inner pads deco (read-inline ctx it)
      ) |> List.fold-left (++) inline-nil


  let-inline ctx \space =
    let pads = (0pt, 0pt, 0pt, 0pt) in
    let deco (x, y) w h d =
      let rect = Gr.rectangle (x, y -' d) (x +' w, y +' h) in
      [
        fill (Gray(0.5)) rect;
        stroke 0.5pt Color.black rect;
      ]
    in
    let w = 0.4cm in
    let h = 0.5cm in
    let d = 0cm in
      inline-frame-inner pads deco
        (inline-graphics w h d (fun (x, y) -> []))


  let-inline ctx \glue =
    let h = 0.5cm in
    let d = 0cm in
      (inline-graphics-outer h d (fun w (x, y) -> (
        let rect = Gr.rectangle (x, y -' d) (x +' w, y +' h) in
        [
          fill (Gray(0.5)) rect;
          stroke 0.5pt Color.black rect;
        ]
      )))


  let-inline ctx \line it =
    let pads = (0pt, 0pt, 0pt, 0pt) in
    let deco (x, y) w h d =
      let rect = Gr.rectangle (x, y -' d) (x +' w, y +' h) in
      [
        fill (Gray(0.75)) rect;
        stroke 0.5pt Color.black rect;
      ]
    in
      inline-frame-outer pads deco (read-inline ctx it)


  let-inline ctx \justify wid its =
    let pads = (0pt, 0pt, 0pt, 0pt) in
    let l = 0.5cm in
    let deco (x, y) w h d =
      [
        stroke 1pt Color.black (Gr.line (x     , y -' d -' l) (x     , y +' h +' l));
        stroke 1pt Color.black (Gr.line (x +' w, y -' d -' l) (x +' w, y +' h +' l));
      ]
    in
    let decoset = (deco, deco, deco, deco) in
      embed-block-top ctx wid (fun ctx ->
        block-frame-breakable ctx pads decoset (fun ctx ->
          its |> List.map (fun it ->
            line-break false false ctx (read-inline ctx it)
          ) |> List.fold-left (+++) block-nil
        )
      )

end


let make-graphics ctx grf =
  grf (|
    text-centering = (fun pt it ->
      Gr.text-centering pt (read-inline ctx it)
    );
  |)


let-block ctx +centered-graphics w h grf =
  let ib-gr =
    inline-graphics w h 0pt (fun pt ->
      List.map (shift-graphics pt) (make-graphics ctx grf)
    )
  in
  line-break true true (ctx |> set-paragraph-margin 0pt 0pt)
    (inline-fil ++ ib-gr ++ inline-fil)


let-inline ctx \d-code-and-block s bt =
  let pads = (5pt, 5pt, 5pt, 5pt) in
  let wid = get-text-width ctx in
  let bb =
    display-code-scheme ctx s +++
      block-frame-breakable ctx pads VDecoSet.paper (fun ctx ->
        read-block ctx bt
      )
  in
    inline-fil ++ embed-block-breakable ctx bb



module Sample = struct

  let-inline ctx \enlarge it =
    let size = get-font-size ctx in
    let ctx-enlarge = set-font-size (size *' 1.5) ctx in
      read-inline ctx-enlarge it

end


module Type : sig

  type t
  val to-math : t -> math
  val (-->) : t -> t -> t
  val base-type : inline-text -> t
  val product : t list -> t
  val unit : t
  val bool : t
  val int : t
  val float : t
  val length : t
  val context : t
  val inline-text : t
  val inline-boxes : t
  val block-text : t
  val block-boxes : t
  val list : t -> t
  val option : t -> t
end = struct

  type t =
    | Ctr  of inline-text * t list
    | Func of t * t
    | Prod of t list


  type paren-mode =
    | Normal
    | Domain
    | Single


  let-math \arr =
    let mbr =
      text-in-math MathOrd (fun ctx ->
        discretionary 100 inline-nil inline-fil inline-nil)
    in
      math-group MathBin MathBin (math-concat (math-char MathOrd `→`) mbr)


  let to-math =
    let-rec aux
      | mode (Ctr(it, tyargs)) =
          let marg =
            tyargs |> List.map (fun ty -> (
              let m = aux Single ty in
              ${#m\ }
            )) |> List.fold-left math-concat ${}
          in
          let mctr =
            text-in-math MathOrd
              (fun ctx -> read-inline ctx {\no-break{#it;}})
          in
          let m = ${#marg#mctr} in
          ( match (mode, tyargs) with
            | (Single, _ :: _) -> ${\paren{#m}}
            | _                -> m
          )

      | mode (Func(ty1, ty2)) =
          let m1 = aux Domain ty1 in
          let m2 = aux Normal ty2 in
          let m = ${#m1 \arr #m2} in
          ( match mode with
            | Normal -> m
            | _      -> ${\paren{#m}}
          )

      | mode (Prod(tys)) =
          let ms = List.map (aux Single) tys in
            Math.join ${\mathbin{\ast}} ms
    in
    aux Normal


  let base-type it =
    Ctr(it, [])


  let (-->) ty1 ty2 =
    Func(ty1, ty2)


  let product tys =
    Prod(tys)


  let unit         = base-type {unit}
  let bool         = base-type {bool}
  let int          = base-type {int}
  let float        = base-type {float}
  let length       = base-type {length}
  let context      = base-type {context}
  let inline-text  = base-type {inline-text}
  let inline-boxes = base-type {inline-boxes}
  let block-text   = base-type {block-text}
  let block-boxes  = base-type {block-boxes}


  let list ty = Ctr({list}, [ty])
  let option ty = Ctr({option}, [ty])

end


let quote-indent-1 = 24pt
let quote-indent-2 = 12pt


let-inline ctx \val it-cmd ty =
  let m = Type.to-math ty in
  let wid = get-text-width ctx in
  let len = quote-indent-1 +' quote-indent-2 in
  let ib =
    inline-skip len ++
      embed-block-top ctx (wid -' len)
        (fun ctx ->
          line-break true true ctx
            (inline-skip (0pt -' quote-indent-2) ++
              read-inline ctx {\codem{#it-cmd;} : ${#m}} ++ inline-fil))
  in
    inline-fil ++
      embed-block-breakable ctx
        (line-break true true ctx ib)


let-inline ctx \type ty =
  embed-math ctx (Type.to-math ty)


let-inline ctx \meta it =
  let ctx =
    ctx |> Book.set-latin-font Book.font-latin-italic
  in
    read-inline ctx it


let-inline ctx \metasub msub it =
  read-inline ctx {${\text!{\meta{#it;}}_{#msub}}}


let-inline ctx \inline-frame inner =
  let pads = (2pt, 2pt, 2pt, 2pt) in
  let decoset = HDecoSet.simple-frame-stroke 0.5pt Color.black in
    inline-frame-breakable pads decoset (read-inline ctx inner)


let-math \tuple mlst =
  let m = Math.join ${,} mlst in
    ${\paren{#m}}


let-block ctx +frame content =
  let pads = (10pt, 10pt, 5pt, 5pt) in
  let decoset = VDecoSet.paper in
    block-frame-breakable ctx pads decoset (fun ctx -> read-block ctx content)


let-inline ctx \fbox it =
  let pads = (2pt, 2pt, 2pt, 2pt) in
  let t = 0.5pt in
  let deco (x, y) w h d =
    [ stroke t Color.black (Gr.rectangle (x, y -' d) (x +' w, y +' h)) ]
  in
    inline-frame-inner pads deco (read-inline ctx it)


type position-spec =
  | Top
  | Bottom


let-inline ctx \parbox ?:specopt wid ib =
  let blockf =
    match specopt with
    | None         -> embed-block-top ctx wid
    | Some(Top)    -> embed-block-top ctx wid
    | Some(Bottom) -> embed-block-bottom ctx wid
  in
    blockf (fun ctx -> read-block ctx ib)


let-inline ctx \as-latin-word it =
  script-guard Latin (read-inline ctx it)
