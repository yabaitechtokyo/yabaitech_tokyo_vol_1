% -*- coding: utf-8 -*-
@require: deco
@require: code
@require: color
@require: itemize
@require: hdecoset
@require: table
@require: bnf
@import: term
@import: book-class


% ---- constants ----

let code-background = Gray(0.875)
let quote-indent-1 = 24pt
let quote-indent-2 = 12pt
let val-margin = 12pt
let val-explain-margin = 6pt

% ---- ----


let-inline ctx \REMAINS msg =
  let pads = (2pt, 2pt, 2pt, 2pt) in
  let ctx =
    ctx |> Book.set-cjk-font Book.font-cjk-gothic
        |> set-text-color Color.red
  in
    inline-frame-inner pads (Deco.simple-frame 1pt Color.red Color.yellow)
      (read-inline ctx {要加筆： #msg;})


let-math \defeq = ${\coloneq}


let-inline ctx \quad =
  let sz = Book.get-cjk-font-size ctx in
    inline-skip sz


let-inline ctx \size sz it =
  read-inline (ctx |> set-font-size sz) it


let-inline ctx \italic it =
  read-inline (ctx |> Book.set-latin-font Book.font-latin-italic) it


let-inline \dfnje itj ite =
  {\dfn{#itj;}(\italic{#ite;})}


let set-mono-font ctx =
  ctx |> set-font Latin (`lmmono`, 1., 0.)
      |> set-hyphen-penalty 100000


let-inline ctx \pkg it =
  read-inline (ctx |> set-mono-font) it


let-inline ctx \path it =
  read-inline (ctx |> set-mono-font) it


let strut h d =
  inline-graphics 0pt h d (fun _ -> [])


let-inline ctx \codem it =
  let ib-strut = strut 8pt 3pt in
  let ib =
    let ctx =
      ctx |> set-mono-font
          |> set-every-word-break inline-nil ib-strut
    in
      ib-strut ++ read-inline ctx it
  in
  let pads = (2pt, 2pt, 2pt, 2pt) in
  let decoset = HDecoSet.rectangle-round-fill 4pt 2pt code-background in
    script-guard Latin (inline-frame-breakable pads decoset ib)


let-inline ctx \github it =
  read-inline (ctx |> set-mono-font) it


let-inline ctx \twitter it =
  read-inline (ctx |> set-mono-font) it


let-inline \person-github itn itg =
  {#itn; (\github{#itg;})}


let display-code-decoset =
  let deco (x, y) w h d =
    [
      fill code-background (Gr.rectangle (x, y -' d) (x +' w, y +' h));
    ]
  in
    (deco, deco, deco, deco)


let display-code-scheme ctx s =
  Code.scheme display-code-decoset Color.black ctx s


let-inline ctx \d-code s =
  let bb = display-code-scheme ctx s in
    inline-fil ++ embed-block-breakable ctx bb


let-inline ctx \d-code-and-block s bt =
  let pads = (5pt, 5pt, 5pt, 5pt) in
  let wid = get-text-width ctx in
  let bb =
    display-code-scheme ctx s +++
      block-frame-breakable ctx pads VDecoSet.paper (fun ctx ->
        read-block ctx bt
      )
  in
    inline-fil ++ embed-block-breakable ctx bb


let-inline ctx \d-codem it =
  let pads = (5pt, 5pt, 5pt, 5pt) in
  let bb =
    block-frame-breakable ctx pads display-code-decoset (fun ctx ->
      line-break true true ctx
        (read-inline (ctx |> set-mono-font) it ++ inline-fil)
    )
  in
    inline-fil ++
      embed-block-breakable ctx bb


module BoxGraphics = struct

  let-inline ctx \roman its =
    let ctx =
      ctx |> Book.set-latin-font Book.font-latin-roman
          |> set-font-size 10mm
    in
    let pads = (0pt, 0pt, 0pt, 0pt) in
    let deco (x, y) w h d =
      let rect = Gr.rectangle (x, y -' d) (x +' w, y +' h) in
      [
        fill (Gray(0.875)) rect;
        stroke 0.5pt Color.black rect;
      ]
    in
      its |> List.map (fun it ->
        inline-frame-inner pads deco (read-inline ctx it)
      ) |> List.fold-left (++) inline-nil


  let-inline ctx \space =
    let pads = (0pt, 0pt, 0pt, 0pt) in
    let deco (x, y) w h d =
      let rect = Gr.rectangle (x, y -' d) (x +' w, y +' h) in
      [
        fill (Gray(0.5)) rect;
        stroke 0.5pt Color.black rect;
      ]
    in
    let w = 0.4cm in
    let h = 0.5cm in
    let d = 0cm in
      inline-frame-inner pads deco
        (inline-graphics w h d (fun (x, y) -> []))


  let-inline ctx \glue =
    let h = 0.5cm in
    let d = 0cm in
      (inline-graphics-outer h d (fun w (x, y) -> (
        let rect = Gr.rectangle (x, y -' d) (x +' w, y +' h) in
        [
          fill (Gray(0.5)) rect;
          stroke 0.5pt Color.black rect;
        ]
      )))


  let-inline ctx \line it =
    let pads = (0pt, 0pt, 0pt, 0pt) in
    let deco (x, y) w h d =
      let rect = Gr.rectangle (x, y -' d) (x +' w, y +' h) in
      [
        fill (Gray(0.75)) rect;
        stroke 0.5pt Color.black rect;
      ]
    in
      inline-frame-outer pads deco (read-inline ctx it)


  let-inline ctx \justify wid its =
    let pads = (0pt, 0pt, 0pt, 0pt) in
    let l = 0.5cm in
    let deco (x, y) w h d =
      [
        stroke 1pt Color.black (Gr.line (x     , y -' d -' l) (x     , y +' h +' l));
        stroke 1pt Color.black (Gr.line (x +' w, y -' d -' l) (x +' w, y +' h +' l));
      ]
    in
    let decoset = (deco, deco, deco, deco) in
      embed-block-top ctx wid (fun ctx ->
        block-frame-breakable ctx pads decoset (fun ctx ->
          its |> List.map (fun it ->
            line-break false false ctx (read-inline ctx it)
          ) |> List.fold-left (+++) block-nil
        )
      )

end


let make-graphics ctx grf =
  grf (|
    text-centering = (fun pt it ->
      Gr.text-centering pt (read-inline ctx it));
    text-rightward = (fun pt it ->
      Gr.text-rightward pt (read-inline ctx it));
    text-leftward = (fun pt it ->
      Gr.text-leftward pt (read-inline ctx it));
  |)


let-block ctx +centered-graphics w h grf =
  let ib-gr =
    inline-graphics w h 0pt (fun pt ->
      List.map (shift-graphics pt) (make-graphics ctx grf)
    )
  in
  line-break true true (ctx |> set-paragraph-margin 0pt 0pt)
    (inline-fil ++ ib-gr ++ inline-fil)


module Sample = struct

  let-inline ctx \enlarge it =
    let size = get-font-size ctx in
    let ctx-enlarge = set-font-size (size *' 1.5) ctx in
      read-inline ctx-enlarge it


  let-inline ctx \q inner =
    let ib-after = read-inline ctx {«\ } in
    let ctxq =
      ctx |> set-every-word-break inline-nil ib-after
    in
    read-inline ctxq {« #inner; »}


  let-block ctx +p-alph it =
    line-break true true ctx
      (inline-skip 15mm ++ read-inline ctx it ++ inline-fil)


  let-inline ctx \area it =
    let ib = read-inline ctx it in
    let (w, h, d) = get-natural-metrics ib in
    let thickness = 0.5pt in
    let color = Color.black in
      inline-graphics w h d (fun (x, y) ->
        [
          stroke thickness color
            (start-path (x, y -' d)
              |> line-to (x +' w, y -' d)
              |> line-to (x +' w, y +' h)
              |> line-to (x, y +' h)
              |> close-with-line);

          stroke thickness color
            (start-path (x, y -' d)
              |> line-to (x +' w, y +' h)
              |> terminate-path);

          stroke thickness color
            (start-path (x, y +' h)
              |> line-to (x +' w, y -' d)
              |> terminate-path);
        ]
      )


  let-inline \show-int n =
    embed-string (arabic n)


  let-inline ctx \simple-frame it =
    let pads = (2pt, 2pt, 2pt, 2pt) in
    let decoset = HDecoSet.simple-frame-stroke 1pt (Gray(0.5)) in
      inline-frame-breakable pads decoset (read-inline ctx it)


end


module Type : sig

  type t
  val to-math : bool -> t -> math
  val (-->) : t -> t -> t
  val base-type : inline-text -> t
  val product : t list -> t
  val unit : t
  val bool : t
  val int : t
  val float : t
  val length : t
  val string : t
  val context : t
  val inline-text : t
  val inline-boxes : t
  val block-text : t
  val block-boxes : t
  val pre-path : t
  val path : t
  val point : t
  val graphics : t
  val color : t
  val deco : t
  val deco-set : t
  val paren : t
  val script : t
  val image : t
  val list : t -> t
  val option : t -> t
  val paddings : t
  val cell : t
end = struct

  type t =
    | Ctr  of inline-text * t list
    | Func of t * t
    | Prod of t list


  type paren-mode =
    | Normal
    | Domain
    | Single


  let-math \arr-display =
    let mbr =
      text-in-math MathOrd (fun ctx ->
        discretionary 100 inline-nil inline-fil inline-nil)
    in
      math-group MathBin MathBin (math-concat (math-char MathOrd `→`) mbr)


  let-math \arr-inline =
    let mbr =
      text-in-math MathOrd (fun ctx -> (
        let ib-space =
          Option.from inline-nil
            (space-between-maths ctx
              (math-char MathOrd ` `) (math-char MathBin ` `))
        in
        discretionary 100 ib-space inline-nil inline-nil
      ))
    in
      math-group MathBin MathOrd (math-concat (math-char MathOrd `→`) mbr)


  let to-math is-inline =
    let-rec aux
      | mode (Ctr(it, tyargs)) =
          let marg =
            tyargs |> List.map (fun ty -> (
              let m = aux Single ty in
              ${#m\ }
            )) |> List.fold-left math-concat ${}
          in
          let mctr =
            text-in-math MathOrd
              (fun ctx -> read-inline ctx {\no-break{#it;}})
          in
          let m = ${#marg#mctr} in
          ( match (mode, tyargs) with
            | (Single, _ :: _) -> ${\paren{#m}}
            | _                -> m
          )

      | mode (Func(ty1, ty2)) =
          let m1 = aux Domain ty1 in
          let m2 = aux Normal ty2 in
          let m =
            if is-inline then
              ${#m1 \arr-inline #m2}
            else
              ${#m1 \arr-display #m2}
          in
          ( match mode with
            | Normal -> m
            | _      -> ${\paren{#m}}
          )

      | mode (Prod(tys)) =
          let ms = List.map (aux Single) tys in
            Math.join ${\mathbin{\ast}} ms
    in
    aux Normal


  let base-type it =
    Ctr(it, [])


  let (-->) ty1 ty2 =
    Func(ty1, ty2)


  let product tys =
    Prod(tys)


  let unit         = base-type {unit}
  let bool         = base-type {bool}
  let int          = base-type {int}
  let float        = base-type {float}
  let length       = base-type {length}
  let string       = base-type {string}
  let context      = base-type {context}
  let inline-text  = base-type {inline-text}
  let inline-boxes = base-type {inline-boxes}
  let block-text   = base-type {block-text}
  let block-boxes  = base-type {block-boxes}
  let pre-path     = base-type {pre-path}
  let path         = base-type {path}
  let point        = base-type {point}
  let graphics     = base-type {graphics}
  let color        = base-type {color}
  let deco         = base-type {deco}
  let deco-set     = base-type {deco-set}
  let paren        = base-type {paren}
  let script       = base-type {script}
  let image        = base-type {image}
  let paddings     = base-type {paddings}
  let cell         = base-type {cell}


  let list ty = Ctr({list}, [ty])
  let option ty = Ctr({option}, [ty])

end


let val-scheme ctx indexopt it-cmd ty explainopt =
  let m = Type.to-math false ty in
  let it =
    match indexopt with
    | None    -> {\codem{#it-cmd;} : ${#m}}
    | Some(s) -> {\index(s)?:({\code(s);}){\codem{#it-cmd;}} : ${#m}}
  in
  let wid = get-text-width ctx in
  let len = quote-indent-1 +' quote-indent-2 in
  let ib =
    inline-skip len ++
      embed-block-top ctx (wid -' len)
        (fun ctx ->
          line-break true true ctx
            (inline-skip (0pt -' quote-indent-2) ++
              read-inline ctx it ++ inline-fil))
  in
  let bb-head =
    let ctx =
      match explainopt with
      | None    -> ctx
      | Some(_) -> ctx |> set-paragraph-margin val-margin val-explain-margin
    in
      line-break true true ctx ib
  in
  let bb-explain =
    match explainopt with
    | None ->
        block-nil

    | Some(it-explain) ->
        let pads = (quote-indent-1 +' quote-indent-2, 0pt, 0pt, 0pt) in
        let decoset = VDecoSet.empty in
        let ctx = ctx |> set-paragraph-margin val-explain-margin val-margin in
          block-frame-breakable ctx pads decoset (fun ctx ->
            line-break false true ctx
              (read-inline ctx it-explain ++ inline-fil))
  in
    inline-fil ++
      embed-block-breakable ctx
        (bb-head +++ bb-explain)


let-block ctx +example it =
  let pads = (15pt, 15pt, 0pt, 0pt) in
  let decoset = VDecoSet.simple-frame-stroke 1pt (Gray(0.75)) in
    block-frame-breakable ctx pads decoset (fun ctx ->
      block-skip 0pt
        +++ read-block ctx '<+Book.example{#it;}>
        +++ line-break false true (ctx |> set-paragraph-margin 0pt 0pt) inline-fil
    )


let-inline ctx \val ?:indexopt it-cmd ty =
  val-scheme ctx indexopt it-cmd ty None


let-inline ctx \val-explain ?:indexopt it-cmd ty it =
  val-scheme ctx indexopt it-cmd ty (Some(it))


let-inline ctx \type ty =
  script-guard Latin (embed-math ctx (Type.to-math true ty))


let-inline ctx \meta it =
  let ctx =
    ctx |> Book.set-latin-font Book.font-latin-italic
  in
    read-inline ctx it


let-inline ctx \metasub msub it =
  read-inline ctx {${\text!{\meta{#it;}}_{#msub}}}


let-inline ctx \meta-star it =
  embed-math ctx ${\sqbracket{\text!{#it;}}^{\ast}}


let-inline ctx \meta-or its =
  let m =
    math-paren-with-middle Math.paren-left Math.paren-right Math.bar-middle
      (its |> List.map (fun it -> ${\text!{#it;}}))
  in
    embed-math ctx m


let-inline ctx \inline-frame inner =
  let pads = (2pt, 2pt, 2pt, 2pt) in
  let decoset = HDecoSet.simple-frame-stroke 0.5pt Color.black in
    inline-frame-breakable pads decoset (read-inline ctx inner)


let-math \tuple mlst =
  let m = Math.join ${,} mlst in
    ${\paren{#m}}


let-block ctx +d-block content =
  let pads = (10pt, 10pt, 5pt, 5pt) in
  let decoset = VDecoSet.paper in
    block-frame-breakable ctx pads decoset (fun ctx -> read-block ctx content)


let-inline ctx \d-block content =
  inline-fil ++
    embed-block-breakable ctx (read-block ctx '<+d-block(content);>)


let-inline ctx \fbox it =
  let pads = (2pt, 2pt, 2pt, 2pt) in
  let t = 0.5pt in
  let deco (x, y) w h d =
    [ stroke t Color.black (Gr.rectangle (x, y -' d) (x +' w, y +' h)) ]
  in
    inline-frame-inner pads deco (read-inline ctx it)


type position-spec =
  | Top
  | Bottom


let-inline ctx \parbox ?:specopt wid ib =
  let blockf =
    match specopt with
    | None         -> embed-block-top ctx wid
    | Some(Top)    -> embed-block-top ctx wid
    | Some(Bottom) -> embed-block-bottom ctx wid
  in
    blockf (fun ctx -> read-block ctx ib)


let-inline ctx \as-latin-word it =
  script-guard Latin (read-inline ctx it)


let-inline ctx \stack len its =
  let bbf ctx =
    its
      |> List.map (fun it ->
        line-break true true (ctx |> set-paragraph-margin 4pt 4pt)
          (read-inline ctx it ++ inline-fil))
      |> List.fold-left (+++) block-nil
  in
  embed-block-top ctx len bbf


let structure-box r hw (x, y) it =
  let rect = Gr.rectangle (x -' hw, y -' 0.25cm) (x +' hw, y +' 0.5cm) in
  [
    fill Color.white rect;
    stroke 0.5pt Color.black rect;
    r#text-centering (x, y) it;
  ]


let structure-arrow-color = Color.black
let structure-arrow-half-width = 0.125cm
let structure-arrow-head-length = 0.2cm
let structure-arrow-head-width = 0.25cm


let structure-arrow-down x y1 y2 =
  let color = structure-arrow-color in
  let hw = structure-arrow-half-width in
  let trih = structure-arrow-head-length in
  let trihw = structure-arrow-head-width in
  [
    fill color (Gr.rectangle (x -' hw, y1) (x +' hw, y2 +' trih));
    fill color (Gr.polygon
      (x -' trihw, y2 +' trih) [
        (x +' trihw, y2 +' trih);
        (x, y2);
      ]);
  ]


let structure-arrow-left-head (x1, y) =
  let color = structure-arrow-color in
  let trih = structure-arrow-head-length in
  let trihw = structure-arrow-head-width in
  [
    fill color (Gr.polygon
      (x1, y +' trihw) [
        (x1, y -' trihw);
        (x1 -' trih, y);
      ])
  ]

let structure-arrow-left x1 x2 y =
  let color = structure-arrow-color in
  let trih = structure-arrow-head-length in
  let hw = structure-arrow-half-width in
  List.append [
    fill color (Gr.rectangle (x1 +' trih, y -' hw) (x2, y +' hw));
  ] (structure-arrow-left-head (x1 +' trih, y))


let structure-bend path =
  let color = structure-arrow-color in
  let hw = structure-arrow-half-width in
%  let trih = 0.2cm in
%  let trihw = 0.25cm in
  [
    stroke (hw *' 2.) color path;
%    fill color (Gr.polygon (x -' trihw, y) [
%        (x +' trihw, y);
%        (x, y -' trih);
%      ]);
  ]
